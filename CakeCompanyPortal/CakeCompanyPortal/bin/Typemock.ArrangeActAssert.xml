<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Typemock.ArrangeActAssert</name>
  </assembly>
  <members>
    <member name="T:TypeMock.DesignModeException">
      <summary>
            Can be thrown when using one of the methods that is used in DesignMode.InterfaceOnly
            </summary>
    </member>
    <member name="M:TypeMock.DesignModeException.#ctor">
      <summary>
            Thrown when using one of the following methods is used in DesignMode.InterfaceOnly:
            <list type="bullet"><item><description>Isolate.Fake.StaticMethods</description></item><item><description>Isolate.Fake.StaticConstructor</description></item><item><description>All Isolate.NonPublic APIs</description></item><item><description>All Isolate.Swap�. APIs</description></item><item><description>Isolate.Fake.Instance for sealed objects, or a non-virtual method</description></item><item><description>Isolate.Fake.Dependencies if one or more dependencies are
            sealed or have only non-virtual methods.</description></item><item><description>Isolate.WhenCalled APIs used on non-virtual methods or live objects</description></item><item><description>Isolate.Verify APIs used on non-virtual methods or live objects</description></item></list></summary>
    </member>
    <member name="M:TypeMock.DesignModeException.#ctor(System.String)">
      <summary>
            Thrown when using one of the following methods is used in DesignMode.InterfaceOnly:
            <list type="bullet"><item><description>Isolate.Fake.StaticMethods</description></item><item><description>Isolate.Fake.StaticConstructor</description></item><item><description>All Isolate.NonPublic APIs</description></item><item><description>All Isolate.Swap�. APIs</description></item><item><description>Isolate.Fake.Instance for sealed objects, or a non-virtual method</description></item><item><description>Isolate.Fake.Dependencies if one or more dependencies are
            sealed or have only non-virtual methods.</description></item><item><description>Isolate.WhenCalled APIs used on non-virtual methods or live objects</description></item><item><description>Isolate.Verify APIs used on non-virtual methods or live objects</description></item></list><param name="message"> The message that will show on the exception text</param></summary>
    </member>
    <member name="T:TypeMock.Scope">
      <exclude />
      <summary>
            Scope of Mock 
            </summary>
    </member>
    <member name="F:TypeMock.Scope.Instance">
      <summary>
      </summary>
    </member>
    <member name="F:TypeMock.Scope.Static">
      <summary>
      </summary>
    </member>
    <member name="F:TypeMock.Scope.All">
      <summary>
      </summary>
    </member>
    <member name="T:TypeMock.InternalMocking">
      <summary>
            A struct that is responsible for enabling and disabling <see cref="T:TypeMock.MockManager" />.
            </summary>
    </member>
    <member name="M:TypeMock.InternalMocking.StopMocking">
      <summary>
            Responsible for disabling <see cref="T:TypeMock.MockManager" />.
            </summary>
      <returns> A locked <see cref="T:TypeMock.InternalMocking" /> struct.</returns>
      <example>
        <code>
            using (InternalMocking.StopMocking())
             {
              // content..
             }
            </code>
      </example>
    </member>
    <member name="M:TypeMock.InternalMocking.EnableMocking">
      <summary>
            Responsible for enabling <see cref="T:TypeMock.MockManager" />.
            </summary>
      <returns> An unlocked <see cref="T:TypeMock.InternalMocking" /> struct.</returns>
      <example>
        <code>
            using (InternalMocking.EnableMocking())
             {
              // content...
             }
            </code>
      </example>
    </member>
    <member name="M:TypeMock.InternalMocking.Dispose">
      <summary>
            Responsible for disposing <see cref="T:TypeMock.InternalMocking" />.
            </summary>
    </member>
    <member name="M:TypeMock.Assign.#ctor(System.Object)">
      <summary>
            Create a new Assign object that will mock ref and out arguments
            </summary>
      <remarks>
            Use in conjunction with <see cref="T:TypeMock.IParameters" /></remarks>
      <param name="value">The value to assign the parameter</param>
    </member>
    <member name="M:TypeMock.Assign.AndCheck(System.Object)">
      <summary>
            Validate the parameter before assigning it a value.
            </summary>
      <param name="expectation">Expected value or parameter checker</param>
      <returns>The parameter assigner</returns>
    </member>
    <member name="M:TypeMock.Assign.IsCheckingSameType(System.Object)">
      <summary>
            A boolean method the checks if the "other" object is the same type as the object that called the method.
            </summary>
      <param name="other"> the object to compare</param>
      <returns>
            Boolean, true - if they have the sdame type and false otherwise
            </returns>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.CalledType">
      <summary>
            Type in which the method was called from
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.CalledMethodName">
      <summary>
            Name of method that was called
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.SentArguments">
      <summary>
            Array of the Argument that where went
            </summary>
      <remarks>
            The arguments are read only, setting these to other values will not change the arguments.
            To assign other values see <see cref="T:TypeMock.Assign" /></remarks>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.ExpectedArguments">
      <summary>
            Array of the expected arguments sent to the Args method (see <see cref="T:TypeMock.IParameters" /> )
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.WillThrowException">
      <summary>
            This is true if the mocked method will throw an exception,
            Either because the exception was mocked (see <see cref="M:TypeMock.Mock.ExpectAndThrow(System.String,System.Exception,System.Type[])" /> or
            because of a validation exception.
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.Exception">
      <summary>
            This is the exception that will be thrown (null unless <see cref="P:TypeMock.MockMethodCallEventArgs.WillThrowException" /> 
            is true.
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.ReturnValue">
      <summary>
            The mocked return value (null if <see cref="P:TypeMock.MockMethodCallEventArgs.WillThrowException" /> is true)
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.HasPassedValidation">
      <summary>
            This is true if the method has passed all validations
            </summary>
    </member>
    <member name="P:TypeMock.MockMethodCallEventArgs.IsStaticMethod">
      <summary>
            This is true if the method is static
            </summary>
    </member>
    <member name="T:TypeMock.CannotEvaluateWhileRecordingException">
      <summary>
            TypeMockException is thrown when there is an attempt to evaluate methods inside a recording block.
            </summary>
    </member>
    <member name="M:TypeMock.CannotEvaluateWhileRecordingException.#ctor">
      <summary>
            Initializes a new instance of the CannotEvaluateWhileRecordingException class an error message.
            </summary>
    </member>
    <member name="M:TypeMock.CannotEvaluateWhileRecordingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the CannotEvaluateWhileRecordingException class with serialized data.
            </summary>
      <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
    </member>
    <member name="T:TypeMock.CompoundCheck">
      <summary>
            Summary description for CompoundCheck.
            </summary>
    </member>
    <member name="T:TypeMock.InternalCheck">
      <summary>
            Summary description for InternalCheck.
            </summary>
    </member>
    <member name="T:TypeMock.IsCloseCheck">
      <summary>
            Summary description for IsCloseCheck.
            </summary>
    </member>
    <member name="T:TypeMock.StateFullDelegate">
      <summary>
            Summary description for StateFullDelegate.
            </summary>
    </member>
    <member name="T:TypeMock.StringCheck">
      <summary>
            Summary description for StringCheck.
            </summary>
    </member>
    <member name="T:TypeMock.VerifyMessageBuilder">
      <summary>
            Helper for building failure messages
            </summary>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.#ctor(System.String,System.Object[])">
      <summary>
            Create a Message Builder
            </summary>
      <param name="message">Custom message</param>
      <param name="args">Arguments for custom message</param>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.AddToPrefix(System.String)">
      <summary>
            Add message to prefix, remember current prefix
            </summary>
      <param name="prefix">Message to add</param>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.RemoveLastPrefix">
      <summary>
            Restore prefix to last known
            </summary>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.SetMessage(TypeMock.ParameterCheckerEventArgs,System.String)">
      <summary>
            Set message with one text
            </summary>
      <param name="data">Information about the checked argument</param>
      <param name="message">Error Message</param>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.SetMessage(TypeMock.ParameterCheckerEventArgs,System.Object,System.Object)">
      <summary>
            Set message with expected and actual objects
            </summary>
      <param name="data">Information about the checked argument</param>
      <param name="expected">The expected argument</param>
      <param name="actual">The actual argument</param>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.SetMessage(TypeMock.ParameterCheckerEventArgs,System.String,System.Object,System.Object)">
      <summary>
            Set message with prefix string and expected and actual objects
            </summary>
      <param name="data">Information about the checked argument</param>
      <param name="prefix">Prefix to add to message</param>
      <param name="expected">The expected argument</param>
      <param name="actual">The actual argument</param>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.ToString">
      <summary>
            Get Message string
            </summary>
      <returns>The message string</returns>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.BuildCallString(TypeMock.ParameterCheckerEventArgs)">
      <summary>
            Default message prefix that can be added to the message
            </summary>
      <remarks>
            The message is: Call to [namespace.method] Parameter: [number] 
            </remarks>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.DisplayString(System.Object)">
      <summary>
            Display an object as a string
            </summary>
      <param name="obj">The object to display</param>
      <returns>String representation of object</returns>
    </member>
    <member name="M:TypeMock.VerifyMessageBuilder.Quoted(System.String)">
      <summary>
            Quote a string
            </summary>
      <param name="text">Text to Quote</param>
      <returns>Quoted string</returns>
    </member>
    <member name="P:TypeMock.VerifyMessageBuilder.CustomMessage">
      <summary>
            Set/Get the CustomMessage
            </summary>
    </member>
    <member name="P:TypeMock.VerifyMessageBuilder.PrefixMessage">
      <summary>
            Set/Get Prefix to add before message
            </summary>
    </member>
    <member name="P:TypeMock.VerifyMessageBuilder.Message">
      <summary>
            Get Message String
            </summary>
    </member>
    <member name="M:TypeMock.ClearMocksAttribute.Execute">
      <summary>
            Called by the framework instead of the original method. This will run the original method and 
            afterwards clear the Mock Manager.
            </summary>
      <returns> the result of the original method</returns>
    </member>
    <member name="T:TypeMock.DecoratorAttribute">
      <summary>
            This is the base class for all decorator attributes.
            In order to implement a custom attribute, need to subclass DecoratorAttribute and implement the
            abstract method execute. 
            </summary>
      <remarks>
            The custom attribute can control the flow of the call to the original method by 
            calling the CallOriginalMethod method during the execute method.
            In any case even if the original method is not activated by the custom attribute it will be run by the decorator
            framework
            </remarks>
    </member>
    <member name="F:TypeMock.DecoratorAttribute.m_Decorator">
      <summary>
            Referance to the decorator object which holds data of the original method
            </summary>
    </member>
    <member name="F:TypeMock.DecoratorAttribute.m_DecoratedMethod">
      <summary>
            The method that is decorated by the attribute.
            </summary>
    </member>
    <member name="M:TypeMock.DecoratorAttribute.Execute">
      <summary>
                The propriety logic of the attribute should be implemented in the execute. The
                custom attribute can control the flow of the call to the original method by calling
                the CallOriginalMethod method during the execute method. In any case even if the
                original method is not activated by the custom attribute it will be run by the
                decorator framework, unless the attribute specifically asked that the original
                method will not be called using the
                <see cref="M:TypeMock.DecoratorAttribute.DontCallDecoratedMethod">DontCallDecoratedMethod Method</see></summary>
      <returns>The results from activating the original invoker on the test (unless overridden)</returns>
    </member>
    <member name="M:TypeMock.DecoratorAttribute.Decorate(TypeMock.MethodDecorator,TypeMock.ExecutionDelegator)">
      <summary>
            Replace the call to the original method with the call to the attribute execute, storing all needed information
            </summary>
      <param name="decorator">The MethodDecorator instance which holds the original method data</param>
      <param name="methodToDecorate">The method that needs to be decorated</param>
      <returns>ExecutionDelegator representing the method after decoration</returns>
    </member>
    <member name="M:TypeMock.DecoratorAttribute.DecorateMethodWhenAttributeIsClass(System.Reflection.MethodBase)">
      <summary>
            Filter which methods to Execute the code, when the attribute is on a Class
            </summary>
      <param name="methodBase">method being executed</param>
      <returns>true to wrap the code</returns>
      <remarks>Default action is to apply class decorators only on test methods 
            i.e. methods that are decorated with [Test] or [TestMethod] attribute on them as well</remarks>
    </member>
    <member name="M:TypeMock.DecoratorAttribute.CallDecoratedMethod">
      <summary>
            Activate the original (decorated) method.
            </summary>
      <returns>The results from activating the original method</returns>
    </member>
    <member name="M:TypeMock.DecoratorAttribute.DontCallDecoratedMethod">
      <summary>
                Stops the decorator from calling the original method which is called automatically
                even when <see cref="M:TypeMock.DecoratorAttribute.Execute">Execute</see> method fails to call
                <see cref="M:TypeMock.DecoratorAttribute.CallDecoratedMethod">CallDecoratedMethod</see>.
            </summary>
      <remarks>If original method is decorated by another attribute and
            explicitly called there. It will be
            activated</remarks>
    </member>
    <member name="P:TypeMock.DecoratorAttribute.IgnoreStaleMocks">
      <summary>
            When set Typemock will not track stale mocks.
            A stale mock is an object that was faked in a previous test is used in current test. 
            This may lead to an unexpected behavior.
            </summary>
    </member>
    <member name="P:TypeMock.DecoratorAttribute.OriginalMethod">
      <summary>
            Retrieves the Original method info (the method which is tagged by the attribute)
            </summary>
    </member>
    <member name="P:TypeMock.DecoratorAttribute.OriginalContext">
      <summary>
            Retrieves the instance that the original method was called with.
            </summary>
    </member>
    <member name="P:TypeMock.DecoratorAttribute.OriginalParams">
      <summary>
            Retrieves the original parameters that were passed to the original method
            </summary>
    </member>
    <member name="P:TypeMock.DecoratorAttribute.IsTearDown">
      <summary>
            Signals that the method being called is a teardown method
            </summary>
    </member>
    <member name="P:TypeMock.DecoratorAttribute.HasTearDown">
      <summary>
            Signals that the test has a teardown method
            </summary>
    </member>
    <member name="T:TypeMock.DefaultRecordBehavior">
      <summary>
            Change the default Behavior of Natural Mocks�
            </summary>
      <remarks>
            The default Behavior of Natural Mocks is
            <list type="bullet"><item>Repeat once (See <see cref="M:TypeMock.IMockBehavior.Repeat(System.Int32)" />)</item><item>Ignore Arguments (See <see cref="M:TypeMock.IMockBehavior.IgnoreArguments" />)</item></list>
            To change this use DefaultBehavior.
            This is useful for chained natural mocks where we require the whole chain to be checked.
            <para><example>
            Example of using Natural Mocks� repeat always, 
            we will always return 10 when GetSomething().DoSomething() is called from any TestedClass instance
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // make all future instances mocked and all statements repeat
                   recorder.DefaultBehavior.RepeatAlways();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething().DoSomething();
                   // always return 10
                   recorder.Return(10);
                }
            }
            </code><code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' make all future instances mocked and all statements repeat
                   recorder.DefaultBehavior.RepeatAlways()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething().DoSomething()
                   ' always return 10
                   recorder.Return(10)
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations" /></example></para><seealso cref="P:TypeMock.RecordExpectations.DefaultBehavior" /></remarks>
    </member>
    <member name="M:TypeMock.DefaultRecordBehavior.CheckArguments">
      <summary>
            Check All Arguments of statements
            </summary>
      <remarks>
            Using CheckArguments will fail tests if the arguments actually passed are not those that where expected.
            Special care must be taken when changing the default expectation, as the statement CheckArguments now
            must include an item for all arguments passed.
            <para><example>
            Example of using Natural Mocks� CheckArguments with multiple statements, 
            we will validate that GetSomething("TypeMock").DoSomething("magic") is called with "TypeMock" and "magic"
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething("TypeMock").DoSomething("magic");
                }
            }
            </code><code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething("TypeMock").DoSomething("magic")
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations" /></example><example>
            Example of using Natural Mocks� CheckArguments with multiple statements, 
            we will validate the arguments with built-in checks
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething(null).DoSomething(null);
                   recorder.CheckArguments(Check.IsIn("TypeMock", "NaturalMock"),Check.StartsWith("s"));
                }
            }
            </code><code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething(null).DoSomething(null);
                   recorder.CheckArguments(Check.IsIn("TypeMock","NaturalMock"),Check.StartsWith("s"))
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations" /></example></para><seealso cref="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])" /></remarks>
    </member>
    <member name="M:TypeMock.DefaultRecordBehavior.WhenArgumentsMatch">
      <summary>
            Mock method only when arguments passed are as expected
            </summary>
      <remarks>
            See <see cref="M:TypeMock.IMockBehavior.WhenArgumentsMatch(System.Object[])" /><note>Care should be taken when using this in a chained statement.
            There is no backtracking and after one method is mocked a mock is returned even if the next statement
            is not mocked.
            </note><seealso cref="M:TypeMock.IMockBehavior.WhenArgumentsMatch(System.Object[])" /></remarks>
    </member>
    <member name="M:TypeMock.DefaultRecordBehavior.IgnoreArguments">
      <summary>
            Don't verify arguments, this is the default.
            </summary>
      <remarks>
        <seealso cref="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])" />
      </remarks>
    </member>
    <member name="M:TypeMock.DefaultRecordBehavior.Repeat(System.Int32)">
      <summary>
            Repeat each statement. 
            </summary>
      <remarks>See <seealso cref="M:TypeMock.IMockBehavior.Repeat(System.Int32)" /></remarks>
      <param name="timesToRun">Amount of times to repeat the expectation</param>
      <returns>Use to change more Behavior</returns>
    </member>
    <member name="M:TypeMock.DefaultRecordBehavior.RepeatAlways">
      <summary>
            Repeat each statement for every call. 
            </summary>
      <remarks>See <seealso cref="M:TypeMock.IMockBehavior.RepeatAlways" /></remarks>
      <returns>Use to change more Behavior</returns>
    </member>
    <member name="P:TypeMock.DefaultRecordBehavior.Strict">
      <summary>
            Flags that define the behavior of Arbitrary (not expected) calls.
            The default is the Methods of Abstract and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
      <remarks>
            When testing for mock interactions there are times when the default behavior needs to be changed, 
            the StrictFlags define which arbitrary methods we allow.
            <note>
            When allowing arbitrary abstract methods (methods created dynamically by Typemock Isolator using <see cref="M:TypeMock.MockManager.MockObject(System.Type,TypeMock.Constructor,System.Object[])" /> or <see cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.StrictFlags,System.Object[])" />), 
            Typemock Isolator create the following default behavior:
            1. All void calls just return
            2. Other Methods will return 0 or null depending on the return type
            3. Properties will behave like normal properties
            </note><note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)" /> or <see cref="M:TypeMock.RecordExpectations.FailWhenCalled(System.Object)" /></note></remarks>
    </member>
    <member name="P:TypeMock.DefaultRecordBehavior.AutomaticFieldMocking">
      <summary>
            Flags that define the behavior of Field handling calls.
            By default internal fields are mocked according to the state of the appropriate 
            constructor(i.e. if the constructor is mocked then the field will be mocked as well),
            which means that any uninitialized field (its value is null) will be replaced with a mocked 
            object during the recording phase.
            values of static fields will be reverted back at the end of the test before any calls to 
            a method on the class. 
            </summary>
      <remarks>
            only the immediate level of fields is automatically mocked. i.e. fields of fields are not mocked.
            </remarks>
    </member>
    <member name="P:TypeMock.DefaultRecordBehavior.MockStaticConstructors">
      <summary>
            Flags that define the default behavior of static constructors mocking.
            By default all static constructors of objects created inside a recording block will 
            not be mocked. 
            Setting this flag to true will cause static constructors of newly created object to be mocked.
            (the real static constructor will be executed when needed after the test ends.)
            </summary>
    </member>
    <member name="T:TypeMock.ExpectationBlock">
      <summary>
            An expectation block (Enterprise Edition Only)
            </summary>
      <remarks>
        <para>
            Group a number of expectation. Define an expectation block using Mock.<see cref="M:TypeMock.Mock.StartBlock" /> and Mock.<see cref="M:TypeMock.Mock.EndBlock" />. 
            When grouping expectations in a block you can control
            The expectation dynamically. This is very useful when setting up a mock infrastructure.
            After defining a block it is possible to:
            <list type="number"><item>Remove the block using Mock.<see cref="M:TypeMock.Mock.Clear(TypeMock.ExpectationBlock)" />.
            </item><item>
            Add expectations before the block using Mock.<see cref="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock)" />.
            </item></list>
            
            Blocks can be labeled and can be later on referred to by Mock.<see cref="M:TypeMock.Mock.GetBlock(System.String)" />.
            
            Blocks can have different <see cref="T:TypeMock.VerifyMode" />s.
            <example>
            The following example shows a utility method that sets up expectations 
            for an AccessController
            <code lang="cs">
            private Mock SetupExpectations()
            {
            	//Mock all invocation of AccessController, 
            	Mock mock = MockManager.MockAll(typeof(AccessController));
            
            	// start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal);
            	 // We expect that the login method will be called and we will return 
            	 // AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 // second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	return mock;
            }
            [Test]
            public void TestSomething()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"));
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// continue with test
            }
            [Test]
            public void TestSomething2()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"));
            	
            	// continue with test
            }
            </code><code lang="vbnet">
            Private Function SetupExpectations() As Mock 
            	'Mock all invocation of AccessController, 
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal)
            	 ' We expect that the login method will be called and we will return 
            	 ' AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 ' second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	SetupExpectations = mock
            End Function
            &lt;Test()&gt; _
            Public Sub TestSomething()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"))
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' continue with test
            End Sub
            &lt;Test()&gt; _
            Public Sub TestSomething2()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"))
            	
            	' continue with test
            End Sub
            </code></example><seealso cref="T:TypeMock.VerifyMode" /><seealso cref="M:TypeMock.Mock.GetBlock(System.String)" /><seealso cref="M:TypeMock.Mock.Clear" /></para>
      </remarks>
      <returns>The Expectation Block</returns>
    </member>
    <member name="F:TypeMock.ExpectationBlock.FIRST_FREE_ID">
      <summary>
            first two ids are reserved for firstBlock and lastBlock.
            </summary>
    </member>
    <member name="P:TypeMock.ExpectationBlock.Name">
      <summary>
            Return the default expectation block
            </summary>
      <summary>
            The Name or Label of the Block
            </summary>
    </member>
    <member name="T:TypeMock.Generic">
      <summary>
            This class helps strongly type generic method types when using Reflective Mocks
            </summary>
      <remarks>
            Following is an example of using Generic
            <example><code>
            [Test]
            public void MockGenericMethod()
            {
               Mock mock = Mock&lt;MockedClass&gt;.MockNextInstance();
               mock.AlwaysReturn("Method", 11, Generic.Method&lt;int&gt;());
               MockedClass test = new MockedClass();
               Assert.AreEqual(11, test.Method&lt;int&gt;(1));
            }
            </code><code lang="VB">
            &lt;Test()&gt; _
            Public Sub MockGenericMethod()
               Dim mock As Mock = Mock(Of MockedClass).MockNextInstance()
               mock.AlwaysReturn("Method", 11, Generic.Method(Of Integer)());
               Assert.AreEqual(11, test.Method(Of Integer)(1));
            End Sub
            </code></example></remarks>
    </member>
    <member name="M:TypeMock.Generic.Method``1">
      <summary>
            Define Expectations of Generic Methods with 1 generic parameter
            </summary>
      <typeparam name="TArg0">Method Generic Parameter</typeparam>
      <returns>Types of generic parameters</returns>
      <remarks>
            See <see cref="T:TypeMock.Generic" /> for an example
            </remarks>
    </member>
    <member name="M:TypeMock.Generic.Method``2">
      <summary>
            Define Expectations of Generic Methods with 2 generic parameter
            </summary>
      <typeparam name="TArg0">Method Generic Parameter 1</typeparam>
      <typeparam name="TArg1">Method Generic Parameter 2</typeparam>
      <returns>Types of generic parameters</returns>
      <remarks>
            See <see cref="T:TypeMock.Generic" /> for an example
            </remarks>
    </member>
    <member name="M:TypeMock.Generic.Method``3">
      <summary>
            Define Expectations of Generic Methods with 3 generic parameter
            </summary>
      <typeparam name="TArg0">Method Generic Parameter 1</typeparam>
      <typeparam name="TArg1">Method Generic Parameter 2</typeparam>
      <typeparam name="TArg2">Method Generic Parameter 3</typeparam>
      <returns>Types of generic parameters</returns>
      <remarks>
            See <see cref="T:TypeMock.Generic" /> for an example
            </remarks>
    </member>
    <member name="M:TypeMock.Generic.Method``4">
      <summary>
            Define Expectations of Generic Methods with 4 generic parameter
            </summary>
      <typeparam name="TArg0">Method Generic Parameter 1</typeparam>
      <typeparam name="TArg1">Method Generic Parameter 2</typeparam>
      <typeparam name="TArg2">Method Generic Parameter 3</typeparam>
      <typeparam name="TArg3">Method Generic Parameter 4</typeparam>
      <returns>Types of generic parameters</returns>
      <remarks>
            See <see cref="T:TypeMock.Generic" /> for an example
            </remarks>
    </member>
    <member name="P:TypeMock.IMethodSettings.IsStrict">
      <summary>
            Can set one method of the mock to be Strict
            </summary>
      <remarks>
            By default Mocked Types are NOT strict this mean that if a call to a mocked
            method was not expected the normal code is executed.
            Mocked Types can be made strict and fail if an unexpected call is made
            <example><code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	// No expectations, the following will fail because passInt() is 
            	// set to Strict
            	mock.MethodSettings("passInt").IsStrict = true;
            	t.passInt(10);
            	MockManager.Verify();
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            {
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	' No expectations, the following will fail because passInt() is 
            	' set to Strict
            	mock.MethodSettings("passInt").IsStrict = True
            	t.passInt(10)
            	MockManager.Verify()
            End Sub
            </code></example><seealso cref="T:TypeMock.VerifyMode" /></remarks>
    </member>
    <member name="E:TypeMock.IMethodSettings.MockMethodCalled">
      <summary>
            Event that is fired after a mocked method is called and after validation is performed
            <see cref="T:TypeMock.MockMethodCalledEventHandler" /><seealso cref="T:TypeMock.MockMethodCalledEventHandler" /></summary>
      <remarks>
            To set an event for all calls see Mock.<see cref="E:TypeMock.Mock.MockMethodCalled" /><example><code lang="cs">
            // This will be called when a mocked method is called
            private void SuccessEvent(object sender,MockMethodCallEventArgs e) 
            {
            	Assert.AreEqual(typeof(TestedClass),e.CalledType);
            	Assert.AreEqual("getVar",e.CalledMethodName);
            	Assert.AreEqual(0,e.SentArguments.Length);
            	Assert.AreEqual(0,e.ExpectedArguments.Length);
            	Assert.AreEqual(false,e.WillThrowException);
            	Assert.AreEqual(null,e.Exception);
            	Assert.AreEqual(5,e.ReturnValue);
            	Assert.AreEqual(true,e.HasPassedValidation);
            }
            [Test]
            public void SimpleEventSuccess() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass),false);
            	TestedClass t = new TestedClass();
            	
            	mock.ExpectAndReturn("getVar",5);
            	// set event listener
            	mock.MethodSettings("getVar").MockMethodCalled += new MockMethodCalledEventHandler(SuccessEvent);
            	// the event will be called
            	Assert.AreEqual(5,t.getVar());
            	mock.Verify();
            }
            </code><code lang="vbnet">
            ' This will be called when a mocked method is called
            Public Shared Sub SuccessEvent(ByVal sender As Object, ByVal e As MockMethodCallEventArgs) 
            	Assert.AreEqual(GetType(TestedClass),e.CalledType)
            	Assert.AreEqual("getVar",e.CalledMethodName)
            	Assert.AreEqual(0,e.SentArguments.Length)
            	Assert.AreEqual(0,e.ExpectedArguments.Length)
            	Assert.AreEqual(False,e.WillThrowException)
            	Assert.AreEqual(Nothing,e.Exception)
            	Assert.AreEqual(5,e.ReturnValue)
            	Assert.AreEqual(True,e.HasPassedValidation)
            End Sub
            
            &lt;Test()&gt; _
            Public Sub SimpleEventSuccess()
            	Dim t As TestedClass = new TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	
            	mock.ExpectAndReturn("getVar",5)
            	' set event listener
            	AddHandler mock.MethodSettings("getVar").MockMethodCalled, AddressOf SuccessEvent
            	
            	' the event will be called
            	Assert.AreEqual(5,t.getVar())
            	mock.Verify()
            End Sub
            </code></example></remarks>
    </member>
    <member name="M:TypeMock.IMockControl.MethodSettings(System.String)">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler. Properties and 
            indexes can be tweaked using <see cref="M:TypeMock.IMockControl.MethodSettingsGetProperty(System.String)" />,
            <see cref="M:TypeMock.IMockControl.MethodSettingsSetProperty(System.String)" />, <see cref="M:TypeMock.IMockControl.MethodSettingsGetIndex" /> 
            and <see cref="M:TypeMock.IMockControl.MethodSettingsSetIndex" /><seealso cref="M:TypeMock.IMockControl.MethodSettingsGetProperty(System.String)" /><seealso cref="M:TypeMock.IMockControl.MethodSettingsSetProperty(System.String)" /><seealso cref="M:TypeMock.IMockControl.MethodSettingsGetIndex" /><seealso cref="M:TypeMock.IMockControl.MethodSettingsSetIndex" /></remarks>
      <param name="methodName">Name of method</param>
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.IMockControl.MethodSettingsGetProperty(System.String)">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <param name="propertyName">Name of Property</param>
      <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.IMockControl.MethodSettingsSetProperty(System.String)">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <param name="propertyName">Name of Property</param>
      <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.IMockControl.MethodSettingsGetIndex">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.IMockControl.MethodSettingsSetIndex">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectConstructor">
      <summary>
            Mock Constructor 
            </summary>
      <remarks>
            Using <c>ExpectConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectConstructor(System.Int32)">
      <summary>
            Mock Constructor
            </summary>
      <remarks>
            Using <c>ExpectConstructor </c> will verify that a constructor has been called and can be used to validate the arguments passed
            to the constructor
            </remarks>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectConstructorAlways">
      <summary>
            Mock unlimited calls from Constructor
            </summary>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectConstructorAndThrow(System.Exception)">
      <summary>
            Mock Constructor and throw exception when constructor is called
            </summary>
      <remarks>
            Using <c>ExpectConstructorAndThrow </c> will throw an exception when the constructor
            is called
            </remarks>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedConstructor">
      <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
      <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedConstructor(System.Int32)">
      <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
      <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedCall(System.String,System.Type[])">
      <summary>
            Verify 1 call from method , continue with method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedCall(System.String,System.Int32,System.Type[])">
      <summary>
            Verify a number of calls from method , continue with method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="timesToRun">Number of times to expect</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectCall(System.String,System.Type[])">
      <summary>
            Expect 1 call from method
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectCall(System.String,System.Int32,System.Type[])">
      <summary>
            Expect a number of calls from method
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])">
      <summary>
            Expect 1 call from method, and mock return value
            </summary>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
      <seealso cref="T:TypeMock.Check" />
      <seealso cref="T:TypeMock.IParameters" />
      <seealso cref="T:TypeMock.ParameterChecker" />
      <seealso cref="T:TypeMock.DynamicReturnValue" />
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Int32,System.Type[])">
      <summary>
            Expect a number of calls from method, and mock return value
            </summary>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
      <seealso cref="T:TypeMock.Check" />
      <seealso cref="T:TypeMock.IParameters" />
      <seealso cref="T:TypeMock.ParameterChecker" />
      <seealso cref="T:TypeMock.DynamicReturnValue" />
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAndThrow(System.String,System.Exception,System.Type[])">
      <summary>
            Expect 1 call from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="method">Method Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAndThrow(System.String,System.Exception,System.Int32,System.Type[])">
      <summary>
            Expect a number of calls from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="method">Method Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAlways(System.String,System.Type[])">
      <summary>
            Expect unlimited calls from method
            </summary>
      <param name="method">Method Name</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.IMockControl.AlwaysReturn(System.String,System.Object,System.Type[])">
      <summary>
            Expect unlimited calls from method, and always returns mock value
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.IMockControl.AlwaysReturn(System.String,System.Object,System.Type[])" /> is used together with <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the <see cref="M:TypeMock.IMockControl.AlwaysReturn(System.String,System.Object,System.Type[])" /> value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></remarks>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
    </member>
    <member name="M:TypeMock.IMockControl.AlwaysThrow(System.String,System.Exception,System.Type[])">
      <summary>
            Expect unlimited calls from method, and always throws exception
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.IMockControl.AlwaysThrow(System.String,System.Exception,System.Type[])" /> is used together with <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the method will throw the <see cref="M:TypeMock.IMockControl.AlwaysThrow(System.String,System.Exception,System.Type[])" /> value
            </remarks>
      <param name="method">Method Name</param>
      <param name="ex">Mocked exception</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSet(System.String)">
      <summary>
            Expect 1 set of a Property
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSet(System.String,System.Int32)">
      <summary>
            Expect a number of sets of a Property
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="timesToRun">Number of times to expect the set</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetAlways(System.String)">
      <summary>
            Expect unlimited set of a Property
            </summary>
      <param name="property">Property Name</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetAndThrow(System.String,System.Exception)">
      <summary>
            Expect 1 set of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetAndThrow(System.String,System.Exception,System.Int32)">
      <summary>
            Expect  a number of sets of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetAndAlwaysThrow(System.String,System.Exception)">
      <summary>
            Expect unlimited set of a Property and always mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedSet(System.String)">
      <summary>
            Verify 1 set of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedSet(System.String,System.Int32)">
      <summary>
            Verify a number of sets of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGet(System.String,System.Object)">
      <summary>
            Expect 1 get of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="property">Property Name</param>
      <param name="value">Mocked value</param>
      <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGet(System.String,System.Object,System.Int32)">
      <summary>
            Expect a number of gets of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="property">Property Name</param>
      <param name="value">Mocked value</param>
      <param name="timesToRun">Number of times to expect the gets</param>
      <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetAlways(System.String,System.Object)">
      <summary>
            Expect unlimited get of a Property and always mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="property">Property Name</param>
      <param name="value">Mocked value</param>
      <exception cref="T:TypeMock.TypeMockException">If property is not found or is not correct value type</exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetAndThrow(System.String,System.Exception)">
      <summary>
            Expect 1 get of a Property and mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetAndThrow(System.String,System.Exception,System.Int32)">
      <summary>
            Expect a number of gets of a Property and mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of calls to expect</param>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetAndAlwaysThrow(System.String,System.Exception)">
      <summary>
            Expect unlimited get of a Property and always mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedGet(System.String)">
      <summary>
            Verify 1 get of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectUnmockedGet(System.String,System.Int32)">
      <summary>
            Verify a number of gets of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetIndex">
      <summary>
            Expect 1 set of an Index
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetIndex(System.Int32)">
      <summary>
            Expect a number of sets of an Index
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="timesToRun">Number of sets to expect</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetIndexAlways">
      <summary>
            Expect unlimited set of an Index
            </summary>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetIndexAndThrow(System.Exception)">
      <summary>
            Expect 1 set of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetIndexAndThrow(System.Exception,System.Int32)">
      <summary>
            Expect a number of sets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of sets to expect</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectSetIndexAndAlwaysThrow(System.Exception)">
      <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetIndex(System.Object)">
      <summary>
            Expect 1 get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="value">Mocked Index Value</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetIndex(System.Object,System.Int32)">
      <summary>
            Expect a number of get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="value">Mocked Index Value</param>
      <param name="timesToRun">Number of sets to expect</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetIndexAlways(System.Object)">
      <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
      <param name="value">Mocked Index Value</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetIndexAndThrow(System.Exception)">
      <summary>
            Expect 1 get of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetIndexAndThrow(System.Exception,System.Int32)">
      <summary>
            Expect a number of gets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of expected calls</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectGetIndexAndAlwaysThrow(System.Exception)">
      <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAddEvent(System.String)">
      <summary>
            Expect 1 event listener to be added (event += new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAddEvent(System.String,System.Int32)">
      <summary>
            Expect a number of event listeners to be added (event += new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectAddEventAlways(System.String)">
      <summary>
            Expect unlimited number of event listeners to be added (event += new EventHandler())
            </summary>
      <remarks>
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance" />[index] property
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>
            Since Version 3.7
             </remarks>
      <param name="eventName">Name of Event</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectRemoveEvent(System.String)">
      <summary>
            Expect 1 event listener to be removed (event -= new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.IMockControl.ExpectRemoveEvent(System.String,System.Int32)">
      <summary>
            Expect a number of event listeners to be removed (event -= new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.IMockControl.AnonymousMethodOf(System.String)">
      <summary>
            Use to mock all anonymous methods that are called from within a method
            </summary>
      <param name="calledFromMethod">Method from which the anonymous method is called</param>
      <returns>Anonymous Method Mock Name</returns>
      <example>
            Assuming that we have this code
            <code lang="cs">
            public void DoSomething()
            {
            	button1.Click += delegate
            	 {
            	 	MessageBox.Show("Click!");
            	 };
            } 
            public void FireClick()
            {
            	button1.PerformClick();
            } 
            </code>
            We can Mock the button1.Click Anonymous Method as follows:
            <code lang="cs">
            [Test] 
            public void AnonymousTest()
            {
                 // Mock TestedClass 
                 Mock mock = MockManager.Mock(typeof(TestedClass)); 
                 // set up our expectations for anonymous method called in DoSomething
                 // check that the delegate will be called without displaying the message box 
                 mock.ExpectCall(mock.AnonymousMethod("DoSomething"));
                  
                 // create the instances
                 TestedClass tested = new TestedClass();
                 // Test the code 
                 tested.DoSomething();
                 tested.FireClick();
                 // Verify that all calls were made (This can be done in the [Teardown]) 
                 MockManager.Verify();
            } 
            </code></example>
    </member>
    <member name="M:TypeMock.IMockControl.Clear(System.String)">
      <summary>
            Clear expectation of a method
            </summary>
      <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify" /></remarks>
      <param name="method">Name of method to remove expectations</param>
    </member>
    <member name="M:TypeMock.IMockControl.Clear">
      <summary>
            Clear all expectations 
            </summary>
      <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify" /></remarks>
    </member>
    <member name="M:TypeMock.IMockControl.MockField(System.String)">
      <summary> Create a Mock object and assign it to a given field.</summary>
      <param name="fieldName">The name of the field to be mocked</param>
      <returns>A mock object that is assigned to the field.</returns>
      <example>Show how to mock a call on a public field.
            this works on private members as well
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void MockInstanceField()
            {
                // mock next instance creation of ClassWithField 
                Mock mock = MockManager.Mock(typeof(ClassWithField));
                // mock the "field" field and set the expectation on it
                Mock mockedField = mock.MockField("field");
                mockedField.ExpectAndReturn("ReturnFive", 6);
            
                ClassWithField target = new ClassWithField();
                int actual = target.field.ReturnFive();
                // ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual);
            }
            </code><code lang="vbnet">
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub MockInstanceField()
                ' mock next instance creation of ClassWithField 
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' mock the "field" field and set the expectaion on it
                Dim MockedField As Mock = mock.MockField("field")
                MockedField.ExpectAndReturn("ReturnFive", 6)
                
                Dim target As New ClassWithField
                Dim actual As Integer = target.field.ReturnFive
                ' ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual)
            End Sub
            </code></example>
      <seealso cref="M:TypeMock.IMockControl.AssignField(System.String,System.Object)">AssignField</seealso>
      <exception cref="T:TypeMock.TypeMockException">If constructor is not mocked, field is not
            found or field can't be mocked</exception>
    </member>
    <member name="M:TypeMock.IMockControl.AssignField(System.String,System.Object)">
      <summary>
            Assign a new value to the given field.
            </summary>
      <param name="fieldName">The name of the field to be assigned</param>
      <param name="value">The value to assign.</param>
      <exception cref="T:TypeMock.TypeMockException">If field is not found or is static</exception>
      <seealso cref="M:TypeMock.IMockControl.MockField(System.String)" />
      <example>
            Show how to assign values to private fields.
            this can also be done to private static fields using the 
            AssignStaticField API.
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void AssignField()
            {
                // create the new value we will assign to the field
                FieldClass replacement = new FieldClass();
                // create the mock object
                Mock mock = MockManager.Mock&lt;ClassWithField&gt;();
                // if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateField", replacement);
              
                // verify that the replacement was assigned to the newly crated instance
                ClassWithField target = new ClassWithField();
                int actual = target.GetPrivate().GetHashCode();
                Assert.AreEqual(replacement.GetHashCode(), actual);
            }
            </code><code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub AssignField()
                ' create the new value we will assign to the field
                Dim Replacement As New FieldClass
                'create the mock object
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateField", Replacement)
                
                ' verify that the replacement was assigned to the newly crated instance
                Dim field As New ClassWithField
                Dim hashCode As Integer = field.GetPrivate().GetHashCode()
                Assert.AreEqual(Replacement.GetHashCode, hashCode)
            End Sub
            </code></example>
    </member>
    <member name="M:TypeMock.IMockControl.AlwaysCallOriginal(System.String,System.Type[])">
      <summary>
            Indicate that the behavior of the mocked method will be to call the original method. 
            </summary>
      <param name="method"> The mocked mothod's name.</param>
      <param name="genericTypes"> Parameters that the mockef method receives</param>
    </member>
    <member name="P:TypeMock.IMockControl.CallBase">
      <summary>
            Allow mocking a method in a base class that is hidden by the mocked class 
            </summary>
      <remarks>
            In most cases there is no need to use this method as Typemock Isolator will mock all methods in the hierarcy 
            of the mocked type. CallBase should be used when a method of a base class is overriden in the mocked type,
             and there is a need to mock the base method only. 
            <example><code lang="cs">
            public class BaseClass
            {
                public virtual int SomeMethod()
                {
                    return 1;
                }
            }
            
            public class DerivedClass() : BaseClass
            {
                public override int SomeMethod()
                {
                    return base.SomeMethod() + 1;
                }
            }
            
            [Test]
            public void Test()
            {
                Mock mock = MockManager.Mock(typeof(DerivedClass))
                // mock only BaseClass.SomeMethod when called from a DerivedClass Type.
                mock.CallBase.ExpectAndReturn("SomeMethod", 100);
                DerivedClass d = new DerivedClass();
                Assert.AreEqual(101, d.SomeMethod());
            }
            </code><code lang="vbnet">
            Public Class BaseClass
              Public Overridable Function SomeMethod() As Integer
                Return 1
              End Function
            End Class
            
            Public Class DerivedClass
              Inherits BaseClass
              Public Overrides Function SomeMethod() As Integer
                Return 1
              End Function
             End Class
            
            &lt;Test()&gt; _
            Public Sub Test()
              Dim mock As Mock = MockManager.Mock(GetType(DerivedClass))
              ' mock only BaseClass.SomeMethod when called from a DerivedClass Type.
              mock.CallBase.ExpectAndReturn("SomeMethod", 100)
              Dim d As DerivedClass = New DerivedClass
              Assert.AreEqual(101, d.SomeMethod())      
            End Sub
            </code></example></remarks>
      <exception cref="T:TypeMock.TypeMockException">If a static method is mocked</exception>
    </member>
    <member name="P:TypeMock.IMockControl.ValidateArgsOnVerify">
      <summary>
            Obsolete. Argument validation is done both on calling the method and during Verify.
            Postpone throwing validation errors till <see cref="M:TypeMock.MockManager.Verify" /> is called
            </summary>
      <remarks>
            Using ValidateArgsOnVerify, validation errors are thrown after Verify is called.
            This is useful if the validation is done in another thread and you want the thread to continue.
            When Verify is called all argument validations are shown too.
            </remarks>
    </member>
    <member name="T:TypeMock.IMockedEvent">
      <summary>
            IMockedEvent is the Typemock Isolator Event Mocking mechanism, used to fire events to test Event driven applications.
            </summary>
      <remarks>
        <para>
            When one instance of the event publisher is mocked, use MockedEvent.<see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> 
            to fire the event.
            <code lang="cs">
            [Test]
            public void SimulateFiringClick()
            {
              // Mock the Click Event of the next Button
              Mock mockButton = MockManager.Mock(typeof(Button));
              MockedEvent handler = mockButton.ExpectAddEvent("Click");
            
              // Create the button and register to the Event
              Button button = new(Button);
              button.Click += new EventHandler(button_Click);
            
              // Simulate firing the event
              handler.Fire(this, EventArgs.Empty);
              // Check that system works...
            
              MockManager.Verify()
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClick()
              'Mock all Click Events of the next Button
              Dim buttonMock As Mock = MockManager.Mock(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEvent("Click")
            
              ' Create the button and register to the Event
              Dim button As Button = New Button
              AddHandler button.Click, AddressOf button_Click
            
              ' Simulate firing the event
              handle.Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>  /// 
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance" />[index] property
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code></para>
            Since Version 3.7
            </remarks>
    </member>
    <member name="M:TypeMock.IMockedEvent.Fire(System.Object[])">
      <summary>
            Fire a mocked event. See <see cref="T:TypeMock.IMockedEvent" /></summary>
      <param name="args">Arguments to pass to the mocked event</param>
      <returns>The return value of the event</returns>
    </member>
    <member name="M:TypeMock.IMockedEvent.GetEventHandle">
      <summary>
            Retrieve the EventHandle
            </summary>
      <remarks>
            Using GetEventHandle can help write type-safe tests by casting the EventHandle to the correct Event Type
            Example
            <code lang="cs">
            EventHandler fire = handle.GetEventHandle() as EventHandler;
            fire(this, EventArgs.Empty);
            </code><code lanf="vbnet">
            Dim fire As EventHandler = handle.GetEventHandle()
            fire(Me, EventArgs.Empty)
            </code></remarks>
      <returns>The Event</returns>
    </member>
    <member name="T:TypeMock.AboutMessage">
      <summary>
            Summary description for AboutMessage.
            </summary>
    </member>
    <member name="T:TypeMock.MethodCallCounter">
      <summary>
            CallCounter counts the calls to all registered methods 
            <see cref="P:TypeMock.MockManager.CollectAllCalls" /></summary>
    </member>
    <member name="T:TypeMock.CallExpectation">
      <summary>
            Hold the Return value for mocked methods
            </summary>
    </member>
    <member name="M:TypeMock.CallExpectation.Repeat(System.Int32)">
      <summary>
            set the number of times that the expectation should be repeated
            </summary>
      <param name="value">times to repeat</param>
    </member>
    <member name="M:TypeMock.CallExpectation.CheckAndAssign(System.Object[],System.Type)">
      <summary>
            Checks whether the actual arguments passed to the call match the expected, and assign new values 
            if needed. method will throw a <see cref="T:TypeMock.VerifyException" /> if arguments do not match.
            </summary>
      <param name="actualParams">the real parameters passed to the call</param>
      <param name="type">the mocked type (needed for error messages)</param>
    </member>
    <member name="M:TypeMock.CallExpectation.ConditionSatisfied(System.Object[],System.Type)">
      <summary>
            Checks whether actual parameters passed to the method match the expected ones 
            (needed to decide if the method should be mocked or not)
            </summary>
      <param name="actualArgs">actual parameters passed to the call</param>
      <param name="type">the mocked type (needed for error messages)</param>
      <returns>
        <c>true</c> if condition is satisfied, otherwise <c>false</c></returns>
    </member>
    <member name="T:TypeMock.InstanceKey">
      <summary>
            This is to wrap all classes and use our own Hash code.
            Or else it might lead to stack overflow
            </summary>
    </member>
    <member name="P:TypeMock.InstanceKey.InstanceObject">
      <summary>
            returns the mocked object instance
            </summary>
    </member>
    <member name="T:TypeMock.NullableInstanceKey">
      <summary>
            This is to wrap all classes and use our own Hash code.
            Or else it might lead to stack overflow
            </summary>
    </member>
    <member name="P:TypeMock.NullableInstanceKey.InstanceObject">
      <summary>
            returns the mocked object instance
            </summary>
    </member>
    <member name="M:TypeMock.TypeExpectations.Verify">
      <summary>
            Verify mocked type 
            </summary>
    </member>
    <member name="M:TypeMock.TypeExpectations.FindRecorderMock(TypeMock.Mock)">
      <summary>
            Find the mock object that was created during the recording of the given mock object
            </summary>
      <param name="createdMock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:TypeMock.TypeExpectations.IsMockAllBehaviorAlreadySet">
      <summary>
            should be true only if MockAll behavior has been set for a struct through AAA
            </summary>
    </member>
    <member name="T:TypeMock.GlobalFunctions">
      <summary>
            Use this type when mocking global functions
            </summary>
      <remarks>
            This is an example of how to mock global functions in C++
            <example><code>
            namespace TestWithCpp
            {
            	int globalFunction(int a) {return a;}
            }
            </code>
            And the test
            <code>
            [Test]
            void Global() {
            	Mock* mock = MockManager::Mock(__typeof(GlobalType));
            	mock-&gt;ExpectAndReturn("TestWithCpp.globalFunction",__box(5));
            	Assert::AreEqual(__box(5), __box(globalFunction(4)));
            }	
            </code></example></remarks>
    </member>
    <member name="M:TypeMock.MethodBehaviorRepository.Clear(TypeMock.Mock)">
      <summary>
            Clear all expectations of a mock (clears static members made by an instance mock)
            </summary>
      <returns>if no expectations are left</returns>
    </member>
    <member name="P:TypeMock.MethodBehaviorRepository.HasConditionalExpectationsLeft">
      <summary>
            this return true if we have unfulfiled conditional returns
            </summary>
    </member>
    <member name="T:TypeMock.MethodExpectation">
      <summary>
            Manage all expectations set on a specific method 
            </summary>
      <remarks>
            There are two kinds of call expectations values - Default and sequenced.
            The Default is used to Always return the same value, and the sequence
            return according to call sequence, there are also two corresponding types for conditional
            and default conditional</remarks>
    </member>
    <member name="M:TypeMock.MethodExpectation.CreateDefault(System.Object,System.Boolean,TypeMock.Mock,TypeMock.ExpectationBlock)">
            Create a new default call expectation.
            Note - this will replace the previous default
        </member>
    <member name="M:TypeMock.MethodExpectation.AddNewCallExpectation(System.Object,System.Boolean,TypeMock.Mock)">
            Add a new regular call expectation
        </member>
    <member name="M:TypeMock.MethodExpectation.CountExpectedCallsLeft">
      <summary>
            this will count the number of calls which were not made.
            (only calls with normal verification mode are counted)
            </summary>
    </member>
    <member name="M:TypeMock.MethodExpectation.GetReturn(System.Object,System.Object[],System.Type,TypeMock.Scope,System.Int32,System.Object,System.Type,System.Reflection.MethodBase)">
      <summary>
            this is the main api used during the test execution, when a method is mocked we will call this
            to "activate" the behavior which was dictated during the expectation setup phase.
            </summary>
      <returns>the value to return to the user</returns>
    </member>
    <member name="M:TypeMock.MethodExpectation.GetReturn(System.Object,System.Object[],System.Type,TypeMock.Scope,System.Int32,System.Object,System.Type,System.Reflection.MethodBase,TypeMock.Mock)">
      <summary>
            this is the main api used during the test execution, when a method is mocked we will call this
            to "activate" the behavior which was dictated during the expectation setup phase.
            </summary>
      <returns>the value to return to the user</returns>
    </member>
    <member name="M:TypeMock.MethodExpectation.Verify">
      <summary>
            Count the number of unfulfilled expectations.
            </summary>
      <returns>number of calls left (Negative can happen with default returns)</returns>
    </member>
    <member name="M:TypeMock.MethodExpectation.MoveToProperDefault(TypeMock.CallExpectation)">
      <summary>
            this takes a regular/conditional expectation and turn it into a default regular/conditional
            (repeated always) expectation.
            </summary>
    </member>
    <member name="F:TypeMock.RecordedMocksContainer.m_RecordedMocks">
      <summary>
            Holds all the created mocks
            </summary>
    </member>
    <member name="T:TypeMock.MethodCallContext">
      <summary>
            Class that contains information about the called instance 
            </summary>
    </member>
    <member name="M:TypeMock.MethodCallContext.WillCallOriginal">
      <summary>
            Use this to call the original method after exiting DoInstead.
            </summary>
      <example>
        <code>
            public int Foo()
            {
                return 1;
            }
            
            [Isolated,TestMethod]
            public void Test()
            {
                Isolate.WhenCalled(() =&gt; Foo()).DoInstead(context=&gt; { 
                                                                     context.WillCallOriginal(); 
                                                                     return 0; // this return value is ignored
                                                                     });
                Assert.AreEqual(Foo(), 1);
            }
            </code>
      </example>
    </member>
    <member name="P:TypeMock.MethodCallContext.Instance">
      <summary>
            Reference to the mocked object instance, or null if the method is static
            </summary>
      <value>The instance.</value>
    </member>
    <member name="P:TypeMock.MethodCallContext.Parameters">
      <summary>
            Array of parameters passed to mocked method
            </summary>
      <value>The parameters.</value>
    </member>
    <member name="P:TypeMock.MethodCallContext.Method">
      <summary>
            The method being faked
            </summary>
      <value>The method.</value>
    </member>
    <member name="P:TypeMock.MethodCallContext.ContinueFakingThisMethodRecursively">
      <summary>
            Allow recursive calls to this faked method to be faked and reenter DoInstead lambda
            </summary>
      <remarks>
            The default is to call the original implementation to the faked method so that 
            it is easy to use context.<see cref="P:TypeMock.MethodCallContext.Method" /> to invoke the original method, without creating a recursive endless loop
            </remarks>
      <example>
        <code>
            public int Foo(int i)
            {
                if (i==0) return 1;
                return Foo(i)+1;
            }
            
            [Isolated,TestMethod]
            public void Test()
            {
                bool called=false;
                Isolate.WhenCalled(() =&gt; Foo(0)).DoInstead(context=&gt; 
                { 
                     // allow calls down the stack to be faked
                     context.ContinueFakingThisMethodRecursively = true;
                     
                     // call original code with different arg
                     int passedVal = (int)context.Parameters[0];
                     return context.Method.Invoke(context.Instance, new object[] { passedVal + 1});
                });
                Assert.AreEqual(foo(), 1);
            }
            </code>
      </example>
    </member>
    <member name="T:TypeMock.MethodDecorator">
      <summary>
            Implement the logic which activate the decorating attributes.
            </summary>
    </member>
    <member name="F:TypeMock.MethodDecorator.m_OriginalMethod">
      <summary>
            holds the Decorated method (i.e. method which is tagged by the custom attribute)
            </summary>
    </member>
    <member name="F:TypeMock.MethodDecorator.m_OriginalContext">
      <summary>
            stores the instance that the decorated method was called with
            </summary>
    </member>
    <member name="F:TypeMock.MethodDecorator.m_OriginalParams">
      <summary>
            stores the original parameters to pass to the decorated method
            </summary>
    </member>
    <member name="F:TypeMock.MethodDecorator.m_DecoratingAttributes">
      <summary>
            holds all the attributes decorating the method
            </summary>
    </member>
    <member name="F:TypeMock.MethodDecorator.OriginalWasCalled">
      <summary>
            specify if the original method was called or not during the execution flow
            </summary>
    </member>
    <member name="F:TypeMock.MethodDecorator.IgnoreOriginalCalled">
      <summary>
            specify if the original method can be ignored
            </summary>
    </member>
    <member name="M:TypeMock.MethodDecorator.#ctor(System.Reflection.MethodBase,System.Object,System.Object[])">
      <summary>
            default ctor. initialize the context,method,attributes,par
            </summary>
      <param name="method">The method to decorate(i.e. the method which is tagged by the attribute)</param>
      <param name="context">The instance that the decorated method was called through</param>
      <param name="par">the parameters to pass to the decorated method</param>
    </member>
    <member name="M:TypeMock.MethodDecorator.GetDecoratingAttributes(System.Reflection.MethodBase)">
      <summary>
            Returns all the custom attributes (i.e. sub classes of DecoratorAttribute) that surrounds the method
            </summary>
      <param name="method">The method </param>
      <returns>array of the decorating attributes</returns>
    </member>
    <member name="M:TypeMock.MethodDecorator.Run">
      <summary>
            Activate the execution flow of the decorating attributes
            </summary>
      <returns>The results from activating the original invoker on the test (unless overridden)</returns>
    </member>
    <member name="M:TypeMock.MethodDecorator.DontCallDecoratedMethod">
      <summary>
            Tell the decorator not to check if the decorated method was called from the 
            attributes. this means that if the attribute didnt call the decorated method 
            it wont be executed at all.
            </summary>
    </member>
    <member name="P:TypeMock.MethodDecorator.OriginalMethod">
      <summary>
            Retrieves the Original method info (the method which is tagged by the attribute)
            </summary>
    </member>
    <member name="P:TypeMock.MethodDecorator.OriginalContext">
      <summary>
            Retrieves the instance that the original method was called with.
            </summary>
    </member>
    <member name="P:TypeMock.MethodDecorator.OriginalParams">
      <summary>
            Retrieves the original parameters that were passed to the original method
            </summary>
    </member>
    <member name="T:TypeMock.DynamicReturnValue">
      <summary>
            Delegate to implement a custom return value
            </summary>
      <remarks>
            Typemock Isolator allows you to specify mocked return values for mocked methods.
            These values are normally hard coded, but
            there are some cases where this is not enough and a custom return value is needed,
            to do so create a delegation method and pass it as the return value to 
            one of the <see cref="T:TypeMock.Mock" /> setup methods 
            <para><example>
            For example, if we need to return the first <c>int</c> parameter of a mocked method, but throw an exception
            if the value is 0, we can write the following code 
            <code lang="cs">
            public static object MyReturnValue(object[] parameters, object context) 
            {
            	if ((int)parameters[0]==0) 
            	{
            		throw new Exception();
            	}
            	return parameters[0];
            }
            </code><code lang="vbnet">
            Public Shared Function MyReturnValue(ByVal parameters() As Object, ByVal that As Object) As Object
            	If parameters(0)=0 Then
                   Throw New Exception
            	End If
            	MyReturnValue = parameters(0)
            End Function
            </code>
            We can then use it in our test
            <code lang="cs">
            [Test]
            public void Test() 
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	// getInt will be called, it will return our dynamic values
            	mock.AlwaysReturn("getInt",new DynamicReturnValue(MyReturnValue));
            	TestedClass t = new TestedClass();
            	// This will pass
            	Assert.AreEqual(10,t.getVar(10));
            	// so will this
            	Assert.AreEqual(1,t.getVar(1));
            	// this will throw an exception
            	t.getVar(0);
            	MockManager.Verify();
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test() 
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	' getInt will be called, it will return our dynamic values
            	mock.AlwaysReturn("getInt",New DynamicReturnValue(AddressOf MyReturnValue))
            	Dim t As TestedClass = New TestedClass()
            	' This will pass
            	Assert.AreEqual(10,t.getVar(10))
            	' so will this
            	Assert.AreEqual(1,t.getVar(1))
            	' this will throw an exception
            	t.getVar(0)
            	MockManager.Verify()
            End Sub
            </code></example></para><note>
            BEWARE, Typemock Isolator does not check the legitimacy of the returned value, if you 
            return a value with the wrong type a <c>System.InvalidCastException</c> will be 
            thrown
            </note><note>
            BEWARE, All code that is run inside the delegate is NOT mocked. 
            thrown
            </note><note>
            To continue with the original method without mocking, return <see cref="P:TypeMock.MockManager.CONTINUE_WITH_METHOD" /></note><note>
            You can use <c>DynamicReturnValue</c> to change <c>ref</c> and <c>out</c> parameters
            Just change the values of the parameters array and if the parameter is referenced it will change its
            value. Again Typemock Isolator does not check the legitimacy of the value.
            </note></remarks>
      <param name="parameters">array of parameters passed to mocked method</param>
      <param name="context">a reference to the mocked object instance, or null if the method is static</param>
      <returns>custom return value</returns>
      <exception cref="T:System.InvalidCastException">If return a value of the wrong type</exception>
    </member>
    <member name="F:TypeMock.Mock.allExpectedCallsDoneEvent">
      <exclude />
      <summary>
            Event that is set when all expectations have been made, used for verify with timeout
            </summary>
    </member>
    <member name="F:TypeMock.Mock.m_MockedFields">
      <summary>used to store mocked fields objects which will be assigned upon object creation</summary>
    </member>
    <member name="F:TypeMock.Mock.m_AssignedFieldValues">
      <summary>Used to store fields which will be assigned to the field of the next object</summary>
    </member>
    <member name="F:TypeMock.Mock.m_IsFieldMock">
      <summary>Marks the mock as one sitting on a field (needed for license verification)</summary>
    </member>
    <member name="F:TypeMock.Mock._recorder">
      <summary>
            This mock is filled when a recorder is recording on this instance 
            but it has to register on the recorder mock future instance
            </summary>
    </member>
    <member name="M:TypeMock.Mock.#ctor(TypeMock.Mock,System.Type,TypeMock.Constructor)">
      <summary>
            Constructer, keep internal
            </summary>
      <param name="staticMock">Link to mock for static methods</param>
      <param name="type">Type to be mocked</param>
      <param name="mockConstructors">flag to mock constructors</param>
    </member>
    <member name="M:TypeMock.Mock.ChangeConstructor(TypeMock.Constructor)">
      <summary>
            Constructer swaping with the mocked one, keep internal
            </summary>
      <param name="mockConstructors">flag to mock constructors</param>
    </member>
    <member name="M:TypeMock.Mock.RemoveStaticCtor">
      <summary>
            Remobing static constructer, keep internal
            </summary>
    </member>
    <member name="M:TypeMock.Mock.MethodSettings(System.String)">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler. Properties and 
            indexes can be tweaked using <see cref="M:TypeMock.Mock.MethodSettingsGetProperty(System.String)" />,
            <see cref="M:TypeMock.Mock.MethodSettingsSetProperty(System.String)" />, <see cref="M:TypeMock.Mock.MethodSettingsGetIndex" /> 
            and <see cref="M:TypeMock.Mock.MethodSettingsSetIndex" /><seealso cref="M:TypeMock.Mock.MethodSettingsGetProperty(System.String)" /><seealso cref="M:TypeMock.Mock.MethodSettingsSetProperty(System.String)" /><seealso cref="M:TypeMock.Mock.MethodSettingsGetIndex" /><seealso cref="M:TypeMock.Mock.MethodSettingsSetIndex" /></remarks>
      <param name="methodName">Name of method</param>
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.Mock.MethodSettingsGetProperty(System.String)">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <param name="propertyName">Name of Property</param>
      <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.Mock.MethodSettingsSetProperty(System.String)">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <param name="propertyName">Name of Property</param>
      <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.Mock.MethodSettingsGetIndex">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.Mock.MethodSettingsSetIndex">
      <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
      <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
      <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)" />
      <returns>Interface to change method Behavior</returns>
    </member>
    <member name="M:TypeMock.Mock.IsMethodMocked(System.String,System.Object,System.Int32,System.String)">
      <summary>
            Check if method is in the expectation table
            </summary>
      <param name="methodName">
      </param>
      <param name="methodParameters">
      </param>
      <param name="inInstanceNumber">
      </param>
      <param name="typeName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:TypeMock.Mock.AddInstance">
      <summary>
            Used by StaticMock to count references of Mocks so that the last
            verify will verify the static too.
            </summary>
    </member>
    <member name="M:TypeMock.Mock.MockConstructor">
      <summary>
            Mock Constructor 
            </summary>
      <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectConstructor">
      <summary>
            Mock Constructor 
            </summary>
      <remarks>
            Using <c>ExpectConstructor </c> will verify that a constructor has been called and can be used to validate the arguments passed
            to the constructor
            </remarks>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectConstructor(System.Int32)">
      <summary>
            Mock Constructor
            </summary>
      <remarks>
            Using <c>ExpectConstructor </c> will verify that a constructor has been called and can be used to validate the arguments passed
            to the constructor
            </remarks>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectConstructorAlways">
      <summary>
            Mock unlimited calls from Constructor
            </summary>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectConstructorAndThrow(System.Exception)">
      <summary>
            Mock Constructor and throw exception when constructor is called
            </summary>
      <remarks>
            Using <c>ExpectConstructorAndThrow </c> will throw an exception when the constructor
            is called
            </remarks>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedConstructor">
      <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
      <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedConstructor(System.Int32)">
      <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
      <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectCallAndVerify(System.String)">
      <summary>
            Verify 1 call from method , continue with method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedCall(System.String,System.Type[])">
      <summary>
            Verify 1 call from method , continue with method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedCall(System.String,System.Int32,System.Type[])">
      <summary>
            Verify a number of calls from method , continue with method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="timesToRun">Number of times to expect</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.AlwaysCallOriginal(System.String,System.Type[])">
      <summary>
            Sets the expectaion of this method to always call the original method.
            </summary>
      <param name="method">The method name</param>
      <param name="genericTypes">Parameters which the method recives</param>
      <returns>
      </returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectCall(System.String,System.Type[])">
      <summary>
            Expect 1 call from method
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectCall(System.String,System.Int32,System.Type[])">
      <summary>
            Expect a number of calls from method
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="method">Method Name</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])">
      <summary>
            Expect 1 call from method, and mock return value
            </summary>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
      <seealso cref="T:TypeMock.Check" />
      <seealso cref="T:TypeMock.IParameters" />
      <seealso cref="T:TypeMock.ParameterChecker" />
      <seealso cref="T:TypeMock.DynamicReturnValue" />
    </member>
    <member name="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Int32,System.Type[])">
      <summary>
            Expect a number of calls from method, and mock return value
            </summary>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
      <seealso cref="T:TypeMock.Check" />
      <seealso cref="T:TypeMock.IParameters" />
      <seealso cref="T:TypeMock.ParameterChecker" />
      <seealso cref="T:TypeMock.DynamicReturnValue" />
    </member>
    <member name="M:TypeMock.Mock.ExpectAndThrow(System.String,System.Exception,System.Type[])">
      <summary>
            Expect 1 call from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="method">Method Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectAndThrow(System.String,System.Exception,System.Int32,System.Type[])">
      <summary>
            Expect a number of calls from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="method">Method Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectAlways(System.String,System.Type[])">
      <summary>
            Expect unlimited calls from method
            </summary>
      <param name="method">Method Name</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.Mock.InternalAlwaysReturn(System.String,System.Object,System.Int32,System.Type[])">
      <summary>
            Expect unlimited calls from method, and always returns mock value
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])" /> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])" /> value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></remarks>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="inInstanceNumber">Number of instances</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
    </member>
    <member name="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])">
      <summary>
            Expect unlimited calls from method, and always returns mock value
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])" /> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])" /> value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></remarks>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
    </member>
    <member name="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[],System.Type[])">
      <summary>
            Expect unlimited calls from method, and always returns mock value
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[],System.Type[])" /> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[],System.Type[])" /> value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></remarks>
      <param name="method">Method Name</param>
      <param name="ret">Mocked return value</param>
      <param name="argumentTypes">List of arguments types</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
    </member>
    <member name="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[])">
      <summary>
            Expect unlimited calls from method, and always throws exception
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[])" /> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the method will throw the <see cref="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[])" /> value
            </remarks>
      <param name="method">Method Name</param>
      <param name="ex">Mocked exception</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[],System.Type[])">
      <summary>
            Expect unlimited calls from method, and always throws exception
            </summary>
      <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[],System.Type[])" /> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])" /> values then the method will throw the <see cref="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[],System.Type[])" /> value
            </remarks>
      <param name="method">Method Name</param>
      <param name="ex">Mocked exception</param>
      <param name="argumentTypes">List of arguments types</param>
      <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSet(System.String)">
      <summary>
            Expect 1 set of a Property
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSet(System.String,System.Int32)">
      <summary>
            Expect a number of sets of a Property
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="timesToRun">Number of times to expect the set</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetAlways(System.String)">
      <summary>
            Expect unlimited set of a Property
            </summary>
      <param name="property">Property Name</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetAndThrow(System.String,System.Exception)">
      <summary>
            Expect 1 set of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetAndThrow(System.String,System.Exception,System.Int32)">
      <summary>
            Expect  a number of sets of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of times to expect the call</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetAndAlwaysThrow(System.String,System.Exception)">
      <summary>
            Expect unlimited set of a Property and always mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedSet(System.String)">
      <summary>
            Verify 1 set of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedSet(System.String,System.Int32)">
      <summary>
            Verify a number of sets of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGet(System.String,System.Object)">
      <summary>
            Expect 1 get of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="property">Property Name</param>
      <param name="value">Mocked value</param>
      <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGet(System.String,System.Object,System.Int32)">
      <summary>
            Expect a number of gets of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="property">Property Name</param>
      <param name="value">Mocked value</param>
      <param name="timesToRun">Number of times to expect the gets</param>
      <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetAlways(System.String,System.Object)">
      <summary>
            Expect unlimited get of a Property and always mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="property">Property Name</param>
      <param name="value">Mocked value</param>
      <exception cref="T:TypeMock.TypeMockException">If property is not found or is not correct value type</exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetAndThrow(System.String,System.Exception)">
      <summary>
            Expect 1 get of a Property and mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetAndThrow(System.String,System.Exception,System.Int32)">
      <summary>
            Expect a number of gets of a Property and mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of calls to expect</param>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetAndAlwaysThrow(System.String,System.Exception)">
      <summary>
            Expect unlimited get of a Property and always mock throwing an exception
            </summary>
      <param name="property">Property Name</param>
      <param name="ex">Mocked Exception</param>
      <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedGet(System.String)">
      <summary>
            Verify 1 get of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectUnmockedGet(System.String,System.Int32)">
      <summary>
            Verify a number of gets of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="property">Property Name</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetIndex">
      <summary>
            Expect 1 set of an Index
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetIndex(System.Int32)">
      <summary>
            Expect a number of sets of an Index
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="timesToRun">Number of sets to expect</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetIndexAlways">
      <summary>
            Expect unlimited set of an Index
            </summary>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetIndexAndThrow(System.Exception)">
      <summary>
            Expect 1 set of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetIndexAndThrow(System.Exception,System.Int32)">
      <summary>
            Expect a number of sets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of sets to expect</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectSetIndexAndAlwaysThrow(System.Exception)">
      <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetIndex(System.Object)">
      <summary>
            Expect 1 get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="value">Mocked Index Value</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetIndex(System.Object,System.Int32)">
      <summary>
            Expect a number of get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /><seealso cref="T:TypeMock.DynamicReturnValue" /></summary>
      <param name="value">Mocked Index Value</param>
      <param name="timesToRun">Number of sets to expect</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetIndexAlways(System.Object)">
      <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
      <param name="value">Mocked Index Value</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetIndexAndThrow(System.Exception)">
      <summary>
            Expect 1 get of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetIndexAndThrow(System.Exception,System.Int32)">
      <summary>
            Expect a number of gets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check" /><seealso cref="T:TypeMock.IParameters" /><seealso cref="T:TypeMock.ParameterChecker" /></summary>
      <param name="ex">Mocked Exception</param>
      <param name="timesToRun">Number of expected calls</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.ExpectGetIndexAndAlwaysThrow(System.Exception)">
      <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
      <param name="ex">Mocked Exception</param>
      <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters" /></returns>
      <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
    </member>
    <member name="M:TypeMock.Mock.MockField(System.String)">
      <summary> Create a Mock object and assign it to a given field.</summary>
      <param name="fieldName">The name of the field to be mocked</param>
      <returns>A mock object that is assigned to the field.</returns>
      <example>Show how to mock a call on a public field.
            this works on private members as well
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void MockInstanceField()
            {
                // mock next instance creation of ClassWithField 
                Mock mock = MockManager.Mock(typeof(ClassWithField));
                // mock the "member" field and set the expectation on it
                Mock mockedField = mock.MockField("member");
                mockedField.ExpectAndReturn("ReturnFive", 6);
            
                ClassWithField target = new ClassWithField();
                int actual = target.member.ReturnFive();
                // ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual);
            }
            </code><code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub MockInstanceField()
                ' mock next instance creation of ClassWithField 
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' mock the "member" field and set the expectaion on it
                Dim MockedField As Mock = mock.MockField("member")
                MockedField.ExpectAndReturn("ReturnFive", 6)
                
                Dim target As New ClassWithField
                Dim actual As Integer = target.member.ReturnFive
                ' ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual)
            End Sub
            </code></example>
      <seealso cref="M:TypeMock.Mock.AssignField(System.String,System.Object)">AssignField</seealso>
      <exception cref="T:TypeMock.TypeMockException">If constructor is not mocked, field is not
            found or field can't be mocked</exception>
    </member>
    <member name="M:TypeMock.Mock.AssignField(System.String,System.Object)">
      <summary>
            Assign a new value to the given field.
            </summary>
      <param name="fieldName">The name of the field to be assigned</param>
      <param name="value">The value to assign.</param>
      <exception cref="T:TypeMock.TypeMockException">If field is not found or is static, or if the class's constructor is not mocked</exception>
      <seealso cref="M:TypeMock.Mock.MockField(System.String)" />
      <example>
            Show how to assign values to private fields.
            this can also be done to private static fields using the 
            AssignStaticField API.
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void AssignField()
            {
                // create the new value we will assign to the field
                FieldClass replacement = new FieldClass();
                // create the mock object
                Mock mock = MockManager.Mock&lt;ClassWithField&gt;();
                // if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateMember", replacement);
              
                // verify that the replacement was assigned to the newly crated instance
                ClassWithField target = new ClassWithField();
                int actual = target.GetPrivate().GetHashCode();
                Assert.AreEqual(replacement.GetHashCode(), actual);
            }
            </code><code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub AssignField()
                ' create the new value we will assign to the field
                Dim Replacement As New FieldClass
                'create the mock object
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateMember", Replacement)
                
                ' verify that the replacement was assigned to the newly crated instance
                Dim field As New ClassWithField
                Dim hashCode As Integer = field.GetPrivate().GetHashCode()
                Assert.AreEqual(Replacement.GetHashCode, hashCode)
            End Sub
            </code></example>
    </member>
    <member name="M:TypeMock.Mock.MockAllFields">
      <summary>
            Create a mock object on all the fields (which are classes)
            done by default in natural mocks, when encountering a ctor recording
            </summary>
    </member>
    <member name="M:TypeMock.Mock.MockAllStaticFields(System.Boolean)">
      <summary>
            Create a mock object on all static fields of the class
            done by default in natural mocks when encountering a cctor recording
            </summary>
    </member>
    <member name="M:TypeMock.Mock.AssignValuesToFields(System.Object)">
      <summary>
            gop over mocked field list and atatch the mocks to the created object
            and then go over user assigned values and assign them to the fields
            this is called when creating the real object
            </summary>
      <param name="context">the real object being created</param>
    </member>
    <member name="M:TypeMock.Mock.ExpectAddEventAlways(System.String)">
      <summary>
            Expect unlimited number of event listeners to be added (event += new EventHandler())
            </summary>
      <remarks>
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance" />[index] property
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>
            Since Version 3.7
             </remarks>
      <param name="eventName">Name of Event</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectAddEvent(System.String)">
      <summary>
            Expect 1 event listener to be added (event += new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectAddEvent(System.String,System.Int32)">
      <summary>
            Expect a number of event listeners to be added (event += new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectRemoveEvent(System.String)">
      <summary>
            Expect 1 event listener to be removed (event -= new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.Mock.ExpectRemoveEvent(System.String,System.Int32)">
      <summary>
            Expect a number of event listeners to be removed (event -= new EventHandler())
            </summary>
      <param name="eventName">Name of Event</param>
      <param name="timesToRun">Number of times to expect</param>
      <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])" /> the Event</returns>
    </member>
    <member name="M:TypeMock.Mock.AnonymousMethodOf(System.String)">
      <summary>
            Use to mock all anonymous methods that are called from within a method
            </summary>
      <param name="calledFromMethod">Method from which the anonymous method is called</param>
      <returns>Anonymous Method Mock Name</returns>
      <example>
            Assuming that we have this code
            <code lang="cs">
            public void DoSomething()
            {
            	button1.Click += delegate
            	 {
            	 	MessageBox.Show("Click!");
            	 };
            } 
            public void FireClick()
            {
            	button1.PerformClick();
            } 
            </code>
            We can Mock the button1.Click Anonymous Method as follows:
            <code lang="cs">
            [Test] 
            public void AnonymousTest()
            {
                 // Mock TestedClass 
                 Mock mock = MockManager.Mock(typeof(TestedClass)); 
                 // set up our expectations for anonymous method called in DoSomething
                 // check that the delegate will be called without displaying the message box 
                 mock.ExpectCall(mock.AnonymousMethod("DoSomething"));
                  
                 // create the instances
                 TestedClass tested = new TestedClass();
                 // Test the code 
                 tested.DoSomething();
                 tested.FireClick();
                 // Verify that all calls were made (This can be done in the [Teardown]) 
                 MockManager.Verify();
            } 
            </code></example>
    </member>
    <member name="M:TypeMock.Mock.Verify">
      <summary>
            Verify mocked type 
            </summary>
      <remarks>
            Part of Test Driven Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. This should always be the final part of the test
            If some methods that we expected to be called where not called this will fail the test.
            
            This is automatically called when using <c>MockManager.Verify()</c> see <see cref="M:TypeMock.MockManager.Verify" /><example>
            For an example see <see cref="P:TypeMock.Mock.Strict" /></example><note>
            Using <see cref="P:TypeMock.Mock.Strict" /> we can also define, that calls to methods that where
            not expected, will fail the test too.
            </note></remarks>
    </member>
    <member name="M:TypeMock.Mock.VerifyWithTimeout">
      <summary>
            Wait with timeout (5 seconds) for all expected methods to be called
            </summary>
      <remarks>
            VerifyWithTimeout will wait for all expectations to be called. If the Timeout is triggered
            the test will fail. 
            Part of Test Driver Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. There are cases when mocks are called in a-synchronic
            code or are encapsulated in a try catch block and errors are not thrown to testing method.
            In these cases using VerifyWithTimeout will enable us to validate our code and return as soon as
            the expected methods are called without needing to add Pause statements
            
            This is automatically called when using <c>MockManager.VerifyWithTimeout()</c> see <see cref="M:TypeMock.MockManager.VerifyWithTimeout" /><example><code lang="cs">
            [Test]
            public void TestCallsInOtherThread ()
            {
            	// Let mock the product -  it will not mock constructors;
            	Mock productMock = MockManager.Mock(typeof(Product),Constructor.NotMocked);
            	// CalculatePrice will return 10 - expect 10 as argument
            	productMock.ExpectAndReturn("CalculatePrice",10F).Args(10);
            	// our method will be called in a new thread
            	Thread theThread = new Thread(new ThreadStart(RunWithWait));
            	theThread.Start();
            	// If we use Verify we dont know when the thread will actually be called
            	// Here we WAIT for the mocked methods to be called, or the timeout.
            	// Default timeout is 5000 milliseconds
            	productMock.VerifyWithTimeout();		
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestCallsInOtherThread()
               ' Let mock the product - this will mock the next invocation of Product,
               ' it will mock constructors too so our price will be 0
               Dim productMock As Mock = MockManager.Mock(GetType(Product), Constructor.NotMocked)
               ' CalculatePrice will return 10 - expect 10 as argument
               productMock.ExpectAndReturn("CalculatePrice", 10.0F).Args(10)
               ' our method will be called in a new thread
               Dim theThread As Thread = New Thread(AddressOf RunWithWait)
               theThread.Start()
               ' If we use Verify we dont know when the thread will actually be called
               ' Here we WAIT for the mocked methods to be called, or the timeout.
               ' Default timeout is 5000 milliseconds
               productMock.VerifyWithTimeout()
            End Sub
            </code></example></remarks>
    </member>
    <member name="M:TypeMock.Mock.VerifyWithTimeout(System.Int32)">
      <summary>
            Wait with timeout (im milliseconds) for all expected methods to be called
            </summary>
      <remarks>
            VerifyWithTimeout will wait for all expectations to be called. If the Timeout is triggered
            the test will fail. 
            Part of Test Driver Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. There are cases when mocks are called in a-synchronic
            code or are encapsulated in a try catch block and errors are not thrown to testing method.
            In these cases using VerifyWithTimeout will enable us to validate our code and return as soon as
            the expected methods are called without needing to add Pause statements
            
            This is automatically called when using <c>MockManager.VerifyWithTimeout()</c> see <see cref="M:TypeMock.MockManager.VerifyWithTimeout" /><example><code lang="cs">
            [Test]
            public void TestCallsInOtherThread ()
            {
            	// Let mock the product -  it will not mock constructors;
            	Mock productMock = MockManager.Mock(typeof(Product),Constructor.NotMocked);
            	// CalculatePrice will return 10 - expect 10 as argument
            	productMock.ExpectAndReturn("CalculatePrice",10F).Args(10);
            	// our method will be called in a new thread
            	Thread theThread = new Thread(new ThreadStart(RunWithWait));
            	theThread.Start();
            	// If we use Verify we dont know when the thread will actually be called
            	// Here we WAIT 1000 milliseconds for the mocked methods to be called, or the timeout.
            	productMock.VerifyWithTimeout(1000);		
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestCallsInOtherThread()
               ' Let mock the product - this will mock the next invocation of Product,
               ' it will mock constructors too so our price will be 0
               Dim productMock As Mock = MockManager.Mock(GetType(Product), Constructor.NotMocked)
               ' CalculatePrice will return 10 - expect 10 as argument
               productMock.ExpectAndReturn("CalculatePrice", 10.0F).Args(10)
               ' our method will be called in a new thread
               Dim theThread As Thread = New Thread(AddressOf RunWithWait)
               theThread.Start()
               ' If we use Verify we dont know when the thread will actually be called
               ' Here we WAIT 1000 milliseconds for the mocked methods to be called, or the timeout.
               productMock.VerifyWithTimeout(1000)
            End Sub
            </code></example></remarks>
      <param name="millisecondsTimeout">Time to wait for all expected methods to be called</param>
    </member>
    <member name="M:TypeMock.Mock.Clear(System.String)">
      <summary>
            Clear expectation of a method
            </summary>
      <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify" /></remarks>
      <param name="method">Name of method to remove expectations</param>
    </member>
    <member name="M:TypeMock.Mock.Clear">
      <summary>
            Clear all expectations 
            </summary>
      <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify" /></remarks>
    </member>
    <member name="M:TypeMock.Mock.Clear(TypeMock.ExpectationBlock)">
      <summary>
            Clear expectation of an expectation block
            </summary>
      <remarks>
            There are times when you want to clear expectations of the mock.
            For example, if you use a utility class that contains an expectation block that
            is not needed in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify" /><seealso cref="M:TypeMock.Mock.GetBlock(System.String)" /></remarks>
      <param name="block">The Block to Clear</param>
    </member>
    <member name="M:TypeMock.Mock.GetCallCount(System.String)">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <remarks>
            Can be used as part of a validation. 
            <example>
            In the following example we validate that the doSomething() Method has been called 3 times, 
            while keeping the original functionality (not mocked)
            </example><code lang="cs">
            [Test]
            public void Test()
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	t.doSomething();
            	t.doSomething();
            	t.doSomething();
            	Assert.AreEqual(3,mock.GetCallCount("doSomething"));
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass()
            	t.doSomething()
            	t.doSomething()
            	t.doSomething()
            	Assert.AreEqual(3,mock.GetCallCount("doSomething"))
            End Sub
            </code>
            For Properties and Indexers see <see cref="M:TypeMock.Mock.GetCallPropertyGetCounter(System.String)" /> ,
            <see cref="M:TypeMock.Mock.GetCallPropertySetCounter(System.String)" /> and <see cref="M:TypeMock.Mock.GetCallIndexerCounter" /><note><c>mock.GetCallCount("doSomething")</c> is equivalent to 
            <c>MockManager.CalledCounter("TestClassLibrary.TestedClass","doSomething")</c>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)" /></note></remarks>
      <param name="method">String representation of Method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.Mock.GetCallCount(System.String,System.Type[])">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <param name="methodName">String representation of Method</param>
      <param name="genericMethodTypes">Generic parameters list of the method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.Mock.GetCallPropertyGetCounter(System.String)">
      <summary>
            Return the amount of times a property has been called
            </summary>
      <remarks>
            See <see cref="M:TypeMock.Mock.GetCallCount(System.String)" /></remarks>
      <param name="propertyName">String representation of the Property</param>
      <returns>Number of times the property has been called</returns>
    </member>
    <member name="M:TypeMock.Mock.GetCallPropertySetCounter(System.String)">
      <summary>
            Return the amount of times a property has been set
            </summary>
      <remarks>
            See <see cref="M:TypeMock.Mock.GetCallCount(System.String)" /></remarks>
      <param name="propertyName">String representation of the Property</param>
      <returns>Number of times the property has been set</returns>
    </member>
    <member name="M:TypeMock.Mock.GetCallIndexerCounter">
      <summary>
            Return the amount of times an indexer has been called
            </summary>
      <remarks>
            See <see cref="M:TypeMock.Mock.GetCallCount(System.String)" /></remarks>
      <returns>Number of times the indexer has been called</returns>
    </member>
    <member name="M:TypeMock.Mock.StartBlock">
      <summary>
            Start an expectation block
            </summary>
      <remarks>
        <para>
            Group a number of expectation. When grouping expectations in a block you can control
            The expectation dynamically. This is very useful when setting up a mock infrastructure.
            After defining a block it is possible to:
            <list type="number"><item>Remove the block using <see cref="M:TypeMock.Mock.Clear(TypeMock.ExpectationBlock)" />.
            </item><item>
            Add expectations before the block using <see cref="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock)" />.
            </item></list>		 
            Blocks can be labeled and can be later on referred to by <see cref="M:TypeMock.Mock.GetBlock(System.String)" />.
            
            Blocks can have different <see cref="T:TypeMock.VerifyMode" />s.
            <example>
            The following example shows a utility method that sets up expectations 
            for an AccessController
            <code lang="cs">
            private Mock SetupExpectations()
            {
            	//Mock all invocation of AccessController, 
            	Mock mock = MockManager.MockAll(typeof(AccessController));
            
            	// start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal);
            	 // We expect that the login method will be called and we will return 
            	 // AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 // second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	return mock;
            }
            [Test]
            public void TestSomething()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"));
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// continue with test
            }
            [Test]
            public void TestSomething2()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"));
            	
            	// continue with test
            }
            </code><code lang="vbnet">
            Private Function SetupExpectations() As Mock 
            	'Mock all invocation of AccessController, 
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal)
            	 ' We expect that the login method will be called and we will return 
            	 ' AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 ' second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	SetupExpectations = mock
            End Function
            &lt;Test()&gt; _
            Public Sub TestSomething()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"))
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' continue with test
            End Sub
            &lt;Test()&gt; _
            Public Sub TestSomething2()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"))
            	
            	' continue with test
            End Sub
            </code></example><seealso cref="T:TypeMock.VerifyMode" /><seealso cref="M:TypeMock.Mock.GetBlock(System.String)" /><seealso cref="M:TypeMock.Mock.Clear" /></para>
      </remarks>
      <returns>The Expectation Block</returns>
    </member>
    <member name="M:TypeMock.Mock.StartBlock(System.String)">
      <summary>
            Start an expectation block with a label name
            </summary>
      <remarks>
        <seealso cref="M:TypeMock.Mock.StartBlock" />
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
      <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)" /></param>
      <returns>The Expectation Block</returns>
      <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
    </member>
    <member name="M:TypeMock.Mock.StartBlock(TypeMock.VerifyMode)">
      <summary>
            Start an expectation block with a verify mode
            </summary>
      <remarks>
        <seealso cref="M:TypeMock.Mock.StartBlock" />
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
      <param name="mode">The verify mode of the block </param>
      <returns>The Expectation Block</returns>
    </member>
    <member name="M:TypeMock.Mock.StartBlock(System.String,TypeMock.VerifyMode)">
      <summary>
            Start an expectation block with a label and a verify mode
            </summary>
      <remarks>
        <seealso cref="M:TypeMock.Mock.StartBlock" />
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
      <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)" /></param>
      <param name="mode">The verify mode of the block</param>
      <returns>The Expectation Block</returns>
      <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
    </member>
    <member name="M:TypeMock.Mock.GetBlock(System.String)">
      <summary>
            Retrieve Expectation Block, by its label name
            </summary>
      <param name="name">The Expectation blocks label</param>
      <returns>The Expectation block</returns>
      <exception cref="T:TypeMock.TypeMockException">Will be throw if a block doesn't exist
            </exception>
      <seealso cref="M:TypeMock.Mock.StartBlock" />
    </member>
    <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock)">
      <summary>
            Start an expectation block and adds the expectations before another expectation 
            block
            </summary>
      <remarks>
            Add expectations before another expectation block. This is very useful when setting up a mock infrastructure.
            
            Blocks can be labeled and can be later on referred to by <see cref="M:TypeMock.Mock.GetBlock(System.String)" />.
            
            Blocks can have different <see cref="T:TypeMock.VerifyMode" />s.
            <example>
            The following example shows a utility method that sets up expectations 
            for an AccessController
            <code lang="cs">
            private Mock SetupExpectations()
            {
            	//Mock all invocation of AccessController, 
            	Mock mock = MockManager.MockAll(typeof(AccessController));
            
            	// start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal);
            	 // We expect that the login method will be called and we will return 
            	 // AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 // second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	return mock;
            }
            [Test]
            public void TestSomething()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"));
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// continue with test
            }
            [Test]
            public void TestSomething2()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"));
            	
            	// continue with test
            }
            </code><code lang="vbnet">
            Private Function SetupExpectations() As Mock 
            	'Mock all invocation of AccessController, 
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal)
            	 ' We expect that the login method will be called and we will return 
            	 ' AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 ' second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	SetupExpectations = mock
            End Function
            &lt;Test()&gt; _
            Public Sub TestSomething()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"))
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' continue with test
            End Sub
            &lt;Test()&gt; _
            Public Sub TestSomething2()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"))
            	
            	' continue with test
            End Sub
            </code></example><seealso cref="T:TypeMock.VerifyMode" /><seealso cref="M:TypeMock.Mock.GetBlock(System.String)" /><seealso cref="M:TypeMock.Mock.Clear" /></remarks>
      <param name="before">The Expectations block to add expectations before</param>
      <returns>The Expectation Block</returns>
    </member>
    <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock,System.String)">
      <summary>
            Start an expectation block with a label and adds the expectations before another expectation 
            block
            </summary>
      <remarks>
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
      <param name="before">The Expectation block to add expectations before</param>
      <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)" /></param>
      <returns>The Expectation Block</returns>
      <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
    </member>
    <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock,TypeMock.VerifyMode)">
      <summary>
            Start an expectation block with a verify mode and adds the expectations before another expectation 
            block
            </summary>
      <remarks>
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
      <param name="before">The Expectation block to add expectations before</param>
      <param name="mode">The verify mode of the block</param>
      <returns>The Expectation Block</returns>
    </member>
    <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock,System.String,TypeMock.VerifyMode)">
      <summary>
            Start an expectation block with a label and a verify mode, and adds the expectations before another expectation 
            block
            </summary>
      <remarks>
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
      <param name="before">The Expectation block to add expectations before</param>
      <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)" /></param>
      <param name="mode">The verify mode of the block</param>
      <returns>The Expectation Block</returns>
      <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
    </member>
    <member name="M:TypeMock.Mock.EndBlock">
      <summary>
            End an expectation block
            </summary>
      <remarks>
        <seealso cref="T:TypeMock.VerifyMode" />
        <seealso cref="M:TypeMock.Mock.GetBlock(System.String)" />
        <seealso cref="M:TypeMock.Mock.Clear" />
      </remarks>
    </member>
    <member name="P:TypeMock.Mock.Strict">
      <summary>
            Can set the mock to be Strict
            The default is the Methods of Abstract and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
      <remarks>
            By default Mocked Concrete Types are NOT strict this mean that if a call to a mocked
            method was not expected the normal code is executed.
            Mocked Types can be made strict and fail if an unexpected call is made
            <example><code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	// No expectations, the following will run normal passInt if Strict=false
            	// and will fail if Strict=true 
            	t.passInt(10);
            	MockManager.Verify();
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            {
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	' No expectations, the following will run normal passInt if Strict=false
            	' and will fail if Strict=true 
            	t.passInt(10)
            	MockManager.Verify()
            End Sub
            </code></example><note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)" /></note><note>
            When allowing arbitrary abstract methods (methods created dynamically by Typemock Isolator using <see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])" /> or <see cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)" />), 
            Typemock Isolator create the following default behavior:
            1. All void calls just return
            2. Other Methods will return 0 or null depending on the return type
            3. Properties will behave like normal properties
            </note><seealso cref="M:TypeMock.Mock.MethodSettings(System.String)" /><seealso cref="T:TypeMock.VerifyMode" /></remarks>
    </member>
    <member name="P:TypeMock.Mock.StrictStatic">
      <summary>
            Can set the static methods of a mocked type to be Strict
            </summary>
      <remarks>
            By default Mocked Types are NOT strict this mean that if a call to a mocked
            method was not expected the normal code is executed.
            Mocked Types Static Members can be made strict and fail if an unexpected call is made
            <note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)" /></note><seealso cref="M:TypeMock.Mock.MethodSettings(System.String)" /><seealso cref="T:TypeMock.VerifyMode" /></remarks>
    </member>
    <member name="P:TypeMock.Mock.MockedInstance">
      <summary>
             Get the actual instance that is being mocked and controlled. This 
             enables tracking instance mocks to the actual instance
             </summary>
      <note>
             When using instance mocks (Mock and MockObject) this property returns the instance mocked
             </note>
      <note>
             MockObject <see cref="P:TypeMock.MockObject.Object" /> will return the same result although has a different usage
             </note>
      <note>
             MockAll mocks and Mocks that haven't been created yet (new not called) will return null (Nothing in Visual Basic)
             </note>
      <remarks>
             Being able to reference the mocked instance enables testing fields of future object.
             Example of using Typemock Isolator to test a field of a future object
             <example><code lang="cs">
            	public static void CreateAnObject()
            	{
                 TestClass theClass = new TestClass();
                 theClass.field = 5;
                 ...
             }
             [Test]
            	public void VerifyFutureObject()
            	{
            		//Create new Mock for a future Object, no expectations 
            		Mock mock = MockManager.Mock(typeof(TestClass));
            	
            		// Call our code
                 TheClass.CreateAnObject();
             
                 // get the mocked object and test the field
                 TestClass theClass = mock.MockedInstance as TestClass;
                 Assert.AreEqual(5, theClass.field);
            
            		// Verify that all the expected calls have actually been called.
            		MockManager.Verify();
             }
             </code><code lang="vbnet">
            	Public Shared Sub CreateAnObject()
            		Dim theClass As TestClass = New TestClass()
                 theClass.field = 5
                 ...
             End Sub
             
             &lt;Test()&gt; _
            	Public Sub ValidateValidUser()
            		' Create new Mock for a future Object, no expectations 
            		Dim mock As Mock = MockManager.Mock(GetType(TestClass))
            	
            		' call our code
                 TheClass.CreateAnObject()
                 ' Get the mocked object and test the field
                 Dim theClass As TestClass = mock.MockedInstance 
                 Assert.AreEqual(5, theClass.field)
            	
            		' Verify that all the expected calls have actually been called.
            		MockManager.Verify()
             End Sub
             </code></example></remarks>
      <returns>Mock Instance</returns>
    </member>
    <member name="P:TypeMock.Mock.IsFieldMock">
      <summary>
            used to specifiy that this is a mock created for a field inside an object
            </summary>
    </member>
    <member name="P:TypeMock.Mock.ValidateArgsOnVerify">
      <summary>
            Obslolete. Argument validation is done both on calling the method and during Verify.
            </summary>
      <remarks>
            Using ValidateArgsOnVerify, validation errors are thrown after Verify is called.
            This is useful if the validation is done in another thread and you want the thread to continue.
            When Verify is called all argument validations are shown too.
            </remarks>
            The flag will be deleted in future
        </member>
    <member name="P:TypeMock.Mock.MockedType">
      <summary>
            Get the type that is mocked and controlled.
            </summary>
    </member>
    <member name="T:TypeMock.VerifyMode">
      <summary>
            Verify Mode is the way that Typemock Isolator verifies uncalled expected methods
            <seealso cref="M:TypeMock.Mock.StartBlock" /><seealso cref="P:TypeMock.Mock.Strict" /></summary>
    </member>
    <member name="F:TypeMock.VerifyMode.Normal">
      <summary>
            Fail if an expected method is not called
            </summary>
    </member>
    <member name="F:TypeMock.VerifyMode.PassIfNotCalled">
      <summary>
            Pass even if an expected method is not called
            </summary>
    </member>
    <member name="F:TypeMock.VerifyMode.DontClear">
      <summary>
            Expectations will not fail if some calls are still expected and expectations are not cleared.
            To Clear use <see cref="M:TypeMock.Mock.Clear" /> or <see cref="M:TypeMock.MockManager.Init" /></summary>
    </member>
    <member name="P:TypeMock.Mock`1.MockedInstance">
      <summary>
             Get the actual instance that is being mocked and controlled. This 
             enables tracking instance mocks to the actual instance
             </summary>
      <returns name="TMockedType">The mocked Type</returns>
      <note>
             When using instance mocks (Mock and MockObject) this property returns the instance mocked
             </note>
      <note>
             MockObject <see cref="P:TypeMock.MockObject.Object" /> will return the same result although has a different usage
             </note>
      <note>
             MockAll mocks and Mocks that haven't been created yet (new not called) will return null (Nothing in Visual Basic)
             </note>
      <remarks>
             Being able to reference the mocked instance enables testing fields of future object.
             Example of using Typemock Isolator to test a field of a future object
             <example><code lang="cs">
            	public static void CreateAnObject()
            	{
                 TestClass theClass = new TestClass();
                 theClass.field = 5;
                 ...
             }
             [Test]
            	public void VerifyFutureObject()
            	{
            		//Create new Mock for a future Object, no expectations 
            		Mock mock = MockManager.Mock&lt;TestClass&gt;();
            	
            		// Call our code
                 TheClass.CreateAnObject();
             
                 // get the mocked object and test the field
                 TestClass theClass = mock.MockedInstance;
                 Assert.AreEqual(5, theClass.field);
            
            		// Verify that all the expected calls have actually been called.
            		MockManager.Verify();
             }
             </code><code lang="vbnet">
            	Public Shared Sub CreateAnObject()
            		Dim theClass As TestClass = New TestClass()
                 theClass.field = 5
                 ...
             End Sub
             
             &lt;Test()&gt; _
            	Public Sub ValidateValidUser()
            		' Create new Mock for a future Object, no expectations 
            		Dim mock As Mock = MockManager.Mock(Of TestClass)()
            	
            		' call our code
                 TheClass.CreateAnObject()
                 ' Get the mocked object and test the field
                 Dim theClass As TestClass = mock.MockedInstance 
                 Assert.AreEqual(5, theClass.field)
            	
            		' Verify that all the expected calls have actually been called.
            		MockManager.Verify()
             End Sub
             </code></example></remarks>
      <returns>Mock Instance</returns>
    </member>
    <member name="T:TypeMock.MockedEvent">
      <summary>
             MockedEvent is used to validate firing of events.
             <para>
             To use this an event must be mocked first, and then the test can fire that event to test that the correct methods are actually called.
             </para></summary>
      <remarks>
        <para>
             When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance" />[index] property
             The first instance to register to the event will be in index 0, the next instance in 1 and so on.
             </para>
        <para>
          <example>
             Example of one instance of Button having the Click event mocked. We will fire the event to test that our TestedClass
             event handler is called
             <code lang="cs">
             // Part of tested class
             public void Init()
             {
                Button button = new Button();
                button.Click += new EventHandler(button_Click);
             }
             </code><code lang="vbnet">
             Public Sub Init()
                Dim button As Button = New Button
                AddHandler button.Click, AddressOf button_Click
             End Sub
             </code>
             Here is the test
             <code lang="cs">
             [Test]
             public void Test()
             {
                 // we will mock the Click event and save the MockedEvent
                 Mock buttonMock = MockManager.Mock(typeof(Button));
                 MockedEvent buttonHandle = buttonMock.ExpectAddEvent("Click");
                             
                 // we expect button_Click to be called once (when the button is clicked)
                 Mock testedMock = MockManager.Mock(typeof(TestedClass));
                 testedMock.ExpectCall("button_Click");
             
                 // call our code
                 TestedClass test = new TestedClass();
                 test.Init();
             
                 // emulate click.
                 buttonHandle.Fire(this, EventArgs.Empty);
                     
                 // verify that all calls where made
                 MockManager.Verify();
             }
             // Natural Mocks
             [Test]
             public void Test()
             {
                 MockedEvent buttonHandle;
            		// Start mocking 
                 using (RecordExpectations recorder = RecorderManager.StartRecording())
                 {
                    // we will mock the Click event and save the MockedEvent
                    Button buttonMock = new Button();
                    buttonMock.Click += null;
                    buttonHandle = RecorderManager.LastMockedEvent;
            
                    // we expect button_Click to be called once (when the button is clicked)
                    TestedClass testMock = new TestedClass();
                    testMock.button_Click(null,null); // use Reflective Mocks if this is private 
                 }
             
                 // call our code
                 TestedClass test = new TestedClass();
                 test.Init();
             
                 // emulate click.
                 buttonHandle.Fire(this, EventArgs.Empty);
                     
                 // verify that all calls where made
                 MockManager.Verify();
             }
             </code><code lang="vbnet">
             &lt;Test()&gt; _
             Public Sub Test()
                 ' we will mock the Click event and save the MockedEvent 
                 Dim buttonMock As Mock = MockManager.Mock(GetType(Button))
                 Dim buttonHandle As MockedEvent = buttonMock.ExpectAddEvent("Click")
             
                 ' we expect button_Click to be called once (when the button is clicked)
                 Dim testedMock As Mock = MockManager.Mock(GetType(TestedClass))
                 testedMock.ExpectCall("button_Click")
             
                 ' call our code
                  Dim test As New TestedClass
                  test.Init()
             
                  ' emulate click.
                  buttonHandle.Fire(Me, EventArgs.Empty)
                  ' Verify that all calls were made 
                  MockManager.Verify()
            	End Sub
             
             ' .NET 2.0 Natural Mocks
             &lt;Test()&gt; _
             Public Sub Test()
                Dim buttonHandle As MockedEvent
                Dim test As New TestedClass
                Using recorder As New RecordExpectations
                   ' mock the Click event and save the MockedEvent 
                   Dim buttonMock As Button = New Button()
                   AddHandler buttonMock.Click, AddressOf test.button_Click
                   buttonHandle = RecorderManager.LastMockedEvent
                   
                   ' we expect button_Click to be called once (when the button is clicked)
                   testMock.button_Click(Nothing, Nothing) ' use Reflective Mocks if this is private 
                 End Using   
             
                  ' call our code
                  test.Init()
             
                  ' emulate click.
                  buttonHandle.Fire(Me, EventArgs.Empty)
                  ' Verify that all calls were made 
                  MockManager.Verify()
            	End Sub    
             </code>
             For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations" /></example>
        </para>
             Since Version 3.6
             </remarks>
    </member>
    <member name="F:TypeMock.MockedEvent.keepReturnValues">
      <summary>
            Used to get return values for NaturalMocks, so that we can do recorder.Repeat
            </summary>
    </member>
    <member name="M:TypeMock.MockedEvent.Fire(System.Object[])">
      <summary>
            Fire a mocked event
            </summary>
      <param name="args">Arguments to pass to the mocked event</param>
      <returns>The return value of the event</returns>
    </member>
    <member name="M:TypeMock.MockedEvent.GetEventHandle">
      <summary>
            Retrieve the EventHandle
            </summary>
      <remarks>
            Using GetEventHandle can help write type-safe tests by casting the EventHandle to the correct Event Type
            Example
            <code lang="cs">
            EventHandler fire = handle.GetEventHandle() as EventHandler;
            fire(this, EventArgs.Empty);
            </code><code lang="vbnet">
            Dim fire As EventHandler = handle.GetEventHandle()
            fire(Me, EventArgs.Empty)
            </code></remarks>
      <returns>The Event</returns>
    </member>
    <member name="P:TypeMock.MockedEvent.Instance">
      <summary>
            Retrieve the <see cref="T:TypeMock.IMockedEvent" /> when more than one instance of the event published is mocked
            <para>
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            This is used to simulate firing the event.
            </para></summary>
      <remarks>
        <example>
            Following is an example of 2 Buttons whose Click event is mocked. The test will fire both Buttons one after
            the other.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code></example>
            Since Version 3.7
            </remarks>
    </member>
    <member name="P:TypeMock.MockedEvent.InstanceCount">
      <summary>
            Return the number of instances registered to this mocked event. See <see cref="P:TypeMock.MockedEvent.Instance" /></summary>
      <remarks>
            Since version 3.7
            </remarks>
    </member>
    <member name="T:TypeMock.MockedEventsList">
      <summary>
            List of mocked events.
            <para>
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance" />[index] property.
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            </para><see cref="T:TypeMock.IMockedEvent" /></summary>
      <remarks>
            Since Version 3.7
            </remarks>
    </member>
    <member name="P:TypeMock.MockedEventsList.Count">
      <summary>
            Return the number of mocked events in the list
            </summary>
    </member>
    <member name="P:TypeMock.MockedEventsList.Item(System.Int32)">
      <summary>
            Get an <see cref="T:TypeMock.IMockedEvent" /> that was previously registers. 
            <para>
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.</para></summary>
      <param name="index">The index of the <see cref="T:TypeMock.IMockedEvent" /> to retrieve</param>
      <returns>The <see cref="T:TypeMock.IMockedEvent" /></returns>
    </member>
    <member name="M:TypeMock.MockedTypesList.AddTypeWithHierarchy(System.Type)">
      <summary>
            Adds the type with all its base classes to the mocked list
            </summary>
      <param name="type">The new type that is being mocked</param>
    </member>
    <member name="T:TypeMock.UnexpectedCallException">
      <summary>
            Thrown when call was made to a mock object but wasn't registered
            see: <see cref="P:TypeMock.Mock.Strict" /></summary>
    </member>
    <member name="T:TypeMock.StrictFlags">
      <summary>
            Flags that define the behavior of Arbitrary (not expected) calls. The default is the Methods of Abstract and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
      <remarks>
            When testing for mock interactions there are times when the default behavior needs to be changed, 
            the StrictFlags define which arbitrary methods we allow.
            <note>
            When allowing arbitrary abstract methods (methods created dynamically by Typemock Isolator using <see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])" /> or <see cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)" />), 
            Typemock Isolator create the following default behavior:
            1. All void calls just return
            2. Other Methods will return 0 or null depending on the return type
            3. Properties will behave like normal properties
            </note><note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)" /> or <see cref="M:TypeMock.RecordExpectations.FailWhenCalled" /></note></remarks>
    </member>
    <member name="F:TypeMock.StrictFlags.AllMethods">
      <summary>
            All methods are strict and if an arbitrary method is called the test will fail
            This is equivalent to : StrictFlags.InstanceMethods | StrictFlags.StaticMethods
            </summary>
    </member>
    <member name="F:TypeMock.StrictFlags.InstanceMethods">
      <summary>
            Instance methods are strict and if an arbitrary instance method is called the test will fail
            </summary>
    </member>
    <member name="F:TypeMock.StrictFlags.StaticMethods">
      <summary>
            Static methods are strict and if an arbitrary static method is called the test will fail
            </summary>
    </member>
    <member name="F:TypeMock.StrictFlags.MethodsOfAbstractTypes">
      <summary>
            This is the default. Methods of Abstract classes and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
    </member>
    <member name="F:TypeMock.StrictFlags.ArbitraryMethodsAllowed">
      <summary>
            Methods are not strict and arbitrary methods are allowed
            </summary>
    </member>
    <member name="T:TypeMock.Constructor">
      <summary>
            Scope of Constructors to Mock. see MockManager.<see cref="M:TypeMock.MockManager.Mock(System.Type,TypeMock.Constructor)" /></summary>
      <remarks>
            .NET code has support for two constructors the first is the normal constructor that is run 
            every time a new instance is created and the other is the static constructor that is run the
            first time the object is referenced too. This constructor sets up all the static fields.
            </remarks>
    </member>
    <member name="F:TypeMock.Constructor.Mocked">
      <summary>
            Both regular constructor and static constructors should be mocked out
            </summary>
    </member>
    <member name="F:TypeMock.Constructor.StaticNotMocked">
      <summary>
            Only regular constructors should be mocked out
            </summary>
    </member>
    <member name="F:TypeMock.Constructor.NotMocked">
      <summary>
            Both Constructors will run as normal and wont be mocked
            </summary>
    </member>
    <member name="F:TypeMock.MockManager.m_InDecoratedCodeImplementation">
      <summary>
            mean that we are in the implementation of the decoration code
            </summary>
    </member>
    <member name="F:TypeMock.MockManager.mockedTypes">
      <summary>
            Stores all classes (with all inheriteance hirarchy) that user has requested to mock.
            </summary>
    </member>
    <member name="F:TypeMock.MockManager.staticCtorsRecorder">
      <summary>
            Stores all cctors in correct order
            </summary>
    </member>
    <member name="F:TypeMock.MockManager.m_CallCounterMap">
      <summary>
            Stores counters for all method calls
            </summary>
    </member>
    <member name="F:TypeMock.MockManager.DynamicMocksAssembly">
            Strong Name for Typemock Isolator Dynamic Objects can be used when mocking internal interfaces
            Use for [assembly: InternalsVisibleTo(MockManager.DynamicMocksAssembly)] 
            This will work for both regular and signed assemblies
            When you don't want to reference TypeMock.dll use the following:
            [assembly: InternalsVisibleTo("DynamicMockAssembly,PublicKey=0024000004800000940000000602000000240000525341310004000001000100ab8e3015b99a732d20ecb2a29fb3f54288a8a614896e7c5091d7b9045368fe6b8bfcc72dce4f01b71281eb4e380dcb709c83a5042a54c684a4711248c078fefb01bcdb09a6ce252e0304ed08c6e4ddf69212e3d0a770d953572e3c474fc08fe3bdbb2fad97b32c6045c08f34466dc8e07bd255d3dbc72408dce6859edb4b04bf")]
        </member>
    <member name="M:TypeMock.MockManager.#ctor">
      <summary>
            Disallow creation on instance
            </summary>
    </member>
    <member name="M:TypeMock.MockManager.GetMockAll(System.Type,System.Object)">
      <summary>
            Returns the mock for all instances of a type, or null if it is not mocked
            </summary>
      <param name="type">Type to return the mock</param>
      <param name="typeGenericParams">the generic params of type</param>
      <returns>The mock</returns>
      <remarks>
        <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)" />
        <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)" />
        <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)" />
        <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)" />
        <seealso cref="M:TypeMock.MockManager.GetMockedTypes" />
        <seealso cref="M:TypeMock.MockManager.GetMocks" />
      </remarks>
    </member>
    <member name="M:TypeMock.MockManager.MockReturnObject(System.Type,TypeMock.Constructor,System.Object[])">
      <summary>
            Same as MockObject but doesn't check for mocked while locked
            </summary>
      <param name="type">
      </param>
      <param name="mockConstructors">
      </param>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledCounter(System.String,System.String)">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <remarks>
            Can be used as part of a validation. 
            <example>
            In the following example we validate that the doSomething() Method has been called 3 times, 
            while keeping the original functionality (not mocked)
            </example><code lang="cs">
            [Test]
            public void Test()
            {
            	// init collecting on
            	MockManager.Init(true);
            	TestedClass t = new TestedClass();
            	t.doSomething();
            	t.doSomething();
            	t.doSomething();
            	Assert.AreEqual(3,MockManager.CalledCounter("TestClassLibrary.TestedClass","doSomething"));
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	' init collecting on
            	MockManager.Init(true)
            	Dim t As TestedClass = New TestedClass
            	t.doSomething()
            	t.doSomething()
            	t.doSomething()
            	Assert.AreEqual(3,MockManager.CalledCounter("TestClassLibrary.TestedClass","doSomething"))
            End Sub
            </code>
            For Properties and Indexers see <see cref="M:TypeMock.MockManager.CalledPropertyGetCounter(System.String,System.String)" /> ,
            <see cref="M:TypeMock.MockManager.CalledPropertySetCounter(System.String,System.String)" /> and <see cref="M:TypeMock.MockManager.CalledIndexerCounter(System.String)" /><note>
            Calls from Types of the System.* namespace will not be collected until the type is mocked
            </note></remarks>
      <param name="type">String representation of Type</param>
      <param name="methodName">String representation of Method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledCounter(System.Type,System.String)">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <param name="type">The type we want count one of its methods</param>
      <param name="methodName">String representation of Method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledCounter(System.Type,System.String,System.Type[])">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <param name="type">The type we want count one of its methods</param>
      <param name="methodName">String representation of Method</param>
      <param name="genericMethodTypes">Generic parameters list of the method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledCounter``1(System.String)">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <typeparam name="TMockType">
      </typeparam>
      <param name="method">String representation of Method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledCounter``1(System.String,System.Type[])">
      <summary>
            Return the amount of times a method has been called
            </summary>
      <typeparam name="TMockType">
      </typeparam>
      <param name="method">String representation of Method</param>
      <param name="genericMethodParams">Generic parameters list of the method</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledPropertyGetCounter(System.String,System.String)">
      <summary>
            Return the amount of times a property has been called
            </summary>
      <remarks>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)" /></remarks>
      <param name="type">String representation of Type</param>
      <param name="propertyName">String representation of the Property</param>
      <returns>Number of times the property has been called</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledPropertySetCounter(System.String,System.String)">
      <summary>
            Return the amount of times a property has been set
            </summary>
      <remarks>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)" /></remarks>
      <param name="type">String representation of Type</param>
      <param name="propertyName">String representation of the Property</param>
      <returns>Number of times the property has been set</returns>
    </member>
    <member name="M:TypeMock.MockManager.CalledIndexerCounter(System.String)">
      <summary>
            Return the amount of times an indexer has been called
            </summary>
      <remarks>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)" /></remarks>
      <param name="type">String representation of Type</param>
      <returns>Number of times the indexer has been called</returns>
    </member>
    <member name="P:TypeMock.MockManager.Version">
      <summary>
            Return Typemock Isolator version
            </summary>
    </member>
    <member name="P:TypeMock.MockManager.IsInitialized">
      <summary>
            Check if Typemock Isolator is initialized <see cref="M:TypeMock.MockManager.Init" /></summary>
    </member>
    <member name="P:TypeMock.MockManager.InSpecialLicenseChain">
      <summary>
            A property that indicates if the licence is part of a special Isolator package.
            </summary>
    </member>
    <member name="M:TypeMock.MockObject.#ctor(TypeMock.Mock,System.Type,TypeMock.Constructor)">
      <exclude />
      <summary>
            Do not create this type, use MockManager.<see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])" /></summary>
      <param name="staticMock">Link to mock for static methods</param>
      <param name="type">Type to be mocked</param>
      <param name="mockConstructors">flag to mock constructors</param>
    </member>
    <member name="P:TypeMock.MockObject.Object">
      <summary>
            Get the Mocked Object
            </summary>
    </member>
    <member name="P:TypeMock.MockObject`1.Object">
      <summary>
            Get the mocked instance. 
            </summary>
    </member>
    <member name="T:TypeMock.MockScope">
      <summary>Create a new instance of the MockScope that will activate the mock
            verification process on its dispose.</summary>
      <remarks>
        <example>
          <code lang="cs"> 
            [Test]
             void TestMethod1()
             {
            	using (new MockScope())
            	{
            		//The Test code
            	}
             }</code>
          <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestMethod1()
                Using Scope As New MockScope
                    ' The Test code
                End Using
            End Sub
            </code>
        </example>
      </remarks>
    </member>
    <member name="F:TypeMock.MockScope.m_Timeout">
      <summary>
            stores the timeout to pass to verify
            </summary>
    </member>
    <member name="M:TypeMock.MockScope.#ctor">
      <summary>Create a new instance of the MockScope that will activate the mock
            verification process on its dispose.</summary>
      <remarks>
        <example>
          <code lang="cs"> 
            [Test]
             void TestMethod1()
             {
            	using (new MockScope())
            	{
            		//The Test code
            	}
             }</code>
          <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestMethod1()
                Using Scope As New MockScope
                    ' The Test code
                End Using
            End Sub
            </code>
        </example>
      </remarks>
    </member>
    <member name="M:TypeMock.MockScope.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:TypeMock.MockScope" /> class, that will call
            the VerifyWithTimeout with the given timeout.
            </summary>
      <param name="millisecondTimeout">The millisecond timeout.</param>
      <summary>Create a new instance of the MockScope that will activate the mock
            verification process on its dispose.</summary>
      <example>
        <para>
        </para>
        <para>
        </para>
        <code lang="cs"> 
            [Test]
             void TestMethod1()
             {
            	using (new MockScope(1000))
            	{
            		//The Test code
            	}
             }</code>
        <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestMethod1()
                Using Scope As New MockScope(1000)
                    ' The Test code
                End Using
            End Sub
            </code>
      </example>
    </member>
    <member name="M:TypeMock.MockScope.Dispose">
      <summary>
            Activate the verification process
            </summary>
    </member>
    <member name="T:TypeMock.State">
      <summary>
            Saves state of object
            </summary>
    </member>
    <member name="T:TypeMock.ObjectState">
      <summary>
             Utility Class that takes a snapshot of all the fields of an object or the static fields of a type
             , in order to reset all the fields back to the saved state.
             </summary>
      <remarks>
             The ObjectState assists testing classes with hidden field, by resetting these field
             when required
             <example>
             The following example we want to test a class that has a static counter.
             <code lang="cs">
             public class StatefulClass
             {
             	static private int count = 0;
             	public int Count {get { return count++ ;}}
             }
            
             [Test]
             public void Stateful()
             {
             	StatefulClass stateful = new StatefulClass();
             	// Save our state
                 ObjectState objState = new ObjectState(state);
                 // Do something to change the state
            		Assert.AreEqual(0,stateful.Count);
            		// lets reset our code for next test
            		objState.ResetState();
            		Assert.AreEqual(0,stateful.Count);
            	}
             </code><code lang="vbnet">
             Public Class StatefulClass
             	Private Shared count As Integer = 0
                 Public ReadOnly Property Count() As Integer
                 	Get
                 		Return _defaultName
                 	End Get
                 End Property
              End Class
            
             &lt;Test()&gt; _
             Public Sub Stateful()
             	Dim stateful As StatefulClass = New StatefulClass
             	' Save our state
                 Dim objState As ObjectState = New ObjectState(state)
                 ' Do something to change the state
            		Assert.AreEqual(0,stateful.Count)
            		' lets reset our code for next test
            		objState.ResetState()
            		Assert.AreEqual(0,stateful.Count)
            	End Sub
             </code></example></remarks>
    </member>
    <member name="M:TypeMock.ObjectState.#ctor(System.Object)">
      <summary>
            Take a snapshot of <b>all</b> the fields of an object, in order to reset
            all the fields back to the saved state.
            </summary>
      <param name="obj">The object to save the state</param>
    </member>
    <member name="M:TypeMock.ObjectState.#ctor(System.Type)">
      <summary>
            Take a snapshot of all the <b>static</b> fields of a type, in order to reset
            all the fields back to the saved state.
            </summary>
      <param name="type">The type to save the state</param>
    </member>
    <member name="M:TypeMock.ObjectState.ResetState">
      <summary>
            Reset the fields back to their original state
            </summary>
    </member>
    <member name="M:TypeMock.ObjectState.SetField(System.String,System.Object)">
      <summary>
            Sets the value of a non-public field (member variable) of the managed type.
            </summary>
      <param name="fieldName">The name of the non-public field to modify.</param>
      <param name="value">value whose type is specific to the field.</param>
    </member>
    <member name="M:TypeMock.ObjectState.SetField(System.Object,System.String,System.Object)">
      <summary>
            Sets the value of a non-public field (member variable) of an instance.
            </summary>
      <param name="obj">The instance to modify</param>
      <param name="fieldName">The name of the non-public field to modify.</param>
      <param name="value">value whose type is specific to the field.</param>
    </member>
    <member name="M:TypeMock.ObjectState.SetField(System.Type,System.String,System.Object)">
      <summary>
            Sets the value of a non-public static field (member variable) of a type.
            </summary>
      <param name="type">The type to modify</param>
      <param name="fieldName">The name of the non-public static field to modify.</param>
      <param name="value">value whose type is specific to the field.</param>
    </member>
    <member name="M:TypeMock.ObjectState.GetField(System.String)">
      <summary>
            Gets the value of a non-public field (member variable) of the managed type.
            </summary>
      <param name="fieldName">The name of the non-public field to modify.</param>
      <returns>value whose type is specific to the field.</returns>
    </member>
    <member name="M:TypeMock.ObjectState.GetField(System.Object,System.String)">
      <summary>
            Gets the value of a non-public field (member variable) of an instance.
            </summary>
      <param name="obj">The instance to read</param>
      <param name="fieldName">The name of the non-public field to modify.</param>
      <returns>value whose type is specific to the field.</returns>
    </member>
    <member name="M:TypeMock.ObjectState.GetField(System.Type,System.String)">
      <summary>
            Gets the value of a non-public static field (member variable) of a type.
            </summary>
      <param name="type">The type to read</param>
      <param name="fieldName">The name of the non-public static field to modify.</param>
      <returns>value` whose type is specific to the field.</returns>
    </member>
    <member name="M:TypeMock.RecorderManager.HasNoAccessibleCtor(System.Type)">
      <summary>
            A boolean method that checks if the "type" param has a Non-Public construtor.
            </summary>
    </member>
    <member name="M:TypeMock.RecordExpectations.Do(TypeMock.DynamicReturnValue)">
      <summary>
            Mock a return value
            </summary>
      <param name="func">Function to perform</param>
      <returns>Ability to modify mock Behavior</returns>
      <remarks>
        <para>
          <example>
            Example of using Natural Mocks� Do
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   TestedClass.MyMethod();
                   recorder.Do(delegate(object[] parameters, object context)
                   {
                       return 5;
                   });
                }
                
                // run our code, This will be mocked 
            	int actual = TestedClass.MyMethod();
                Assert.AreEqual(5,actual);
            	MockManager.Verify();
            }
            </code><code lang="vbnet">
            ' Visual Basic .NET 2.0
            Public Function ReturnValue(ByVal parameters() As Object, ByVal context As Object) As Object 
               ReturnValue = 5
            End function
            End Class
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod()
                   recorder.Do(AddressOf ReturnValue)
                End Using
            
                '  run our code, This will be mocked 
            	Dim actual as Integer = TestedClass.MyMethod()
                Assert.AreEqual(5,actual)
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations" /></example>
        </para>
      </remarks>
    </member>
    <member name="M:TypeMock.RecordExpectations.Dispose">
      <summary>
            Stop RecordExpectations, all methods will be called or mocked
            </summary>
    </member>
    <member name="T:TypeMock.TextualConstants">
      <summary>
             A class that contains constants strings for installation and license messages.
            </summary>
    </member>
    <member name="F:TypeMock.TextualConstants.REFERRAL_PAGE">
      <summary>
            A constat for the web pages that Typemock refer's to.
            </summary>
    </member>
    <member name="F:TypeMock.TextualConstants.LICENSE_EXPIRED">
      <summary>
            A constat for a message that will be received when the license is expired.
            </summary>
    </member>
    <member name="F:TypeMock.TextualConstants.INVALID_LICENSE">
      <summary>
            A constat for a message that will be received when the license invalid.
            </summary>
    </member>
    <member name="M:TypeMock.TypeExpectationMap.GetAllMockedTypes">
      <summary>
            returns all types that has expectations.
            </summary>
      <returns>type array containing list of types that has expectations.</returns>
    </member>
    <member name="M:TypeMock.TypeExpectationMap.VerifyExpectations">
      <summary>
            Verify that all expectations in table has been met
            </summary>
      <returns>String describing the verify problem, an empty string if all expectations has been met</returns>
    </member>
    <member name="M:TypeMock.TypeExpectationMap.VerifyExpectationsWithTimeout(System.Int32)">
      <summary>
            Verify that all expectations in table has been met
            </summary>
      <param name="msec">the timeout in Millisecond</param>
      <returns>String describing the verify problem, an empty string if all expectations has been met</returns>
    </member>
    <member name="M:TypeMock.TypeExpectationMap.HasExpectations(System.Type,System.Boolean)">
      <summary>
            checks if type has any expectations on it (used to decide if cctor should be invoked)
            </summary>
      <param name="type">the type to check</param>
      <param name="checkStaticFields">a bollean parmeter that states if the method should check if there is an exception on static fields</param>
      <returns>true if user set an explicit expecation on any of the methods</returns>
    </member>
    <member name="T:TypeMock.TypeMockException">
      <summary>
            TypeMockException is thrown when illegal arguments are received by <see cref="T:TypeMock.MockManager" /><example>
            For example when trying to return an incorrect type
            </example></summary>
    </member>
    <member name="M:TypeMock.TypeMockException.#ctor(System.String)">
      <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager" /></summary>
      <param name="message">Reason of exception</param>
    </member>
    <member name="M:TypeMock.TypeMockException.#ctor">
      <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager" /></summary>
    </member>
    <member name="M:TypeMock.TypeMockException.#ctor(System.String,System.Exception)">
      <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager" /></summary>
      <param name="message">Reason of exception</param>
      <param name="innerException">Inner Exception</param>
    </member>
    <member name="M:TypeMock.TypeMockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the TypeMockException class with serialized data.
            </summary>
      <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
    </member>
    <member name="T:TypeMock.StackOverflowException">
      <summary>
            An exception that states that there is a potential StackOverflow exception.
            </summary>
      <remarks>
            This class inherit from <see cref="T:TypeMock.TypeMockException" /></remarks>
    </member>
    <member name="M:TypeMock.StackOverflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the StackOverflowException class with serialized data.
            </summary>
      <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
      <param name="ctx">The StreamingContext that contains contextual information about the source or destination.</param>
    </member>
    <member name="M:TypeMock.StackOverflowException.#ctor">
      <summary>
            Initializes a new instance of the StackOverflowException class with serialized data.
            </summary>
      <remarks>The constructor will send the base constructor the message about the potential StackOverflow exception.</remarks>
    </member>
    <member name="T:TypeMock.TypeMockLicenseException">
      <summary>
            Can be thrown when trying to use "Pragmatic design mode" but Typemock version don't support it.
            </summary>
    </member>
    <member name="M:TypeMock.TypeMockLicenseException.#ctor">
      <summary>
            Can be thrown when trying to use "Pragmatic design mode" but Typemock version don't support it.
            </summary>
    </member>
    <member name="T:TypeMock.TypeMockMethodNotMatchException">
      <summary>
            TypeMockMethodNotMatchException is thrown, when a method is not found and/or doesn't match specified parameters 
            (for example: generic arguments, return type, arguments types)
            Also, this is thrown, when a method is ambiguous: more than one method matches to specified parameters.
            </summary>
    </member>
    <member name="M:TypeMock.TypeMockMethodNotMatchException.#ctor(System.String)">
      <summary>
            TypeMockMethodNotMatchException is thrown, when a method is not found and/or doesn't match specified parameters
            </summary>
      <param name="message">Reason of exception</param>
    </member>
    <member name="M:TypeMock.TypeMockMethodNotMatchException.#ctor">
      <summary>
            TypeMockMethodNotMatchException is thrown, when a method is not found and/or doesn't match specified parameters
            </summary>
    </member>
    <member name="T:TypeMock.TypeParamsBuilder">
      <summary>
            This class generate the necessary data of the <seealso cref="T:System.Type" /> it recives.
            </summary>
    </member>
    <member name="M:TypeMock.TypeParamsBuilder.IsTypeParams(System.Object)">
      <summary>
            Checks if the object is an instance of TypeParams type
            </summary>
      <param name="obj">The object to check</param>
    </member>
    <member name="M:TypeMock.TypeParamsBuilder.CreateFromTypes(System.Type[])">
      <summary>
            Constructs the TypeParams object.
            </summary>
      <param name="types">The types whose thier consturctor would be invoked</param>
    </member>
    <member name="M:TypeMock.TypeParamsBuilder.Create(System.Object)">
      <summary>
            Constructs the TypeParams object.
            </summary>
      <param name="obj">The object to convert</param>
    </member>
    <member name="T:TypeMock.InterceptedTypeParamsBuilder">
      <summary>
            This class generate the necessary data of the <seealso cref="T:System.Type" /> it recives.
            </summary>
    </member>
    <member name="M:TypeMock.InterceptedTypeParamsBuilder.IsTypeParams(System.Object)">
      <summary>
            Checks if the object is an instance of TypeParams type
            </summary>
      <param name="obj">The object to check</param>
    </member>
    <member name="M:TypeMock.InterceptedTypeParamsBuilder.CreateFromTypes(System.Type[])">
      <summary>
            Constructs the TypeParams object.
            </summary>
      <param name="types">The types whose thier consturctor would be invoked</param>
    </member>
    <member name="M:TypeMock.InterceptedTypeParamsBuilder.Create(System.Object)">
      <summary>
            Constructs the TypeParams object.
            </summary>
      <param name="obj">The object to convert</param>
    </member>
    <member name="T:TypeMock.RuntimeTypeParamsBuilder">
      <summary>
            This class generate the necessary data of the <seealso cref="T:System.Type" /> it recives.
            </summary>
    </member>
    <member name="M:TypeMock.RuntimeTypeParamsBuilder.IsTypeParams(System.Object)">
      <summary>
            Checks if the object is an instance of TypeParams type
            </summary>
      <param name="obj">The object to check</param>
    </member>
    <member name="M:TypeMock.RuntimeTypeParamsBuilder.CreateFromTypes(System.Type[])">
      <summary>
            Constructs the TypeParams object.
            </summary>
      <param name="types">The types whose thier consturctor would be invoked</param>
    </member>
    <member name="M:TypeMock.RuntimeTypeParamsBuilder.Create(System.Object)">
      <summary>
            Constructs the TypeParams object.
            </summary>
      <param name="obj">The object to convert</param>
    </member>
    <member name="T:TypeMock.TypeParams">
      <summary>
            This class generate the necessary data of the <seealso cref="T:System.Type" /> it recives.
            And implements ovveride to <see cref="T:System.Object" /> methods.
            </summary>
    </member>
    <member name="M:TypeMock.TypeParams.GetTypes">
      <summary>
            A method for invoking the types <seealso cref="M:System.Type.GetType" /> method.
            </summary>
    </member>
    <member name="M:TypeMock.TypeParams.ConvertToStaticGenericContext(System.Object)">
      <summary>
            Converts an object to be a Generic type.
            </summary>
      <param name="context">The object to convert</param>
      <returns>
      </returns>
    </member>
    <member name="M:TypeMock.TypeParams.ToString">
      <summary>
            Override for object's ToString method.
            </summary>
    </member>
    <member name="T:TypeMock.InterceptedTypeParams">
      <summary>
            This class generate the necessary data of the <seealso cref="T:System.Type" /> it recives.
            And implements ovveride to <see cref="T:System.Object" /> methods.
            </summary>
    </member>
    <member name="M:TypeMock.InterceptedTypeParams.#ctor(System.Type[],System.Boolean)">
      <summary>
            Constructor for invoking the types constructor.
            </summary>
      <param name="types">The types whose thier consturctor would be invoked</param>
      <param name="toOverload">
      </param>
    </member>
    <member name="M:TypeMock.InterceptedTypeParams.#ctor(System.Object)">
      <summary>
            Constructor for invoking the types constructor.
            </summary>
      <param name="obj">The object to convert</param>
    </member>
    <member name="M:TypeMock.InterceptedTypeParams.IsTypeParams(System.Object)">
      <summary>
            Checks if the object is an instance of TypeParams type
            </summary>
      <param name="obj">The object to check</param>
    </member>
    <member name="M:TypeMock.InterceptedTypeParams.GetTypes">
      <summary>
            A method for invoking the types <seealso cref="M:System.Type.GetType" /> method.
            </summary>
    </member>
    <member name="M:TypeMock.InterceptedTypeParams.Equals(System.Object)">
      <summary>
            Override for comparing two <see cref="T:TypeMock.TypeParams" />.
            </summary>
      <param name="obj">the objecto to compare</param>
    </member>
    <member name="M:TypeMock.InterceptedTypeParams.GetHashCode">
      <summary>
            A method for invoking the types <seealso cref="M:System.Type.GetHashCode" /> method
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:TypeMock.RuntimeTypeParams">
      <summary>
            This class generate the necessary data of the <seealso cref="T:System.Type" /> it recives.
            And implements ovveride to <see cref="T:System.Object" /> methods.
            </summary>
    </member>
    <member name="M:TypeMock.RuntimeTypeParams.#ctor(System.Type[],System.Boolean)">
      <summary>
            Constructor for invoking the types constructor.
            </summary>
      <param name="types">The types whose thier consturctor would be invoked</param>
      <param name="toOverload">
      </param>
    </member>
    <member name="M:TypeMock.RuntimeTypeParams.#ctor(System.Object)">
      <summary>
            Constructor for invoking the types constructor.
            </summary>
      <param name="obj">The object to convert</param>
    </member>
    <member name="M:TypeMock.RuntimeTypeParams.IsTypeParams(System.Object)">
      <summary>
            Checks if the object is an instance of TypeParams type
            </summary>
      <param name="obj">The object to check</param>
    </member>
    <member name="M:TypeMock.RuntimeTypeParams.GetTypes">
      <summary>
            A method for invoking the types <seealso cref="M:System.Type.GetType" /> method.
            </summary>
    </member>
    <member name="M:TypeMock.RuntimeTypeParams.Equals(System.Object)">
      <summary>
            Override for comparing two <see cref="T:TypeMock.TypeParams" />.
            </summary>
      <param name="obj">the objecto to compare</param>
    </member>
    <member name="M:TypeMock.RuntimeTypeParams.GetHashCode">
      <summary>
            A method for invoking the types <seealso cref="M:System.Type.GetHashCode" /> method
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:TypeMock.VerifyException">
      <summary>
            VerifyException is throw when set expectations are not met (see <see cref="T:TypeMock.Mock" />).
            <para>
            For example when parameters passed are not the ones we expect. When a method is not called or is called
            too often (in Strict mode)
            </para></summary>
    </member>
    <member name="M:TypeMock.VerifyException.#ctor">
      <summary>
            VerifyException is throw when a Mocked call is not as expected <see cref="T:TypeMock.Mock" /></summary>
    </member>
    <member name="M:TypeMock.VerifyException.#ctor(System.String)">
      <summary>
            VerifyException is throw when a Mocked call is not as expected <see cref="T:TypeMock.Mock" /></summary>
      <param name="message">Reason of exception</param>
    </member>
    <member name="M:TypeMock.VerifyException.#ctor(System.String,System.Exception)">
      <summary>
            VerifyException is throw when a Mocked call is not as expected <see cref="T:TypeMock.Mock" /></summary>
      <param name="message">Reason of exception</param>
      <param name="innerException">Inner Exception</param>
    </member>
    <member name="M:TypeMock.VerifyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            For serialization
            </summary>
      <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
    </member>
    <member name="P:TypeMock.VerifyException.BaseMessage">
      <summary>
            Get only base message
            </summary>
    </member>
    <member name="T:TypeMock.VerifyMocksAttribute">
      <summary> Used to initiate verification at the end of each test. This class cant
             be inherited. </summary>
      <remarks>Any method marks with this attribute will call MockManager.Verify after
             the test is done. A marked class will do this for any test defined in
             it.</remarks>
      <example>
        <code lang="cs">
             [TestFixture] 
             [ClearMocks] // clear all mocks between tests
             public TestClass
             {
                 [Test]
                 [VerifyMocks] // verify the mocks after this tests
                 void test1()
                 {
                     // Set Expectations
            
                     // the test code
                 }
             }</code>
        <code lang="vbnet">
             &lt; TestFixture &gt;_
             &lt; ClearMocks &gt;_ ' clear all mocks between tests
             Public class TestClass
                 &lt; Test &gt;_
                 &lt; VerifyMocks &gt;_ ' verify the mocks after this tests
                 Public Sub test1()
                    ' Set expectations
             
                    ' the test code
                 End Sub
             End Class</code>
      </example>
      <seealso cref="T:TypeMock.VerifyMocksAttribute">ClearMocksAttribute</seealso>
      <seealso cref="M:TypeMock.MockManager.Verify">MockManager.Verify</seealso>
    </member>
    <member name="M:TypeMock.VerifyMocksAttribute.#ctor">
      <summary>
            Create an instance of the attribute.
            when this attribute is specified the mock verification process will be initiated automatically
            at the end of the test method (when specified on a class it will be done for each test method)
            </summary>
      <notes>
            Using this constuctor will not ignore stale mocks.
            </notes>
    </member>
    <member name="M:TypeMock.VerifyMocksAttribute.#ctor(System.Int32)">
      <summary>
            Create an instance of the attribute, initializing it with the given timeout.
            When a timeout is specified the auto verify will call the verification with timeout process.
            </summary>
      <param name="timeout">the given timeout (in milliseconds)</param>
    </member>
    <member name="M:TypeMock.VerifyMocksAttribute.Execute">
            Called by the framework instead of the original method. This will run the original method and 
            afterwards will initiate the verification process.
            <remarks>If the test has failed on its own, verification will not be called but all expectations will be cleared
            anyway.</remarks><returns>The results from activating the original invoker on the test</returns><exception cref="T:TypeMock.VerifyException">if verify fails</exception></member>
    <member name="P:TypeMock.VerifyMocksAttribute.Timeout">
      <summary>
            Get and Set the timeout (in milliseconds) for all expectations to complete
            </summary>
    </member>
    <member name="P:TypeMock.FakeLog.FakeLogManager.FakeLogProvider">
      <summary>
            Gets or sets FakeLogProvider to handle printing trace of fakes used.
            </summary>
    </member>
    <member name="P:TypeMock.FakeLog.FakeLogManager.FakeLogEnabled">
      <summary>
            Gets or sets FakeLogEnabled.
            </summary>
      <remarks>
            General FakeLogManager turn on/off switch.
            </remarks>
    </member>
    <member name="M:TypeMock.Internal.InternalDynamicSwapper.CompareMethodInfoByLength(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>
            Compare two MethodInfo by length of name
            </summary>
      <param name="a">MethodInfo to compare</param>
      <param name="b">MethodInfo to compare</param>
      <returns>value &gt; 0 - b is larger, value = 0 - same length, value %lt 0 - a is larger </returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.IsNullable(System.Type)">
      <summary>
            chek to see if type can be assigned a null value
            </summary>
      <param name="type">the given type</param>
      <returns>true if type can be assigned a null value, false if not</returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.InstanceMethodExists(System.Type,System.String)">
      <summary>
            check if there is a method of the given name on this type
            (for now will also check for static methods)
            </summary>
      <param name="type">
      </param>
      <param name="methodName">
      </param>
      <returns>true if there is at least one method by that name</returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.StaticMethodExists(System.Type,System.String)">
      <summary>
            check to see if there is a STATIC method on the given type
            </summary>
      <param name="type">the type </param>
      <param name="methodName">the method name</param>
      <returns>true if there is at least one method method</returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.FindInstanceMethod(System.Type,System.String)">
      <summary>
            locate a method with the given name on the type 
            (for now consider static method as well)
            </summary>
      <param name="type">the given type</param>
      <param name="methodName">the method name</param>
      <returns>a MethodBase object representing the first found method</returns>
      <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
    </member>
    <member name="M:TypeMock.Internal.Reflection.FindStaticMethod(System.Type,System.String)">
      <summary>
            locate a STATIC method with the given name on the type
            </summary>
      <param name="type">the given type</param>
      <param name="methodName">the method name</param>
      <returns>a MethodBase object representing the first found method</returns>
      <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
    </member>
    <member name="M:TypeMock.Internal.Reflection.FindInstanceMethod(System.Type,System.String,System.Type,System.Type[],System.Type[],System.Boolean)">
      <summary>
            search for a method answering all the given criteria:
              name
              generic method signature (e.g. SomemMthod[X,Y])
              Matching return type (can be void also)
            For now will incldue static method in its search.
            </summary>
      <param name="type">the given type</param>
      <param name="methodName">the method name</param>
      <param name="returnType">the supplied return type </param>
      <param name="argumentTypes">the arguments types list</param>
      <param name="genericTypes">the generic signature list</param>
      <param name="simulateOldAPI">use old API behavior</param>
      <returns>a MethodBase for a method answering all of the above conditions</returns>
      <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
    </member>
    <member name="M:TypeMock.Internal.Reflection.FindStaticMethod(System.Type,System.String,System.Type,System.Type[],System.Type[])">
      <summary>
            search for a STATIC method answering all the given criteria:
              name
              generic method signature (e.g. SomemMthod[X,Y])
              Matching return type (can be void also)
            </summary>
      <param name="type">the given type</param>
      <param name="methodName">the method name</param>
      <param name="returnType">the supplied return type </param>
      <param name="argumentTypes">the arguments types list</param>
      <param name="genericTypes">the generic signature list</param>
      <returns>a MethodBase for a method answering all of the above conditions</returns>
      <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
    </member>
    <member name="M:TypeMock.Internal.Reflection.ConstructClosedType(System.Type,System.Type[],System.Type[],System.Type)">
      <summary>
            Constructs a completely bounded type.
            </summary>
      <param name="genericType">the given type we need to constructs</param>
      <param name="methodGenericArguments">the generic arguments from the associated call</param>
      <param name="classGenericArguments">the generic arguments from the associated class</param>
      <param name="declaringType">the declaring type of a method</param>
      <returns>a fully binded type</returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.GetBoundedRuntimeType(System.Object,System.Reflection.MethodBase)">
      <summary>
            This will return the bounded generic type in which the method is declared
            this can either be the type of the context instance, or one of his ancestors types
            </summary>
      <param name="context">the instance on which the call was made</param>
      <param name="info">the method call data</param>
      <returns>The vounded type on which the call was made </returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.GetTypeGenericArguments(System.Object,System.Reflection.MethodBase)">
      <summary>
            This returns the generic arguments of the type associated with the call.
            i.e. the bounded type on which the call was issued
            </summary>
      <param name="context">this either contains the instance on which the call was made, 
            the TypeParams of the class in cases of generic static calls or null (regular static calls)</param>
      <param name="info">the call method</param>
      <returns>
      </returns>
    </member>
    <member name="M:TypeMock.Internal.Reflection.MatchReturnArgument(System.Collections.Generic.List{System.Reflection.MethodBase},System.Type,System.Type[],System.Type@)">
      <summary>
            Filter out the methods with matching return types 
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.GetMethodMatchingGenericDefinition(System.Collections.Generic.IEnumerable{System.Reflection.MethodBase},System.Type[])">
      <summary>
            Filter out the methods with matching generic signature
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.GetStaticMethods(System.Collections.Generic.List{System.Reflection.MethodBase})">
      <summary>
            Filter out instance methods returning only instance methods
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.FindTypeInGivenList(System.Reflection.MethodInfo,System.Type[])">
      <summary>
            will find the method return type in the generic signature
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.TypeMatches(System.Type,System.Type)">
      <summary>
            return true if the types matches according to our logic:
                1) DynamicReturnValue always match
                2) if user gave a null value we match if the method return type can be assigne da null value
                3) do a smart generic matching bound generic types
                4) unbound generic types always match
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.MatchGenericTypes(System.Type,System.Type)">
      <summary>
            do smart match of for a generic type by comparing the generic type definition
            to the generic type definiton of the other class along with his entire class hirarchy or implemented interfaces 
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.FindMethodsByName(System.Type,System.String,System.Reflection.BindingFlags,System.Boolean)">
      <summary>
            collect all methods on the type any of his base class or implemented interfaces with the given name
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.GenericString(System.Type[])">
      <summary>
            convert the type list into a nice presentable string
            </summary>
    </member>
    <member name="M:TypeMock.Internal.Reflection.BuildException(System.String,System.String,System.Type,System.Collections.Generic.List{System.Reflection.MethodBase},System.Type)">
      <summary>
            build a smart exception string based on the scenario
            </summary>
    </member>
    <member name="F:TypeMock.Internal.StaticConstructorsHandler.recordedType">
      <summary>
            contain the list of all types that their cctor was encountered during
            the recording phase and therefore was not activated.
            </summary>
    </member>
    <member name="T:TypeMock.Internal.Hooks.ShouldInterceptDelegate">
      <summary>
            This delegate is called when a method call is detected. Its implementation can be a filter that
            decides whether the method call will be intercepted, not intercepted, or analyzed by Isolator
            </summary>
    </member>
    <member name="T:TypeMock.Internal.Hooks.DuringCallDelegate">
      <summary>
            This delegate is called after a method has been intercepted. Its implementation can be a filter
            that decides how to handle the call: return a custom value, throw an exception, skip the method
            altogether, or let Isolator decide
            </summary>
    </member>
    <member name="F:TypeMock.Internal.Hooks.EventTunnel.ShouldInterceptDecision">
      <summary>
            This delegate is called when a method call is detected. Its implementation can be a filter that
            decides whether the method call will be intercepted, not intercepted, or analyzed by Isolator
            </summary>
    </member>
    <member name="F:TypeMock.Internal.Hooks.EventTunnel.DuringMethodCall">
      <summary>
            This delegate is called after a method has been intercepted. Its implementation can be a filter
            that decides how to handle the call: return a custom value, throw an exception, skip the method
            altogether, or let Isolator decide
            </summary>
    </member>
    <member name="T:TypeMock.Internal.Hooks.IsolationBehavior">
      <summary>
            Enum that indicate what is the Isolation behavior.
            </summary>
    </member>
    <member name="F:TypeMock.Internal.Hooks.IsolationBehavior.LetIsolatorDecide">
      <summary>
            Isolator will decide the behavior.
            </summary>
    </member>
    <member name="F:TypeMock.Internal.Hooks.IsolationBehavior.SkipMethod">
      <summary>
            Indicate that Isolator skips the mocked method.
            </summary>
    </member>
    <member name="F:TypeMock.Internal.Hooks.IsolationBehavior.ReturnCustomValue">
      <summary>
            Indicate that Isolator will return a custom value from the mocked method.
            </summary>
    </member>
    <member name="F:TypeMock.Internal.Hooks.IsolationBehavior.ThrowException">
      <summary>
            Indicate that Isolator will throw an Exception from themocked method.
            </summary>
    </member>
    <member name="T:TypeMock.Internal.Hooks.InterceptBehavior">
      <summary>
            Enum that indicate if the call for the method should be intercepted.
            </summary>
    </member>
    <member name="M:TypeMock.AddinConnection.AddInListener.CheckMutexIfInBreakMode">
      <summary>
            Checks if we are in Break Mode according to the Mutex.
            If we are, result is true, and we need to release the lock.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:TypeMock.AddinConnection.AddInListener.DebuggingMode">
      <summary>
            In Run mode, functions need to be run, thus setting expectations in Typemock Isolator
            But in Break mode, we don't want to evaluate functions that will set the expectation, 
            and this way we can block them. 
            If we are in Break mode, we know this by acquiring the mutex, and so we need to release it
            </summary>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.RecursiveFakeEndNodesNotifier.CallBackForEndNodeOfRecursiveFakes">
      <summary>
            Use this to receive a callback when reaching value types of recursive fakes
            </summary>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.RecursiveFakeEndNodesNotifier.CallBackForSetAutoProperty">
      <summary>
            Use this to receive a callback when an auto property is set 
            </summary>
      <remarks>
            The first method will be the getter method.
            </remarks>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.NestedCallException">
      <summary>
            NestedCallException is thrown when a method call is used as an argument for a method inside a WhenCalled() statement<para /><example><code>WhenCalled(() =&gt; A.B(C.D())).IgnoreCall; // will throw NestedCallException </code>
            Instead you should do:
            <code>
            var argument = C.D();
            WhenCalled(() =&gt; A.B(argument)).IgnoreCall()
            </code></example></summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.NestedCallException.#ctor(System.String)">
      <summary>
            NestedCallException is thrown when a method call is used as an argument for a method inside a WhenCalled() statement
            </summary>
      <param name="message">Reason of exception</param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.NestedCallException.#ctor">
      <summary>
            NestedCallException is thrown when a method call is used as an argument for a method inside a WhenCalled() statement
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.NestedCallException.#ctor(System.String,System.Exception)">
      <summary>
            NestedCallException is thrown when a method call is used as an argument for a method inside a WhenCalled() statement
            </summary>
            /// <param name="message">Reason of exception</param><param name="innerException">Inner Exception</param></member>
    <member name="M:TypeMock.ArrangeActAssert.NestedCallException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            NestedCallException is thrown when a method call is used as an argument for a method inside a WhenCalled() statement
            </summary>
            /// <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param><param name="context">The StreamingContext that contains contextual information about the source or destination.</param></member>
    <member name="M:TypeMock.ArrangeActAssert.NestedCallException.#ctor(System.String,TypeMock.TypeMockException.TypemockExceptionType)">
      <summary>
            NestedCallException is thrown when a method call is used as an argument for a method inside a WhenCalled() statement
            </summary>
            /// /// <param name="message">Reason of exception</param><param name="exceptionType">Type of the Exception</param></member>
    <member name="M:TypeMock.ArrangeActAssert.ValuesGenerators.ReferenceTypeValueGenerator.SetFakeLogDefinedStackFrameForLazyRecursiveFakes(TypeMock.Mock,TypeMock.MockObject)">
      <summary>
            Set FakeLog Definition StackFrame for lazy created Recursive Fakes.
            </summary>
      <remarks>
             Recursive fake Mocks for child objects are implicitly defined with a parent object faking.
             But, in opposite to Parent object Mock, which is created immediately, children's Mocks
             are created in lazy way - on their first usage.
             Since we need a Definition Stack Frame for a definition place, we'll take the father's
             Definition StackFrame.
            </remarks>
      <param name="parentMock">Parent mock.</param>
      <param name="childMock">Child mock.</param>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IHideObjectMethods">
      <summary>
            Hides the methods that are inherited from the class Object.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IHideObjectMethods.Equals(System.Object)">
      <summary>
            Hides the Equals method that is inherited from the class Object.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IHideObjectMethods.GetHashCode">
      <summary>
            Hides the GetHashCode method that is inherited from the class Object.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IHideObjectMethods.ToString">
      <summary>
            Hides the ToString method that is inherited from the class Object.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IHideObjectMethods.GetType">
      <summary>
            Hides the GetType method that is inherited from the class Object.
            </summary>
    </member>
    <member name="T:TypeMock.RunnerUtils">
      <summary>
            Utilities Methods to use with Typemock Smart Runner
            </summary>
    </member>
    <member name="M:TypeMock.RunnerUtils.GetOriginalPath(System.Reflection.Assembly)">
      <summary>
            Find Original Path of Assembly while in test.
            </summary>
      <remarks>
            Typemock Smart Runner, copies all assemblies to a shadow copy in order to allow developers to continue to build while the tests are run.
            This is a helper method to reach original location
            </remarks>
      <example> 
            [Test]
            public void Test_That_Calls_A_File()
            {
               var fileLocation = RunnerUtils.GetOriginalPath(typeof(UnderTest).Assembly);
               var file = Path.Combine(Path.GetDirectoryName(fileLocation), "mydatabase.db");
               
               var result = UnderTest.ReadAllUsersIn(file);
               // Assert
            }    
            </example>
      <param name="assembly">An Assembly that is part of the test</param>
      <returns>path to original location</returns>
    </member>
    <member name="T:TypeMock.DontRunAttribute">
      <summary>
            TypemockRunnerAttribute signals Isolator automatic runner not to run the decorated method or class automatically
            </summary>
      <example>
            Usage example to signal runner to not run the test automatically
            <code> [TestMethod]
            [DontRun]
            public void SpecialTest()
            {
                // Test logic here
            }</code></example>
      <remarks>
            If the test assembly doesn't have a reference to Isolator, it can be added a new attirbute with the same name
            and the runner will treat it the same way as it was decorated with Typemock DontRun attirubte.
            </remarks>
      <example>
            An example of custom attribute defined in test assembly
            <code> [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
            public class DontRunAttribute : Attribute { }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.UseCultureAttribute">
      <summary>
            Sets the current culture for the duration of a test.
            <para>
            The culture remains set until the test completes and is then reset to its original value.
            </para><example><code lang="cs">
            [TestClass]
            public TestClass
            {
                [TestMethod, UseCulture("fr-FR")]
                public void MyTest()
                {
                    // the test code
                }
            }
            </code><code lang="vbnet">
            &lt; TestClass &gt;
            Public Class MyTestClass
                &lt; TestMethod, UseCulture("fr-FR") &gt;
                Public Sub MyTest()
                   ' the test code
                End Sub
            End Class
            </code></example></summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.UseCultureAttribute.#ctor(System.String)">
      <summary>
            Default constructor
            </summary>
      <param name="culture">The culture value to use in the test thread</param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.UseCultureAttribute.Execute">
      <summary>
            Executes the decorated method with the predefined culture
            </summary>
      <returns>The execution result of the decorated method</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.UseCultureAttribute.Dispose">
      <summary>
            Restores the current thread original culture
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.UseCultureAttribute.SetCulture">
      <summary>
            Sets the current thread culture
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.UseCultureAttribute.ResetCulture">
      <summary>
            Restores the original culture of the current thread
            </summary>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.UseCultureAttribute.Culture">
      <summary>
            Gets or sets the culture value to use in the test thread
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Args">
      <summary>
            Args is a helper class for creating and passing Value\Reference\Out arguments into a non-public invoked methods.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Args.Ref``1(``0)">
      <summary>
            Creates a wrapper for passing an argument by reference.
            </summary>
      <param name="argParam">An initialized argument to be passed</param>
      <typeparam name="T">The type of the passed argument</typeparam>
      <returns>A wrapper that can be passed to Isolate.Invoke.Method() as a parameter</returns>
      <remarks>
            Ref helps create a wrapper for passing an argument by reference as part of the params argument list of Isolate.Invoke.Method()
            After the method invocation, it can be checked to the updated value.
            </remarks>
      <example>
        <code>var byRef = Args.Ref(5);
            Isolate.Invoke.Method("MethodName", byRef, 2);
            var result = byRef.Value;
            </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Args.Out``1">
      <summary>
            Creates a wrapper for passing an Out argument by reference
            </summary>
      <typeparam name="T">The type of the passed Out argument</typeparam>
      <returns>A wrapper that can be passed to Isolate.Invoke.Method() as a parameter</returns>
      <remarks>
            Out helps create a wrapper for passing an Out argument by reference as part of the params argument list of Invoke.Method()
            Since an Out value is created inside the called method, there's no argument to pass. 
            After the method invocation, the wrapper can be checked for the updated value.
            </remarks>
      <example>
        <code>var outParam = Args.Out&lt;Type&gt;();
            Isolate.Invoke.Method("MethodName", outParam, 2);
            var result = outParam.Value;
            </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Args.Null``1">
      <summary>
            Creates a wrapper for passing null - nullable arguments so it will be possible to collect information from the passed arguments
            in order to call the correct non-public method. 
            </summary>
      <typeparam name="T">The type of the argument</typeparam>
      <returns>
            A wrapper that can be passed to Isolate.Invoke.Method() as a parameter
            </returns>
      <remarks>
            Null helps create a wrapper for passing a null initialized argument for a nullable type. While it 
            can be stored, it is better to use as an inline argument in the params section of Inovke.Method.
            </remarks>
      <example>
        <code>
              var nullParamToPrivateMethod = new NullParamToPrivateMethod();
              var result = (int)Isolate.Invoke.Method(nullParamToPrivateMethod, "CallMe", Args.Null&lt;int?&gt;());
            </code>
      </example>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.NonPublicField.fieldName">
      <summary>
            Name of field to access
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.NonPublicField.type">
      <summary>
            Type in which the field is defined
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.RecorderBase.ChangeLastCallToBase(System.Type)">
      <summary>
            Call this before InvokeAndRecord to change last to base.
            </summary>
      <param name="baseType">
      </param>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Members">
      <summary>
            A behavior setting on how the fake object is created.
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.Members.MustSpecifyReturnValues">
      <summary>
            All void calls are ignored. Unless using WhenCalled on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.Members.CallOriginal">
      <summary>
            All methods are called. Using WhenCalled allow to change this behavior.
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.Members.ReturnNulls">
      <summary>
            All void calls are ignored. Unless using WhenCalled on methods that return values and properties, they will return null values (or zero for value types).
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes">
      <summary>
            Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.Members.MustBeSpecified">
      <summary>
            All method behaviors must be define or calling them will throw a <see cref="T:TypeMock.TypeMockException" />.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ConstructorWillBe">
      <summary>
            A behavior setting that states how the fake object's constructor will behaves.
            </summary>
      <remarks>
            When not using the ConstructorWillBe enum the default behavior for constructor is using the following rules:
             * When using Members.CallOriginal - The original constructor is called.
             * When using all other Members enums the constructor is not called.
            </remarks>
      <example>
        <code>
            var fake = Isolate.Fake.Instance&lt;ClassToFake;(Members.ReturnRecursiveFakes, ConstructorWillBe.Called, BaseConstructorWillBe.Ignored);
            </code>
      </example>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored">
      <summary>
            Don't execute constructor when creating a fake object
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Called">
      <summary>
            Run constructor when creating a fake object
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.BaseConstructorWillBe">
      <summary>
            A behavior setting on how the base object's constructor behaves
            </summary>
      <example>
        <code>
            var fake = Isolate.Fake.Instance&lt;ClassToFake;(Members.ReturnRecursiveFakes, ConstructorWillBe.Called, BaseConstructorWillBe.Ignored);
            </code>
      </example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type,System.Object[])" />
    </member>
    <member name="F:TypeMock.ArrangeActAssert.BaseConstructorWillBe.Ignored">
      <summary>
            Don't execute base constructor when creating a fake object.
            </summary>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type,System.Object[])" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Isolate">
      <summary>
            This is the entry point to all AAA APIs. 
            Use it to fake, swap, set method behavior and verify calls.
            The Isolate APIs use fluent interfaces, thus 
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.GetFake``1(System.Object)">
      <summary>
            Get a fake that was automatically created by Isolate.Fake.Dependencies()
            </summary>
      <typeparam name="T">The Type of the requested dependency</typeparam>
      <param name="instance">An instance that was created with Isolate.Fake.Dependencies()</param>
      <returns>A fake instance</returns>
      <exception cref="T:TypeMock.TypeMockException">Exception is thrown if fake not found, T is a value-type or a string, or instance is null.</exception>
      <remarks>
            To create an instance, where all the dependencies are fake, use Isolate.Fake.Dependencies.
            To change a behavior of these fakes, use Isolate.GetFake to grab the fake, and then change bahavior like any other fake.
            <example>
            Here is an example how to use control a dependency fake of a ClassUnderTest type:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAllDependancies()
            {
                var real = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;();
                var fake = Isolate.GetFake&lt;Dependency&gt;(real);
                Isolate.WhenCalled(()=&gt;fake.GetCustomerId()).WillReturn(100);
                
                real.Log("Test");
                Assert.AreEqual(1, real.Count);
            }
            </code></example></remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Dependencies``1(System.Object[])" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)">
      <summary>
             Accepts a method in the form of a Lambda expression, to set a specific behavior on it.
             </summary>
      <param name="action">An Action in a form of a Lambda expression (with no parameters) that expresses the method we want to set a behavior on.</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a call:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Increment call will be ignored (stubbed)
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1.AndArgumentsMatch(System.Func{`0,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Action{``0,``1})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Action{``0,``1,``2})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Action{``0,``1,``2,``3})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Action{``0,``1,``2,``3,``4})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Action{``0,``1,``2,``3,``4,``5})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Action{``0,``1,``2,``3,``4,``5,``6})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="action">An Action in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Func{``0})">
      <summary>
            Accepts a method in the form of a Lambda expression, to set a specific behavior on it.
            </summary>
      <param name="func">A function in the form of a Lambda Expression (with no parameters) that expresses the method we want to set a behavior on.</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
            Here is an example how to use WhenCalled in order to return a value:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of IntCall()
                Isolate.WhenCalled(() =&gt; fake.IntCall()).WillReturn(10);
            
                Assert.AreEqual(10, fake.IntCall());
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})">
      <summary>
            Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
            The expression's parameters are used to define custom argument matching.
            </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
            The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1.AndArgumentsMatch(System.Func{`0,System.Boolean})" /> method
            to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`2" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})">
      <summary>
            Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
            The expression's parameters are used to define custom argument matching.
            </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
            The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})" /> method
            to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`3" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})">
      <summary>
            Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
            The expression's parameters are used to define custom argument matching.
            </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
            The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})" /> method
            to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`4" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Func{``0,``1,``2,``3,``4})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4.AndArgumentsMatch(System.Func{`0,`1,`2,`3,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Func{``0,``1,``2,``3,``4,``5})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Func{``0,``1,``2,``3,``4,``5,``6})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
      <summary>
             Accepts a method in the form of a parametric Lambda expression, to set a specific behavior on it. 
             The expression's parameters are used to define custom argument matching.
             </summary>
      <param name="func">A function in a form of a Lambda expression that expresses the method we want to set a behavior on.
             The parameters passed to the action will be used in the <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,System.Boolean})" /> method
             to define custom arguments matching</param>
      <returns>A <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods.</remarks>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Isolate.CleanUp">
      <summary>
            CleanUp should be called at the end of a test. It can be substituted with the <see cref="T:TypeMock.ArrangeActAssert.IsolatedAttribute" />.
            The method cleans all the mockes the have been created by the test.
            </summary>
      <example>
            Here is an example how to use CleanUp. The following test uses CleanUp:
            <code>
            [TestMethod]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Increment call will be ignored (stubbed)
                Isolate.WhenCalled(() =&gt; fake.IntCall()).WillReturn(10);
            
                Assert.AreEqual(10, fake.IntCall());
                Isolate.CleanUp();
            }
            </code>
            
            The following test uses IsolatedAttribute and similar in functionality: 
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Increment call will be ignored (stubbed)
                Isolate.WhenCalled(() =&gt; fake.IntCall()).WillReturn(10);
            
                Assert.AreEqual(10, fake.IntCall());
            }
            </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Isolate.Swap">
      <summary>
             A read-only property, used to swap objects and behaviors
             </summary>
      <returns>
             An <see cref="T:TypeMock.ArrangeActAssert.Fluent.ISwapper" /> interface reference.
             </returns>
      <remarks>
             Because of the nature of fluent interface, you need to use Swap with one of its proceeding methods - 
             see <see cref="T:TypeMock.ArrangeActAssert.Fluent.ISwapper" /> for details.
             </remarks>
      <example>
             This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.NextInstance``1" />.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)" /> in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void SwapAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 Isolate.Swap.NextInstance&lt;RealLogger&gt;().With(fake);
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code>
             This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)" />.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" /> in order to 
             redirect calls from an object to a stand-in object:
             <code>
             [TestMethod]
             [Isolated]
             public void SwapCallsOnObject_CallsRedirectedToTargetObject()
             {
                 // Create the object under test
                 RealLogger logger = new RealLogger();
                 // Create the object calls will be redirected to
                 TestLogger swapped = new TestLogger();
             
                 // Redirect any calls from the object under test to the swapping target
                 Isolate.Swap.CallsOn(logger).WithCallsTo(swapped);
             
                 // logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
                 logger.Write("Hello World");
             
                 // We can still verify the call to logger.Write() happened
                 Isolate.Verify.WasCalledWithAnyArguments(() =&gt; logger.Write(""));
             }
             
             // excerpt code for the class under test:
             public class RealLogger
             {
                 string logFilePath = ...;
                 public void Write(string toWrite)
                 {
                     logFile.WriteAllText(logFilePath, toWrite);
                 }
             }
             
             // excerpt code for the replacement class:
             public class TestLogger
             {
                 public void Write(string toWrite)
                 {
                     Console.WriteLine("RealLogger.Write() was called with {0}", toWrite);
                 }
             }
             </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Isolate.Fake">
      <summary>
             A read-only property, used to fake a new object.
             </summary>
      <returns>
             An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IFaker" /> interface reference.
             </returns>
      <remarks>
             Because of the nature of fluent interface, you need to use Fake with its proceeding methods - 
             see <see cref="T:TypeMock.ArrangeActAssert.Fluent.IFaker" /> for details.
             </remarks>
      <example>
             This example shows how to use Fake in order to fake a RealLogger instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Increment call will be ignored (stubbed)
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IFaker" />
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Isolate.NonPublic">
      <summary>
             A read-only property, used to fake Non-Public members
             </summary>
      <returns>
             An IIsolateNonPublic reference
             </returns>
      <remarks>
             Because of the nature of fluent interface, you need to use NonPublic with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic" /><para>
             When handling non public (private, protected, internal) class members all access to method names is string-based.
             </para></remarks>
      <example>
             This example shows how to use NonPublic in order to set behavior on a private method:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // Avoid performing actual write to disk by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled(fake, "WriteToDisk").IgnoreCall();
             
                 // This call is faked - count should not increment
                 fake.Log("Hello World");
            
                 Assert.AreEqual(1, fake.LineCount);
                 // Verify the private call was actually made
                 Isolate.Verify.NonPublic.WasCalled(fake, "WriteToDisk").WithArguments("Hello World");
             }
             </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Isolate.Verify">
      <summary>
            Return a verifying object that can verify calls were made or not, and check if their arguments were sent correctly.
            </summary>
      <returns>An ICallVerifier interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, you need to use Verify with one of its proceeding methods: 
            <see cref="M:TypeMock.ArrangeActAssert.Verifier.WasCalledWithAnyArguments(System.Action)" />, <see cref="M:TypeMock.ArrangeActAssert.Verifier.WasCalledWithExactArguments(System.Action)" />, <see cref="M:TypeMock.ArrangeActAssert.Verifier.WasNotCalled(System.Action)" />
            and <see cref="P:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.NonPublic" /></remarks>
      <example>
            This example shows how to use Verify in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStubWasCalled_FailWhenNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment();
            
               Isolate.Verify.WasCalledWithAnyArguments(() =&gt; fake.Increment());
            }
            </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Isolate.Invoke">
      <summary>
            A read-only property, used to invoke the object's private\static methods.
            </summary>
      <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IInvoker" /> interface reference.
            </returns>
      <remarks>
            The <see cref="T:TypeMock.ArrangeActAssert.Fluent.IInvoker">Invoker</see> enables code to fire events of objects.
            </remarks>
      <example>
            The following test fires an event and verifies that registered subscriber was notified.
            <code>
            [TestMethod]
            [Isolated]
            public void FireEvent_SubscribersWereNotified()
            {
                bool wasCalled = false;
            
                var logger = new RealLogger();
                logger.Initialized += (sender, args) =&gt; wasCalled = true;
            
                Isolate.Invoke.EventWithDefaultArguments(() =&gt; logger.Initialized += null);
            
                Assert.IsTrue(wasCalled);
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IInvoker" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.IsolatedAttribute">
      <summary> Used to clean up the defined expectations. This attribute can't be inherited.</summary>
      <remarks>Any method marks with this attribute will clean all set expectation
            after the test is done. A marked class will do this for any test defined in
            it. The attribute can be replaced with the <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.CleanUp" /> method.</remarks>
      <example>
        <code lang="cs">
            [TestFixture]
            [Isolated]
            public TestClass
            {
                [Test]
                public void MyTest1()
                {
                    // the test code
                }
            }</code>
        <code lang="vbnet">
            &lt; TestFixture &gt;_
            &lt; Isolated &gt;_ 
            Public class TestClass
                &lt; Test &gt;_
                Public Sub MyTest1()
                   ' the test code
                End Sub
            End Class
            </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.IsolatedAttribute.#ctor">
      <summary>
            IsolatedAttribute constructor. Defines the DesignMode property
            to be the default Pragmatic mode.
            </summary>
      <seealso cref="T:TypeMock.ArrangeActAssert.IsolatedAttribute" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.IsolatedAttribute.#ctor(TypeMock.ArrangeActAssert.DesignMode)">
      <summary>
            IsolatedAttribute constructor. Let's you specify the DesignMode 
            to override the default Pragmatic mode for either the assmebly,
            class or test scope.
            </summary>
      <param name="design">Can be either of the following:
            <list type="bullet"><item><description>Pragmatic. The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </description></item><item><description>InterfaceOnly. This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a DesignModeException.
            </description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.IsolatedAttribute.Execute">
      <summary>
            Called by the framework instead of the original method. This will run the original method and 
            afterwards clear the MockManager.
            </summary>
      <returns> the result of the original method</returns>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.IsolatedAttribute.Design">
      <summary>
            This property defines the design mode for either an assembly, class or a test method scope.
            </summary>
      <value>
            By default, Isolator�s design mode is Pragmatic. In Pragmatic design mode, you can fake any 
            method in any class, including static, sealed or private. In InterfaceOnly design mode, only 
            virtual methods can be faked. Use the DesignMode property explicitly on either assembly, class 
            or a test to override the default, or a higher level specification. For example, you can 
            specify DesignMode.InterfaceOnly in the assembly level, but specify 
            DesignMode.Pragmatic for a specific test.
            
            The property can be set to one of the following values:
            <list type="bullet"><item><description>
            Pragmatic. The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </description></item><item><description>
            InterfaceOnly. This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a Typemock.DesignModeException.
            </description></item></list></value>
      <example>
        <code lang="cs">
            [TestFixture]
            [Isolated(Design = DesignMode.InterfaceOnly)]
            public TestClass
            {
                [Test]
                public void MyTest1()
                {
                    // the test code
                }
            }</code>
        <code lang="vbnet">
            &lt; TestFixture &gt;_
            &lt; Isolated (Design := DesignMode.InterfaceOnly) &gt;_ 
            Public class TestClass
                &lt; Test &gt;_
                Public Sub MyTest1()
                   ' the test code
                End Sub
            End Class
            </code>
      </example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.DesignMode">
      <summary>
            The two different design modes available for mocking:
            <list type="bullet"><item><description>
            Pragmatic. The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </description></item><item><description>
            InterfaceOnly. This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a Typemock.DesignModeException.
            </description></item></list></summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.DesignMode.Pragmatic">
      <summary>
            The default Pragmatic mode allows faking any type and method, 
            including sealed, static or private.
            </summary>
    </member>
    <member name="F:TypeMock.ArrangeActAssert.DesignMode.InterfaceOnly">
      <summary>
            This mode allows faking only abstract or interface types, and
            public non-virtual methods. Otherwise it throws a Typemock.DesignModeException.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Verifier.GetTimesCalled``1(System.Func{``0})">
      <summary>
            Return the calls count on non void method.
            </summary>
      <param name="func">A Func expression of the method we want to get the count.</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Verifier.GetTimesCalled(System.Action)">
      <summary>
            Return the calls count on void method.
            </summary>
      <param name="action">An Action expression of the method we want to get the count.</param>
      <returns>Number of times the method has been called</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Suggest.SuggestIgnoreAttribute">
      <summary>
             Typemock Isolator will NOT suggest tests automatically for a method/class/assembly marked with this attribute
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Suggest.PotentialBugAttribute">
      <summary>
             Used to mark a test as a potential bug. 
             SafetyNet marks tests with this attribute automatically
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.PotentialBugAttribute.#ctor(System.String)">
      <summary>
            Mark test as a potential bug
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute">
      <summary>
             Used to mark a test fixture as auto-generated. 
             Typemock Smart Runner uses this attribute to determine if tests should run in a restricted environment.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute.#ctor(System.Type)">
      <summary>
            Mark test class as auto-generated. When sandboxed (default option), tests will run in a restricted environment.
            </summary>
      <param name="underTest">The type for which the tests were generated for.</param>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute.Sandbox">
      <summary>
            Should generated test be run in a sandboxed environment. Default is true.
            </summary>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Suggest.SafetyNetAttribute.UnderTest">
      <summary>
            The under test type for which the tests were generated for.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Suggest.SuggestBehaviorAttribute">
      <summary> Used to support backward compatability to sequencing. This attribute cant be inherited.</summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Suggest.TestUtil">
      <summary>
            Utility Class for test generated by Typemock SafetyNet
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.CallStaticCtor(System.Type)">
      <summary>
            Reset a type by calling its static constructor and resetting all of the static fields.
            </summary>
      <param name="type">The type to reset</param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.CallStaticCtor(System.Type,System.String)">
      <summary>
            Reset a private type by calling its static constructor and resetting all of the static fields.
            </summary>
      <param name="publicTypeToGetAssembly">Any public type in the assembly of the private type</param>
      <param name="privateTypeName">Name of private type to reset</param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ResetAllStatics">
      <summary>
            Enables and resets all statics fields by rerunning static constructors.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ExcludeResetStaticsOfType(System.String)">
      <summary>
            Specify types to not reset when using ResetAllStatics
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.SafeguardModuleInitializer">
      <summary>
            Support faking of Module initializer
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.AssertRunningInSandbox">
      <summary>
            Assert that we are running in a sandboxed environment to make sure that we don't call API's that can ruin the system. Directory.Delete for example
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ElementIsType``1(System.Collections.IEnumerable,System.Int32)">
      <summary>
            Helper method to check if the n'th item of a collections is of type T, used in suggested unit tests
            </summary>
      <typeparam name="T">Type of item</typeparam>
      <param name="collection">Collection to find item</param>
      <param name="index">Index of item to find</param>
      <returns>True if item is of correect type</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.GetElementAt``1(System.Collections.IEnumerable,System.Int32)">
      <summary>
            Helper method to get the n'th item of a collections as type T, used in suggested unit tests
            </summary>
      <typeparam name="T">Type of item</typeparam>
      <param name="collection">Collection to return item</param>
      <param name="index">Index of item to return</param>
      <returns>Item as T</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.TestUtil.ElementsCount(System.Collections.IEnumerable)">
      <summary>
            Helper method to count the elements in a collections, used in suggested unit tests
            </summary>
      <param name="collection">Collection to count</param>
      <returns>Number of elements</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Suggest.ActualCoverage">
      <summary>
            Used in test generated by Typemock SafetyNet.
            This class will make sure that we get coverage for the method under test and not the setup methods.
            </summary>
      <example>
        <code>
            var underTest = new UnderTest(5);
            int result;
            using (new ActualCoverage())
            {
               result = underTest.MethodUnderTest(8);
            }
            </code>
            Asset.IsEqual(12, result);
            </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.ActualCoverage.#ctor">
      <summary>
            When called Typemock Smart Runner will start collecting actual coverage
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Suggest.ActualCoverage.Dispose">
      <summary>
            When called Typemock Smart Runner will stop collecting actual coverage
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IBox`1">
      <summary>
            An interface that exposes the boxed value of ref or out parameters.
            </summary>
      <remarks>
            When invoking a non-public method that need ref or out arguments, use the Args class methods to create 
            boxed values you can later check for their values.</remarks>
      <typeparam name="T">The type of the boxed value</typeparam>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.IBox`1.Value">
      <summary>
             Retrieve the value returned from boxed out or ref arguments
             </summary>
      <example>
        <code lang="cs">
             [TestClass]
             public class UnitTest1
            {
                [TestMethod]
                public void InvokingPrivateStaticMethodsWithRef()
                {
                    IBox&lt;int&gt; val1 = Args.Ref(10);
                    Isolate.Invoke.Method&lt;Foo&gt;("DoSomething", val1);
            
                    Assert.AreEqual(13, val1.Value);
                }
            }
            
            public class Foo
            {
                private static int DoSomething(ref int x)
                {
                    x = 13;
                    return 0;
                }
            }
             </code>
      </example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicField">
      <summary>
            A class that is used to control hidden fields
            </summary>
      <example>
            This example shows how to use Isolate.NonPublic.StaticField in order to set the field with a fake:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateField_WithRecursiveFake()
            {
                var fake = Isolate.NonPublic.StaticField&lt;MyClass&gt;("m_field").SetRecursiveFake&lt;TypeOfField&gt;();
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                Isolate.WhenCalled(() =&gt; fake.Foo()).WillReturn(1);
                // continue with test
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicField.SetRecursiveFake">
      <summary>
            Set the field to a recursive fake
            </summary>
      <returns>The faked object set to field</returns>
      <see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.StaticField``1(System.String)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicField.SetRecursiveFake``1">
      <summary>
            Set the field to a recursive fake
            </summary>
      <typeparam name="FieldType">The type of the field to fake</typeparam>
      <returns>The faked object set to field</returns>
      <see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.StaticField``1(System.String)" />
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.INonPublicField.Value">
      <summary>
            Get/Set the Value of the field
            </summary>
      <example>
            This example shows how to use Isolate.NonPublic.StaticField in order to asset a field value:
            <code>
            [TestMethod]
            [Isolated]
            public void AssertPrivateField()
            {
                var underTest = new UnderTest();
                underTest.DoSomething();
                var result = Isolate.NonPublic.StaticField&lt;UnderTets&gt;("m_field").Value;
                Assert.AreEqual(4, result);
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicInstanceField">
      <summary>
            Class that is used to control hidden fields
            </summary>
      <remarks>
            Use this class to access the fields, access the field in a base class, set the field as a fake and
            set the field on a future fake
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.InstanceField in order to set the field with a fake:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateField_WithRecursiveFake()
            {
                var instance = new MyClass();
                var fake = Isolate.NonPublic.InstanceField(instance,"m_field").SetRecursiveFake&lt;TypeOfField&gt;();
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                Isolate.WhenCalled(() =&gt; fake.Foo()).WillReturn(1);
                // continue with test
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicInstanceField.OfBase">
      <summary>
            Get/Set/Fake field that is defined in base
            </summary>
      <remarks>Use this to handle a field that is defined in base and derived</remarks>
      <returns>
            A <see cref="T:TypeMock.ArrangeActAssert.NonPublicInstanceField" /> reference
            </returns>
      <example>
            This example shows how to use Isolate.NonPublic.InstanceField in order to set a base field:
            <code>
            public class BaseClass
            {
                public int m_inDerived = 0;
            }
             
            public class DerivedOfBase : BaseClass
            {
                public new int m_inDerived = 0;
            }
             
            [TestMethod]
            [Isolated]
            public void SetPrivateField_OfBase()
            {
                var instance = new DerivedOfBase();
                var fake = Isolate.NonPublic.InstanceField(instance,"m_field").OfBase().Value = 8;
                // continue with test
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicInstanceField.OfBase``1">
      <summary>
            Get/Set/Fake field that is defined in base
            </summary>
      <remarks>Use this to handle a field that is defined in base and derived</remarks>
      <typeparam name="BaseTypeOfField">The Base Type that the field is defined in</typeparam>
      <returns>
            A <see cref="T:TypeMock.ArrangeActAssert.NonPublicField" /> reference
            </returns>
      <example>
            This example shows how to use Isolate.NonPublic.InstanceField in order to set a base field:
            <code>
            public class BaseClass
            {
                public int m_inDerived = 0;
            }
             
            public class DerivedOfBase : BaseClass
            {
                public new int m_inDerived = 0;
            }
             
            [TestMethod]
            [Isolated]
            public void SetPrivateField_OfBase()
            {
                var instance = new DerivedOfBase();
                var fake = Isolate.NonPublic.InstanceField(instance,"m_field").OfBase&lt;BaseClass&gt;().Value = 8;
                // continue with test
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IInvoker">
      <summary>
            Interface for invoking events, private methods and static constructors
            </summary>
      <remarks>
            This interface is returned by the <see cref="P:TypeMock.ArrangeActAssert.Isolate.Invoke" /> property.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.StaticConstructor``1">
      <summary>
             Invokes a static constructor represented by requested type.
             </summary>
      <typeparam name="T">The type on which to invoke the constructor.</typeparam>
      <example>
        <code>
              [TestMethod, Isolated]
            public void CallingStaticConstructorTest()
            {
                StaticConstructorExample.TrueOnStaticConstructor = false;
                // force static constructor to be called
                Isolate.Invoke.StaticConstructor&lt;StaticConstructorExample&gt;();
                Assert.IsTrue(StaticConstructorExample.TrueOnStaticConstructor);
            }
            
            public class StaticConstructorExample
            {
                private static bool trueOnStaticConstructor = false;
            
                public static bool TrueOnStaticConstructor
                {
                    get { return trueOnStaticConstructor; }
                    set { trueOnStaticConstructor = value; }
                }
            
                static StaticConstructorExample()
                {
                    trueOnStaticConstructor = true;
                }
            }
             </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.StaticConstructor(System.Type)">
      <summary>
             Invokes a static constructor represented by requested type.
             </summary>
      <param name="type">The type on which to invoke the constructor.</param>
      <example>
        <code>
              [TestMethod, Isolated]
            public void CallingStaticConstructorTest()
            {
                StaticConstructorExample.TrueOnStaticConstructor = false;
                // force static constructor to be called
                Isolate.Invoke.StaticConstructor(typeof(StaticConstructorExample));
                Assert.IsTrue(StaticConstructorExample.TrueOnStaticConstructor);
            }
            
            public class StaticConstructorExample
            {
                private static bool trueOnStaticConstructor = false;
            
                public static bool TrueOnStaticConstructor
                {
                    get { return trueOnStaticConstructor; }
                    set { trueOnStaticConstructor = value; }
                }
            
                static StaticConstructorExample()
                {
                    trueOnStaticConstructor = true;
                }
            }
             </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Event(System.Action,System.Object[])">
      <summary>
            Fires an event.
            </summary>
      <param name="eventAdderLambda">Accepts a method in the form of a Lambda expression containing a call to the 
            adder of the event being fired. Example: () =&gt; logger.LogEntryCreated += null.
            </param>
      <param name="parameters">The parameters to fire the event with.</param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown when the number of arguments does not match the number of arguments the events expects.
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown when the arguments does not match the parameters types the event expects.
            </exception>
      <example>
            The following test fires an event and sets specific value as event parameter.
            <code>
            [TestMethod]
            [Isolated]
            public void FireEvent_ParameterEqualsRequestedValue()
            {
                int? actualEntryID = null;
            
                var logger = new RealLogger();
                logger.LogEntryCreated += (int entryId) =&gt; actualEntryID = entryId;
            
                var expectedLogEntryID = 100;
                Isolate.Invoke.Event(() =&gt; logger.LogEntryCreated += null, expectedLogEntryID);
            
                Assert.AreEqual(expectedLogEntryID, actualEntryID);
            }
            </code>
            The following test fires event while faking <see cref="T:System.EventHandler">EventHandler</see> default behavior using <see cref="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Event(System.Action,System.Object[])">EventWithExplicitArguments</see>.
            <code>
            [TestMethod]
            [Isolated]
            public void FireEvent_EventHandlerParametersEqualToRequetedValues()
            {
                object actualSender = null;
                EventArgs actualEventArgs = null;
            
                var logger = new RealLogger();
                logger.Initialized += (sender, args) =&gt;
                                          {
                                              actualSender = sender;
                                              actualEventArgs = args;
                                          };
            
                var expectedEventArgs = new EventArgs();
                Isolate.Invoke.Event(() =&gt; logger.Initialized += null, logger, expectedEventArgs);
            
                Assert.AreSame(logger, actualSender);
                Assert.AreSame(expectedEventArgs, actualEventArgs);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Method(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method represented by the current instance, using the specified parameters
            </summary>
      <param name="targetObject">The object on which to invoke the method.</param>
      <param name="methodName">The name of the method</param>
      <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference</param>
      <example>
        <code>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateMethod_ReturnCorrectValue()
            {
                // We will test ProductHandler.InternalCalculateWorth private method 
                var handler = new ProductHandler();
                var product = new Product("product", 10);
            
                // Invoke the event using three arguments and store the result 
                var result = Isolate.Invoke.Method(handler, "InternalCalculateWorth", product, 2, 5);
            
                Assert.AreEqual(15.3, result);
            }
            </code>
      </example>
      <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Method(System.Type,System.String,System.Object[])">
      <summary>
            Invokes a static method represented by the current type, using the specified parameters
            </summary>
      <param name="targetType">The Type on which to invoke the method.</param>
      <param name="methodName">The name of the method</param>
      <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference
            </param>
      <example>
        <code>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateStaticMethod_NewProductAddedToTheFactory()
            {
                // This test invokes the private static method ProductFactory.CreateProduct
                // and checks that the a new product with the same name was created
                ProductFactory.Reset();
                const string productName = "productName";
            
                // Invoke the method using productName as argument
                Isolate.Invoke.Method(typeof(ProductFactory), "CreateProduct", productName);
            
                Assert.IsTrue(ProductFactory.HasProduct(productName));
            }
            </code>
      </example>
      <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Method``1(System.String,System.Object[])">
      <summary>
            Invokes a static method represented by the current type, using the specified parameters
            </summary>
      <typeparam name="T">The Type on which to invoke the method.</typeparam>
      <param name="methodName">The name of the method</param>
      <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference
            </param>
      <example>
        <code>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateStaticMethod_NewProductAddedToTheFactory()
            {
                // This test invokes the private static method ProductFactory.CreateProduct
                // and checks that the a new product with the same name was created
                ProductFactory.Reset();
                const string productName = "productName";
            
                // Invoke the method using productName as argument
                Isolate.Invoke.Method&lt;ProductFactory&gt;("CreateProduct", productName);
            
                Assert.IsTrue(ProductFactory.HasProduct(productName));
            }
            </code>
      </example>
      <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.LocalFunction(System.Object,System.String,System.String,System.Object[])">
      <summary>
            Invokes a local function represented by the current instance, using the specified parameters
            </summary>
      <param name="targetObject">The object on which to invoke the method.</param>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The local function name to invoke.</param>
      <param name="parameters">
            An argument list for the invoked local function. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference</param>
      <example>
        <code>
            [TestMethod]
            [Isolated]
            public void InvokeLocalFunction_InvokePrivateLocalFunction_Return5()
            {
                var fake = Isolate.Fake.Instance&lt;classWithLocal&gt;(Members.callOriginal);
                Isolate.NonPublic.WhenCalledLocal(fake, "UseLocalFunc", "GetLocal").WillReturn(5); 
                
                var result = Isolate.Invoke.LocalFunction(fake, "UseLocalFunc","GetLocal");
            
                Assert.AreEqual(5, result);
            }
            </code>
      </example>
      <returns>An object containing the return value of the invoked local function, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.LocalFunction``1(System.String,System.String,System.Object[])">
      <summary>
            Invokes a static local function represented by the current type, using the specified parameters
            </summary>
      <typeparam name="T">The Type on which to invoke the local function.</typeparam>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The local function name to invoke.</param>
      <param name="parameters">
            An argument list for the invoked method. 
            This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
            If there are no parameters, parameters should be a null reference
            </param>
      <example>
        <code>
            [TestMethod]
            [Isolated]
            public void InvokeLocalFunction_InvokePrivateStaticLocalFunction_Return5()
            {
                Isolate.NonPublic.WhenCalledLocal&lt;PrivateStaticLocalFunction&gt;("UseLocalFunc", "GetLocal").WillReturn(5); 
                
                var result = Isolate.Invoke.LocalFunction&lt;PrivateStaticLocalFunction&gt;("UseLocalFunc","GetLocal");
            
                Assert.AreEqual(5, result);
            }
            </code>
      </example>
      <returns>An object containing the return value of the invoked local function, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.Null``1">
      <summary>
            This method is obsolete please use <seealso cref="M:TypeMock.ArrangeActAssert.Args.Null``1" /> instead.
            </summary>
      <typeparam name="T">The type of the requested argument</typeparam>
      <example>
        <code>
            [TestMethod]
            [Isolated]
            public void InvokeMethod_InvokePrivateStaticMethodWithOutArgument_OutArgumentIsUpdated()
            {
                // This test invokes the private static method with null argument,
                // this method has an overload with the same number of parameters        
            
                var result = (int) Isolate.Invoke.Method&lt;SomeClass&gt;("PrivateStaticOverloadedMethod", Isolate.Invoke.Null&lt;SomeObject&gt;());
                Assert.IsTrue(result != 0);
            }
            </code>
      </example>
      <returns> A boxed null object to send to the private method.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.MethodFromBase``1(System.Object,System.String,System.Object[])">
      <summary>
             Invokes a method represented by the current instance and requested type, using the specified parameters
             </summary>
      <typeparam name="T">The type on which to invoke the method.</typeparam>
      <param name="targetObject">The object on which to invoke the method.</param>
      <param name="methodName">The name of the method</param>
      <param name="parameters">
             An argument list for the invoked method. 
             This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
             If there are no parameters, parameters should be a null reference</param>
      <example>
        <code>
             public class BaseClass
             {
                 protected int Foo()
                 {
                     // Does whatever
                     return 1;
                 }
             }
            
             public class DerivedClass : BaseClass
             {
                 protected new int Foo()
                 {
                     // Does something different from base
                     return 2;
                 }
             }
             
             [TestMethod]
             [Isolated]
             public void InvokeMethod_InvokePrivateMethodOfBase_ReturnCorrectValue()
             {
                 var handler = new DerivedClass();
             
                 // Invoke the protected virtual method of base through the derived instance 
                 var result = Isolate.Invoke.MethodFromBase&lt;BaseClass&gt;(handler, "Foo");
             
                 Assert.AreEqual(1, result);
             }
             </code>
      </example>
      <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.MethodFromBase(System.Type,System.Object,System.String,System.Object[])">
      <summary>
             Invokes a method represented by the current instance and requested type, using the specified parameters
             </summary>
      <param name="type">The type on which to invoke the method.</param>
      <param name="targetObject">The object on which to invoke the method.</param>
      <param name="methodName">The name of the method</param>
      <param name="parameters">
             An argument list for the invoked method. 
             This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
             If there are no parameters, parameters should be a null reference</param>
      <example>
        <code>
             public class BaseClass
             {
                 protected int Foo()
                 {
                     // Does whatever
                     return 1;
                 }
             }
            
             public class DerivedClass : BaseClass
             {
                 protected new int Foo()
                 {
                     // Does something different from base
                     return 2;
                 }
             }
             
             [TestMethod]
             [Isolated]
             public void InvokeMethod_InvokePrivateMethodOfBase_ReturnCorrectValue()
             {
                 var handler = new DerivedClass();
             
                 // Invoke the protected virtual method of base through the derived instance 
                 var result = Isolate.Invoke.MethodFromBase(typeof(BaseClass), handler, "Foo");
             
                 Assert.AreEqual(1, result);
             }
             </code>
      </example>
      <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IInvoker.MethodFromBase(System.Object,System.String,System.Object[])">
      <summary>
             Invokes a method on the base of the passed instance, using the specified parameters
             </summary>
      <param name="targetObject">The object on which to invoke the base method.</param>
      <param name="methodName">The name of the method</param>
      <param name="parameters">
             An argument list for the invoked method. 
             This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. 
             If there are no parameters, parameters should be a null reference</param>
      <example>
        <code>
             public class BaseClass
             {
                 protected int Foo()
                 {
                     // Does whatever
                     return 1;
                 }
             }
            
             public class DerivedClass : BaseClass
             {
                 protected new int Foo()
                 {
                     // Does something different from base
                     return 2;
                 }
             }
             
             [TestMethod]
             [Isolated]
             public void InvokeMethod_InvokePrivateMethodOfBase_ReturnCorrectValue()
             {
                 var handler = new DerivedClass();
             
                 // Invoke the protected virtual method of base through the derived instance 
                 var result = Isolate.Invoke.MethodFromBase(handler, "Foo");
             
                 Assert.AreEqual(1, result);
             }
             </code>
      </example>
      <returns>An object containing the return value of the invoked method, or a null reference in the case of a constructor.</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher">
      <summary>
            Returned by WasCalledWithArguments(), this interface contains methods for verifying arguments used in method calls.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">
      <summary>
            Verifies the argument values passed to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments(System.Action)" /> against a user provided delegate
            </summary>
      <param name="argumentCheckingDelegate">
            A user provided delegate that is used to verify the actual values passed to the call.
            This delegate receives an object array with the actual argument values, and returns true 
            if the argument check passes.
            </param>
      <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1);
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0)).Matching(args =&gt; (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1, "str");
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0, null))
                    .Matching(args =&gt; ((int) args[0] &gt; 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1">
      <summary>
            Interface used for swapping That return a swapping object how is procceded by the <c>With(T fake)</c> method.
            </summary>
      <typeparam name="T">Represents the type of the swapped object</typeparam>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)">
      <summary>
             Specify the fake instance that will replace the created instance.
             </summary>
      <param name="fake">the fake instance that will replace the created instance</param>
      <returns>the fake</returns>
      <example>
        <code>
             [TestMethod]
             [Isolated]
             public void SwapAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 Isolate.Swap.NextInstance&lt;RealLogger&gt;().With(fake);
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.WithRecursiveFake">
      <summary>
             Replace the created instance with a recursive fake.
             </summary>
      <returns>the recursive fake</returns>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1" />
      <example>
        <code>
             [TestMethod, Isolated]
             public void Fake_FutureInstance()
             {
                 var fake = Isolate.Swap.NextInstance&lt;Dependency&gt;().WithRecursiveFake();
            
                 var result = ClassUnderTest.AddSecurly(1, 2);
            
                 Assert.AreEqual(3, result);
             }
             public static int AddSecurly(int x, int y)
             {
               var dependency = new Dependency();
               dependency.Check();
             
               return x + y;
             }
             
             public class Dependency
             {
                 public voi d Check()
                 {
                     throw new Exception("No Entry");
                 }
             }
             </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.ConstructorWillThrow(System.Exception)">
      <summary>
            Specify that an exception will be thrown the next time a construction is encountered for the type
            </summary>
      <param name="ex">The exception that will be thrown when the constructor is called</param>.
            <example><code>
            [TestMethod, Isolated]
            public void FutureInstance_VerifyThrowingExceptionOnCreation()
            {
                // We want a memory handling exception to be thrown the next time a Dependency is instantiated
                Isolate.Swap.NextInstance&lt;Dependency&gt;().ConstructorWillThrow(new OutOfMemoryException());
                var classUnderTest = new ClassUnderTest();
                var result = classUnderTest.Create();
                Assert.AreEqual(null, result);
            }
            </code></example></member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.ICollectionReturnHandler">
      <summary>
            Interface for tweaking behavior for methods returning collection types. This can be used to replace collection values returned
            by a method or property with another test data collection.
            This interface is returned by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" /> method.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ICollectionReturnHandler.WillReturnCollectionValuesOf(System.Collections.IEnumerable)">
      <summary>
            Swaps a collection returned by a method or property with a collection of test data. Follows a call to 
            <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />.
            </summary>
      <param name="collection">The collection to use instead of the replaced collection</param>
      <remarks>
        <para>
            This method is used as a completing statement to <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />, and is used to
            replace the collection in the preceeding statement with the provided collection.
            This is useful when the code under test uses collection data that is prepared externally and then iterated over.
            The collection containing this data can be swapped with a test data collection prepared during the test set up and thus remove
            the dependency on the code populating the collection.
            </para>
        <para>
          <c>Note</c>: because Typemock Isolator does not currently support faking objects implemented in MsCorLib.dll, 
            the source collection used with <c>WhenCalled()</c> cannot be one implemented in MsCorLib, such as 
            <see cref="T:System.Collections.Generic.List`1" /> and <see cref="T:System.Collections.ArrayList" />.
            </para>
      </remarks>
      <exception cref="T:TypeMock.TypeMockException">
            If the lambda expression provided in <c>Isolate.WhenCalled()</c> does not
            evaluate to an object implementing <see cref="T:System.Collections.IEnumerable" />.
            </exception>
      <example>
            This example shows how to use Isolate.<see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ICollectionReturnHandler.WillReturnCollectionValuesOf(System.Collections.IEnumerable)" /> in order to 
            swap a collection data for test data:
            <code>
            [TestMethod]
            [Isolated]
            public void SwapCollectionValues_ReplaceCollectionWithTestData()
            {
                // Create a logger to use as test data
                RealLogger logger = new RealLogger();
                // Swap the logger collection for the class under test with a collection containing the prepared test data
                Isolate.WhenCalled(() =&gt; LoggerFactory.Loggers).WillReturnCollectionValuesOf(new[] { logger });
            
                // Verify the GetLogger() method returned the existing logger instead of creating a new one.
                RealLogger actual = LoggerFactory.GetLogger();
                Assert.AreSame(logger, actual);
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper">
      <summary>
            Interface for performing object to object method call swapping
            </summary>
      <remarks>
            This interface is returned by calling Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)" />. Follow it by calling
            the <see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" /> completing statement.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)">
      <summary>
            Completes swapping method calls for an object. Is called as a completing statement for Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)" />,
            and defines the target object to perform swapping on.
            </summary>
      <param name="swapped">The object whose implementation should be used</param>
      <returns>An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper" /> interface reference. </returns>
      <remarks>
            When a method is called on the swapped object, it is replaced with a corresponding implementation (a method
            with the same signature) on the swapping object. This means that the swapped object will start behaving like
            the object it was swapped with for all methods they have in common.
            <para>
            When a method is called on the swapped object that does not exist in the target object, it will be called on the original
            object.
            </para></remarks>
      <exception cref="T:TypeMock.TypeMockException">
            If there are no compatible methods to swap between the swapping source and target objects.
            </exception>
      <example>
            This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)" />.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" /> in order to 
            redirect calls from an object to a stand-in object:
            <code>
            [TestMethod]
            [Isolated]
            public void SwapCallsOnObject_CallsRedirectedToTargetObject()
            {
                // Create the object under test
                RealLogger logger = new RealLogger();
                // Create the object calls will be redirected to
                TestLogger swapped = new TestLogger();
            
                // Redirect any calls from the object under test to the swapping target
                Isolate.Swap.CallsOn(logger).WithCallsTo(swapped);
            
                // logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
                logger.Write("Hello World");
            
                // We can still verify the call to logger.Write() happened
                Isolate.Verify.WasCalledWithAnyArguments(() =&gt; logger.Write(""));
            }
            
            // excerpt code for the class under test:
            public class RealLogger
            {
                string logFilePath = ...;
                public void Write(string toWrite)
                {
                    logFile.WriteAllText(logFilePath, toWrite);
                }
            }
            
            // excerpt code for the replacement class:
            public class TestLogger
            {
                public void Write(string toWrite)
                {
                    Console.WriteLine("RealLogger.Write() was called with {0}", toWrite);
                }
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IFaker">
      <summary>
            Interface for specifying fake object creation settings. The interface is typed by the preceeding <see cref="P:TypeMock.ArrangeActAssert.Isolate.Fake" /> property.
            </summary>
      <remarks>
            This interface is returned by the <see cref="P:TypeMock.ArrangeActAssert.Isolate.Fake" /> property.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Dependencies``1(System.Object[])">
      <summary>
            Returns a new instance of T with all dependencies faked. 
            </summary>
      <typeparam name="T">The type to which all dependencies will be faked.</typeparam>
      <param name="constructorArguments">List of real arguments to pass to constructor</param>
      <returns>A new instance of type T.</returns>
      <remarks>
            To create an instance, where all the dependencies are fake, use Isolate.Fake.Dependencies.
            When the Type is created the longest constructor of T is called with fakes passed as arguments.
            if a list of constructorArguments is passed, these will be passed in the correct position (matched by type) to the constructor.
            All primitives are initialized to their base value, as well as structs. Strings are passed empty.
            </remarks>
      <example>
            Here is an example how to use Dependencies in order to fake all dependencies of a ClassUnderTest type:
            <code lang="cs">
            [TestMethod]
            [Isolated]
            public void FakeAllDependencies()
            {
                var real = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;();
                real.Log("Test");
                Assert.AreEqual(1, real.Count);
            }
            </code>
            if a list of constructorArguments is passed, these will be passed in the correct position (matched by type) to the constructor.
            Example, To fake all arguments of but use a real instance of MyType1
            <code lang="cs">
            public ClassUnderTest(int arg1, MyType1 arg2, MyInterface2 arg3)
            </code>
            Use
            <code lang="cs">
                var arg2 = new MyType1();
                var underTest = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;(arg2);
            </code>
            To modify a fake before the constructor is called, do the following
            <code lang="cs">
                var fake = Isolate.Fake&lt;MyType1&gt;();
                Isolate.WhenCalled(()=&gt;fake.CrashTheSystem()).IgnoreCall();
                var underTest = Isolate.Fake.Dependencies&lt;ClassUnderTest&gt;(fake);
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.GetFake``1(System.Object)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1">
      <summary>
             Overloaded. Returns a fake instance of type T. Using this overload is equal to using <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes">Members.ReturnRecursiveFakes</see>.
             </summary>
      <typeparam name="T">The type of fake object to create.</typeparam>
      <returns>A fake instance of type T.</returns>
      <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
             Here is an example how to use Instance in order to fake a RealLogger instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 fake.Count = 0;
             
                 // This call is faked because we used the default Instance overload - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)">
      <summary>
             Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created.
             </summary>
      <remarks>
      </remarks>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="T:TypeMock.TypeMockException" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.MustSpecifyReturnValues);
                 
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                 fake.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls);
                 
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
      <summary>
             Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created and the behavior of the constructor.
             </summary>
      <remarks>
      </remarks>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="constructorBehavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="T:TypeMock.TypeMockException" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.MustSpecifyReturnValues, ConstructorWillBe.Ignored);
                 
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal, ConstructorWillBe.Ignored);
                 
                 // Because constructor was not called Count was not initialized
                 Assert.AreEqual(0, fake.Count);
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls, ConstructorWillBe.Ignored);
                 
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 // We create a fake after running the real constructor that sets count field to 5
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, ConstructorWillBe.Called);
            
                 // Because Constructor was called fake.count field was initialized
                 Assert.AreEqual(5, fake.count);
             
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,System.Object[])">
      <summary>
             Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created and the behavior of the constructor.
             </summary>
      <remarks>
      </remarks>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="constructorBehavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="constructorArguments">
             The parameters to pass to a specific constructor. 
             If constructor behavior is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored" /> and this value isn't empty a <see cref="T:TypeMock.TypeMockException" /> will be thrown
             </param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="T:TypeMock.TypeMockException" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.MustSpecifyReturnValues, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count);
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal, ConstructorWillBe.Called, 10);
              
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count);   
             
                 // Because constructor was not called Count was not initialized
                 Assert.AreEqual(0, fake.Count);
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count); 
             
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count); 
             
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe)">
      <summary>
            Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <remarks>
      </remarks>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <returns>A fake instance of Type T.</returns>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object (or other mscorlib types)
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <seealso cref="T:TypeMock.TypeMockException" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Object[])">
      <summary>
            Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <remarks>
      </remarks>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <param name="constructorArguments">        
            The parameters to pass to a specific constructor. 
            </param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if <paramref name="constructorBehavior" /> is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored" /> and parameter arguments are passed in <paramref name="constructorArguments" /></exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments" /></exception>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type)">
      <summary>
            Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <typeparam name="T">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </typeparam>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>
            All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> 
            on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <param name="baseTypeToIgnoreConstructor">
            The type of the base class who's constructor will be ignored.
            </param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor" /></exception>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored,
                                                                   typeof(AbstractLoggerBase));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type,System.Object[])">
      <summary>
            Overloaded. Returns a fake instance of type T, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <typeparam name="T">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </typeparam>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>
            All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> 
            on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <param name="baseTypeToIgnoreConstructor">
            The type of the base class who's constructor will be ignored.
            </param>
      <param name="constructorArguments">        
            The parameters to pass to a specific constructor. 
            </param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor" /></exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments" /></exception>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored,
                                                                   typeof(AbstractLoggerBase));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1">
      <summary>
             Overloaded. Fake future calls to static constructors of the given type.
            </summary>
      <typeparam name="T">The type for which to fake static constructor calls</typeparam>
      <exception cref="T:TypeMock.TypeMockException">
                 Thown if the static constructor for the provided type has already been called, if an 
                 instance fake of the type has already been created or if FakeStaticConstructors has already
                 been called for it.
             </exception>
      <remarks>
                 This overload for FakeStaticConstructor receives a generic parameter. Because static classes cannot be instantiated, they
                 also cannot be used as generic type parameters. In order to fake the static constructors for a static class, use the non
                 generic overload which receives a Type parameter.
             </remarks>
      <example>
             This example shows using Isolate.Fake.StaticConstructor() to fake a call to a static constructor
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticConstructor_CCtorNotCalled()
             {
                 Isolate.Fake.StaticConstructor&lt;TestClass&gt;()
             
                 TestClass.DoSomething(); // this causes the static constructor to be called
             
                 // the call to the static constructor was faked so the flag equals false   
                 Assert.IsFalse(TestClass.TrueIfCCtorHappened); 
             }
             </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor(System.Type)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor(System.Type)">
      <summary>
             Overloaded. Fake future calls to static constructors of the given type.
            </summary>
      <param name="type">The type for which to fake static constructor calls</param>
      <exception cref="T:TypeMock.TypeMockException">
                 Thrown if the static constructor for the provided type has already been called, if an 
                 instance fake of the type has already been created or if FakeStaticConstructors has already
                 been called for it.
             </exception>
      <remarks>
                 This overload for FakeStaticConstructor receives a Type parameter which represents the class to fake static constructors for,
                 and should be used when faking constructors for static classes. For other non-static classes it is generally recommended to use the 
                 generic overload <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />, which receives the class as a generic type argument.
             </remarks>
      <example>
             This example shows using Isolate.Fake.StaticConstructor() to fake a call to a static constructor
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticConstructor_CCtorNotCalled()
             {
                 Isolate.Fake.StaticConstructor( typeof(StaticTestClass))
             
                 StaticTestClass.DoSomething(); // this causes the static constructor to be called
             
                 // the call to the static constructor was faked so the flag equals false   
                 Assert.IsFalse(StaticTestClass.TrueIfCCtorHappened); 
             }
             </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticConstructor``1" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1">
      <summary>
            Overloaded. Fakes all static methods for type T. Using this overload is equal to using <c>Members.MustSpecifyReturnValues</c>.
            </summary>
      <typeparam name="T">The type to fake static methods for.</typeparam>
      <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
      <remarks>
            Static class cannot be used as type argument.
            Use IFaker.StaticMethods(Type type) or IFaker.StaticMethods(Type type, Members behavior) instead.
            </remarks>
      <example>
            This example shows using FakeStaticMethods to stub all static void calls for a class
            <code lang="cs">
            [TestMethod]
            [Isolated]
            public void FakeStaticMethods_StubIncrementMethod()
            {
                Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
            
                LoggerFactory.Count = 0;
                // This call is faked because we used the default overload for FakeStaticMethods - 
                // IncrementCount() is not really performed
                LoggerFactory.IncrementCount();
            
                Assert.AreEqual(0, LoggerFactory.Count);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods(System.Type)">
      <summary>
            Overloaded. Fakes all static methods for the provided type. Using this overload is equal to using <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes"></see>.
            </summary>
      <param name="type">The type to fake static methods for.</param>
      <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
      <remarks>
                This overload receives a Type parameter representing the class to fake static methods for, and should be used 
                when faking methods for static classes. For other non-static classes it is generally recommended to use the 
                generic overload <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1" />, which receives the class as a generic type argument.
            </remarks>
      <example>
            This example shows using FakeStaticMethods to stub all static void calls for a class
            <code lang="cs">
            [TestMethod]
            [Isolated]
            public void FakeStaticMethods_StubIncrementMethod()
            {
                Isolate.Fake.StaticMethods( typeof(LoggerFactory));
            
                LoggerFactory.Count = 0;
                // This call is faked because we used the default overload for FakeStaticMethods - 
                // IncrementCount() is not really performed
                LoggerFactory.IncrementCount();
            
                Assert.AreEqual(0, LoggerFactory.Count);
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)">
      <summary>
             Overloaded. Fakes all static methods for type <typeparamref name="T" />, and allows to set the behavior of how the methods is being faked.
             </summary>
      <typeparam name="T">The type to fake static methods for.</typeparam>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>Default. All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <returns>A fake instance of Type T.</returns>
      <remarks>
             Static class cannot be used as type argument.
             Use IFaker.StaticMethods(Type type) or IFaker.StaticMethods(Type type, Members behavior) instead.
             </remarks>
      <seealso cref="T:TypeMock.TypeMockException" />
      <seealso cref="T:TypeMock.ArrangeActAssert.Members" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)" />
      <example>
             The following test shows the default behavior of FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseDefault()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
             
                 LoggerFactory.Count = 0;
                 // This call is faked because we used the default overload for FakeStaticMethods - 
                 // IncrementCount() is not really performed
                 LoggerFactory.IncrementCount();
             
                 Assert.AreEqual(0, LoggerFactory.Count);
             
                 // The following statement will throw, because we didn't set behavior on GetCount() method.
                 int x = LoggerFactory.GetCount();
             }
             </code>
             The next test shows the CallOriginal setting for FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseCallOriginal()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;(Members.CallOriginal);
                 
                 LoggerFactory.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 LoggerFactory.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseReturnNulls()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;(Members.ReturnNulls);
                 
                 LoggerFactory.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 LoggerFactory.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(LoggerFactory.GetLogger());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code lang="cs">
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;(Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, LoggerFactory.GetLoggerCount());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(LoggerFactory.GetLogger());
             
                 // And the result of GetLogger also returns a non-null object 
                 Assert.IsNotNull(LoggerFactory.GetLogger().GetWriter());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods(System.Type,TypeMock.ArrangeActAssert.Members)">
      <summary>
             Overloaded. Fakes all static methods for the given type, and allows to set the behavior of how the fake object is created.
             </summary>
      <param name="type">The type to fake static methods for.</param>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>Default. All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
      <seealso cref="T:TypeMock.TypeMockException" />
      <seealso cref="T:TypeMock.ArrangeActAssert.Members" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)" />
      <remarks>
                 This overload receives a Type parameter representing the class to fake static methods for, and should be used 
                 when faking methods for static classes. For other non-static classes it is generally recommended to use the 
                 generic overload <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />, which receives the class as a generic type argument.
             </remarks>
      <example>
             The following test shows the default behavior of FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseDefault()
             {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory));
             
                 LoggerFactory.Count = 0;
                 // This call is faked because we used the default overload for FakeStaticMethods - 
                 // IncrementCount() is not really performed
                 LoggerFactory.IncrementCount();
             
                 Assert.AreEqual(0, LoggerFactory.Count);
             
                 // The following statement will throw, because we didn't set behavior on GetCount() method.
                 int x = LoggerFactory.GetCount();
             }
             </code>
             The next test shows the CallOriginal setting for FakeStaticMethods():
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseCallOriginal()
             {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory), Members.CallOriginal);
                 
                 LoggerFactory.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 LoggerFactory.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code lang="cs">
             [TestMethod]
             [Isolated]
             public void FakeStaticMethods_UseReturnNulls()
             {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory), Members.ReturnNulls);
                 
                 LoggerFactory.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 LoggerFactory.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(LoggerFactory.GetLogger());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code lang="cs">
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 Isolate.Fake.StaticMethods(typeof (LoggerFactory), Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, LoggerFactory.GetLoggerCount());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(LoggerFactory.GetLogger());
             
                 // And the result of GetLogger also returns a non-null object 
                 Assert.IsNotNull(LoggerFactory.GetLogger().GetWriter());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1">
      <summary>
             Overloaded. Fake a future instance of type T.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.NextInstance&lt;RealLogger&gt;();
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code></example>
      <note>
             The constructor of the next instance will be ignored.
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(TypeMock.ArrangeActAssert.Members)">
      <summary>
            Overloaded. Fake a future instance of type T, and allows to set the behavior of how the fake future object will be created.
            </summary>
      <returns>An object of type T which is used as a mocking handle.</returns>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
      <summary>
            Overloaded. Fake a future instance of type T, and allows to set the behavior of how the fake future object will be created and the behavior of the constructor.
            </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(TypeMock.ArrangeActAssert.Members,System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fakes the next instance of type T, and allows to set the behavior of how the fake future object will be and allows to add code to run before the constructor.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.NextInstance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1(System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fakes the next instance of type T, and allows to add code to run before the constructor.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.NextInstance&lt;RealLogger&gt;(context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1">
      <summary>
             Overloaded. Fakes all instances of type T.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.AllInstances&lt;RealLogger&gt;();
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code></example>
      <note>
             The constructor will be ignored.
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(TypeMock.ArrangeActAssert.Members)">
      <summary>
            Overloaded. Fakes all instances of type T, and allows to set the behavior of how the fake object is created.
            </summary>
      <returns>An object of type T which is used as a mocking handle.</returns>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
      <summary>
            Overloaded. Fakes all instances of type T, and allows to set the behavior of how the fake object is created and the behavior of the constructor.
            </summary>
      <returns>An object of type T which is used as a mocking handle.</returns>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(TypeMock.ArrangeActAssert.Members,System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fakes all instances of type T, and allows to add code to run before the constructor.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAllInstances_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.AllInstances&lt;RealLogger&gt;(context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1(System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fakes all instances of type T, and allows to add code to run before the constructor.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <typeparam name="T">The type of the fake instance to be created.</typeparam>
      <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAllInstances_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.Fake.AllInstances&lt;RealLogger&gt;(context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic">
      <summary>
            Returned by <seealso cref="P:TypeMock.ArrangeActAssert.Isolate.NonPublic" />, this interface contains methods for faking and setting 
            behavior for method calls on non public methods, properties and indexers.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String)">
      <summary>
             Sets behavior for a specific method on a an object
             </summary>
      <param name="targetObject">The object to set method behavior on.</param>
      <param name="methodName">The name of a method to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /></remarks>
      <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateMethod_DoNotWriteToDisk()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger));
                 
                 // Avoid performing actual write to disk by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled(fake, "WriteToDisk").IgnoreCall();
             
                 // The private call is stubbed so no actual disk writes are performed
                 fake.Log("Hello World");
            
                 Assert.AreEqual(1, fake.LineCount);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])">
      <summary>
             Sets behavior for a specific method on a an object
             </summary>
      <param name="targetObject">The object to set method behavior on.</param>
      <param name="methodName">The name of a method to set behavior on.</param>
      <param name="outParameter">Parameters for validating that the method was called with exact arguments.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /></remarks>
      <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
                   [TestMethod, Isolated]
             public void VerifyPrivateStaticMethodWithRef_Return()
             {
                 int fakeParam = 3;
                 Isolate.NonPublic.WhenCalled&lt;Dependency&gt;("PrivateMethodOutParam").AssignRefOut(fakeParam).IgnoreCall();
            
                 var result = Dependency.CallPrivateMethodOutParam();
            
                 Isolate.Verify.NonPublic.WasCalled(typeof(Dependency), "PrivateMethodOutParam");
                 Assert.AreEqual(3, result);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Type,System.String)">
      <summary>
             Sets behavior for a specific static method on a class
             </summary>
      <param name="type">The type to set method behavior on. Applies to static methods.</param>
      <param name="methodName">The name of a static method to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /></remarks>
      <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateStaticMethod_FactoryCreate()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
                 
                 // Avoid performing to network access by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled(typeof(LoggerFactory), "ReportToControllerServer").IgnoreCall();
             
                 // The private method is stubbed and the unit test will not perform external calls
                 RealLogger logger = LoggerFactory.CreateLogger();
            
                 Assert.IsNotNull(logger);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled``1(System.String)">
      <summary>
             Sets behavior for a specific static method on a class
             </summary>
      <typeparam name="T">The type to set method behavior on. Applies to static methods.</typeparam>
      <param name="methodName">The name of a static method to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /></remarks>
      <example>
             Here is an example how to use WhenCalled in order to ignore (stub) a private call:
             <code>
             [TestMethod]
             [Isolated]
             public void StubPrivateStaticMethod_FactoryCreate()
             {
                 Isolate.Fake.StaticMethods&lt;LoggerFactory&gt;();
                 
                 // Avoid performing to network access by ignoring (stubbing) a private call
                 Isolate.NonPublic.WhenCalled&lt;LoggerFactory&gt;("ReportToControllerServer").IgnoreCall();
             
                 // The private method is stubbed and the unit test will not perform external calls
                 RealLogger logger = LoggerFactory.CreateLogger();
            
                 Assert.IsNotNull(logger);
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalledLocal(System.Object,System.String,System.String)">
      <summary>
            Sets behavior for a specific local function on an object
            </summary>
      <param name="targetObject">The object to set method behavior on.</param>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The name of the local function to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>WhenCalledLocal</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /></remarks>
      <example>
            Here is an example how to use WhenCalledLocal in order to change the return value:
            <code>
            [TestMethod]
            [Isolated]
            public void ChangeLocalFunctionReturnValue()
            {
               var fake = Isolate.Fake.Instance&lt;classWithLocal&gt;(Members.CallOriginal);
               
                // Changing the local function behaviour by setting it return 5.
               Isolate.NonPublic.WhenCalledLocal(fake, "UseLocalFunc", "GetLocal").WillReturn(5);
               var result = fake.UseLocalFunc();
               
               Assert.AreEqual(5, result);
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalledLocal``1(System.String,System.String)">
      <summary>
            Sets behavior for a specific static local function on a static method.
            </summary>
      <typeparam name="T">The type to set method behavior on. Applies to static methods.</typeparam>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The name of the local function to set behavior on it.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>WhenCalledLocal</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" /></remarks>
      <example>
            Here is an example how to use WhenCalledLocal in order to change the return value:
            <code>
            [TestMethod]
            [Isolated]
            public void ChangeLocalFunctionReturnValue()
            {
               // Changing the local function behaviour by setting it return 5.
               Isolate.NonPublic.WhenCalledLocal&lt;PrivateStaticLocalFunction&gt;("UseLocalFunc", "GetLocal").WillReturn(5);
               
               var call = Isolate.Invoke.Method&lt;PrivateStaticLocalFunction&gt;("UseLocalFunc");
               
               Assert.AreEqual(5, call);
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.CreateInstance``1(System.Object[])">
      <summary>
            Creates a live instance of a class that does not have a public constructor
            </summary>
      <typeparam name="T">The type of the instance to create</typeparam>
      <param name="parameters">The argument list to pass to the matching constructor</param>
      <returns>A live instance of type T</returns>
      <remarks>
            A factory method, used to create a real live instance of a type that doesn't expose a public constructor. The types of the arguments 
            in the argument list determines which non-public constructor will be called.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.CreateInstance(System.Type,System.Object[])">
      <summary>
            Creates a live instance of a class
            </summary>
      <param name="type">The type of the instance to create</param>
      <param name="parameters">The argument list to pass to the matching constructor</param>
      <returns>A live instance of type</returns>
      <remarks>
            A factory method, used to create a real live instance of a type, types of the arguments 
            in the argument list determines which constructor will be called.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.StaticField``1(System.String)">
      <summary>
            Set/Get/Fake a non public static field
            </summary>
      <typeparam name="T">The class that contains the static field</typeparam>
      <param name="fieldName">The name of the static field</param>
      <returns>
            A <see cref="T:TypeMock.ArrangeActAssert.NonPublicField" /> reference
            </returns>
      <remarks>
            Use this to test and fake non accessable fields.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.StaticField in order to set the field with a fake:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateField_WithRecursiveFake()
            {
                var fake = Isolate.NonPublic.StaticField&lt;MyClass&gt;("m_field").SetRecursiveFake&lt;TypeOfField&gt;();
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                Isolate.WhenCalled(() =&gt; fake.Foo()).WillReturn(1);
                // continue with test
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.StaticField(System.Type,System.String)">
      <summary>
            Set/Get/Fake a non public static field
            </summary>
      <param name="type">The type that contains the static field</param>
      <param name="fieldName">The name of the static field</param>
      <returns>
            A <see cref="T:TypeMock.ArrangeActAssert.NonPublicField" /> reference
            </returns>
      <remarks>
            Use this to test and fake non accessable fields.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.StaticField in order to set the field with a fake:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateField_WithRecursiveFake()
            {
                var fake = Isolate.NonPublic.StaticField(typeof(MyClass),"m_field").SetRecursiveFake&lt;TypeOfField&gt;();
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                Isolate.WhenCalled(() =&gt; fake.Foo()).WillReturn(1);
                // continue with test
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.InstanceField(System.Object,System.String)">
      <summary>
            Set/Get/Fake a non public instance field
            </summary>
      <param name="instance">The actual instance that contains the field, of a handle to a future fake</param>
      <param name="fieldName">The name of the static field</param>
      <returns>
            A <see cref="T:TypeMock.ArrangeActAssert.NonPublicInstanceField" /> reference
            </returns>
      <remarks>
            Use this to test and fake non accessable fields.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.InstanceField in order to set the field with a fake:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateField_WithRecursiveFake()
            {
                var instance = new MyClass();
                var fake = Isolate.NonPublic.InstanceField(instance,"m_field").SetRecursiveFake&lt;TypeOfField&gt;();
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                Isolate.WhenCalled(() =&gt; fake.Foo()).WillReturn(1);
                // continue with test
            }
            </code></example>
      <example>
            This example shows how to use Isolate.NonPublic.InstanceField in order to set the field of a future fake:
            <code>
            public class UnderTest
            {
               MyClass myClass;
               public void ThisWillCreateANewMyClass()
               {
                  myClass = new MyClass();
               }
            }
            [TestMethod]
            [Isolated]
            public void SetPrivateField_InFutureFake()
            {
                var handle =Isolate.Fake.NextInstance&lt;MyClass&gt;();
                underTest.ThisWillCreateANewMyClass();
                Isolate.NonPublic.InstanceField(handle,"m_field").Value = 8;
                // myClass.m_field is now 8
            }
            </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Property">
      <summary>
            A read only property, used to set behavior on non-public properties
            </summary>
      <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder" /> reference
            </returns>
      <remarks>
            Because of the nature of fluent interface, you need to use Property with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder" />.
            <para>
            When handling non public (private, protected, internal) properties all access to property names is string-based.
            </para></remarks>
      <example>
            This example shows how to use Isolate.NonPublic.Property in order to set behavior on a private property getter:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivatePropertyBehavior_ChangeReturnValue()
            {
                RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.CallOriginal);
                
                // have private RealLogger.IsDiskFull property return true to simulate an error
                Isolate.NonPublic.Property.WhenCalledGet(fake, "IsDiskFull").WillReturn(true);
            
                // Because we simulated a disk full error, this call should throw an exception
                try
                {
                    fake.Log("Hello World");
                    Assert.Fail("fake.Log() should have thrown because IsDiskFull is true");
                }
                catch(OutOfDiskSpaceException)
                {
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder" />
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Indexer">
      <summary>
            A read only property, used to set behavior on non-public indexers
            </summary>
      <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder" /> reference
            </returns>
      <remarks>
            Because of the nature of fluent interface, you need to use Indexer with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder" />.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.Indexer in order to set behavior on a private index getter:
            <code>
            [TestMethod]
            [Isolated]
            public void SetPrivateIndexBehavior_ChangeReturnValue()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                // have private LogFile[i] index return a specified log line
                Isolate.NonPublic.Indexer.WhenCalledGet(fake).WillReturn("Info: this is a test log line");
            
                // We set the value of the next log line the internal implementation will look at
                Assert.AreEqual("this is a test log line", fake.GetNextLogLine(Level.Info));
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder" />
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Fake">
      <summary>
            A read only property, used to create fakes of non-public types
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder">
      <summary>
            Returned by Isolate.NonPublic.<seealso cref="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Indexer" />, this interface contains methods for faking and setting 
            behavior for non-public (private, protected and internal) index get and set calls
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenGetCalled(System.Object)">
      <summary>
             Sets specific behavior for a non-public index getter on a an object
             </summary>
      <param name="fake">The object to set indexer behavior for.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenGetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenGetCalled() in order to set return value for an index call:
             <code>
             [TestMethod]
             [Isolated]
             public void ChangeIndexGetReturnValue()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to return a specific value
                 Isolate.NonPublic.Indexer.WhenGetCalled(fake).WillReturn("hello");
             
                 // The object under test uses the private index get result as part of a calculation
                 string result = fake.GetStringAt(10);
                 Assert.AreEqual("hello", result);
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string GetStringAt(int line)
                 {
                     return this[line];
                 }
            
                 private string fileName = ...
             
                 // private indexer
                 private string this[int line]
                 {
                     get { return ReadFromFile(fileName, line); }
                 }
             
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenGetCalled(System.Object,System.Object)">
      <summary>
             Sets specific behavior for a non-public index getter on a an object
             </summary>
      <param name="fake">The object to set indexer behavior for.</param>
      <param name="index">The index to set indexer behavior for.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenGetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenGetCalled() in order to set return value for an index call:
             <code>
             [TestMethod]
             [Isolated]
             public void ChangeIndexGetReturnValue()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to return a specific value
                 Isolate.NonPublic.Indexer.WhenGetCalled(fake).WillReturn("hello");
             
                 // The object under test uses the private index get result as part of a calculation
                 string result = fake.GetStringAt(10);
                 Assert.AreEqual("hello", result);
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string GetStringAt(int line)
                 {
                     return this[line];
                 }
            
                 private string fileName = ...
             
                 // private indexer
                 private string this[int line]
                 {
                     get { return ReadFromFile(fileName, line); }
                 }
             
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenSetCalled(System.Object)">
      <summary>
             Sets specific behavior for a non-public index set on a an object
             </summary>
      <param name="fake">The object to set indexer behavior for.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenSetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />.</remarks>
      <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenSetCalled() in order to simulate a memory error on index write access:
             <code>
             [TestMethod]
             [Isolated]
             [ExpectedException(typeof(OutOfMemoryException))
             public void ThrowExceptionFromIndexSet_SimulateMemoryError()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to throw an exception on set
                 Isolate.NonPublic.Indexer.WhenSetCalled(fake).WillThrow(new OutOfMemoryException());
             
                 // The object under test uses the private index setter when writing to log
                 fake.WriteToLog("hello");
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string WriteToLog(string message)
                 {
                     this[currentLine] = message;
                     currentLine++;
                 }
            
                 private string fileName = ...
                 private int currentLine = 0;
             
                 // private indexer
                 private string this[int line]
                 {
                     set { InternalWrite(fileName, line, value); }
                 }
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenSetCalled(System.Object,System.Object)">
      <summary>
             Sets specific behavior for a non-public index set with specific value on a an object
             </summary>
      <param name="fake">The object to set indexer behavior for.</param>
      <param name="index">The index to set indexer behavior for.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenSetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />.</remarks>
      <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenSetCalled() in order to simulate a memory error on index write access:
             <code>
             [TestMethod]
             [Isolated]
             [ExpectedException(typeof(OutOfMemoryException))
             public void ThrowExceptionFromIndexSet_SimulateMemoryError()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to throw an exception on set
                 Isolate.NonPublic.Indexer.WhenSetCalled(fake).WillThrow(new OutOfMemoryException());
             
                 // The object under test uses the private index setter when writing to log
                 fake.WriteToLog("hello");
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string WriteToLog(string message)
                 {
                     this[currentLine] = message;
                     currentLine++;
                 }
            
                 private string fileName = ...
                 private int currentLine = 0;
             
                 // private indexer
                 private string this[int line]
                 {
                     set { InternalWrite(fileName, line, value); }
                 }
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicIndexerRecorder.WhenSetCalled(System.Object,System.Object,System.Object)">
      <summary>
             Sets specific behavior for a non-public index set with specific value on a an object
             </summary>
      <param name="fake">The object to set indexer behavior for.</param>
      <param name="index">The index to set indexer behavior for.</param>
      <param name="value">The value to set indexer behavior for.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" /> interface reference.</returns>
      <remarks>
             Because of the nature of fluent interface, <c>WhenSetCalled</c> should be used with its proceeding methods. 
             See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />.</remarks>
      <example>
             Here is an example how to use Isolate.NonPublic.Indexer.WhenSetCalled() in order to simulate a memory error on index write access:
             <code>
             [TestMethod]
             [Isolated]
             [ExpectedException(typeof(OutOfMemoryException))
             public void ThrowExceptionFromIndexSet_SimulateMemoryError()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;LogContainer&gt;();
                 
                 // Set the internal indexer to throw an exception on set
                 Isolate.NonPublic.Indexer.WhenSetCalled(fake).WillThrow(new OutOfMemoryException());
             
                 // The object under test uses the private index setter when writing to log
                 fake.WriteToLog("hello");
             }
             
             // Excerpt from class under test
             public class LogContainer
             {
                 // method under test
                 public string WriteToLog(string message)
                 {
                     this[currentLine] = message;
                     currentLine++;
                 }
            
                 private string fileName = ...
                 private int currentLine = 0;
             
                 // private indexer
                 private string this[int line]
                 {
                     set { InternalWrite(fileName, line, value); }
                 }
             }
             </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder">
      <summary>
            Returned by Isolate.NonPublic.<seealso cref="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Property" />, this interface contains methods for faking and setting 
            behavior for non-public (private, protected and internal) property get and set calls
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenGetCalled(System.Object,System.String)">
      <summary>
            Sets specific behavior for a non-public property getter on an object
            </summary>
      <param name="fake">The object to set property behavior for.</param>
      <param name="propertyName">The name of a property to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>Property.WhenGetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
            Here is an example how to use Property.WhenGetCalled in order to set return value on a private property:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedExcetion(typeof(OutOfDiskSpaceException))]
            public void ChangePrivatePropertyReturnValue_SimulateDiskError()
            {
                RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger));
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenGetCalled(fake, "IsDiskFull").WillReturn(true);
            
                // The fake object checks the disk is full before logging and throws an exception
                fake.Log("Hello World");
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    AppendToFile(fileName, message);
                }
            
                private bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenGetCalled(System.Type,System.String)">
      <summary>
            Sets specific behavior for a non-public static property getter for a class type
            </summary>
      <param name="type">The type to set static property getter behavior on. Applies to static methods.</param>
      <param name="propertyName">The name of a property to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>Property.WhenGetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
            Here is an example how to use Property.WhenGetCalled in order to set return value on a private property:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfDiskSpaceException))]
            public void ChangePrivatePropertyReturnValue_SimulateDiskError()
            {
                Isolate.Fake.StaticMethods(typeof(RealLogger), );
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenGetCalled(typeof(RealLogger), "IsDiskFull").WillReturn(true);
            
                RealLogger logger = new RealLogger();
                
                // The logger object calls the static property to find out if the disk is full before logging and throws an exception
                logger.Log("Hello World");
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public static override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    AppendToFile(fileName, message);
                }
            
                private static bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenSetCalled(System.Object,System.String)">
      <summary>
            Sets specific behavior for a non-public property setter on an object
            </summary>
      <param name="fake">The object to set property behavior for.</param>
      <param name="propertyName">The name of a property to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>Property.WhenSetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
            Here is an example how to use Property.WhenSetCalled in order to simulate an error by throwing an exception
            on an internal property setter call:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfDiskSpaceException))]
            public void ThrowExceptionFromPrivatePropertySetter_SimulateDiskError()
            {
                RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger));
                
                // Set the behavior of the internal CurrentLine property to throw an exception when set
                Isolate.NonPublic.Property.WhenSetCalled(fake, "CurrentLine").WillThrow(new OutOfDiskSpaceException());
            
                // The object under test tries to log to its internal container and fails because of the exception we set
                fake.Log("Hello World");
            }
            
            // Excerpt from classes under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public static override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    CurrentLine = message;
                }
            
                private static bool IsDiskFull
                {
                    get { return ...; }
                }
            
                internal string CurrentLine
                {
                    get { return current; }
                    set { WriteToLogFile(value); current = value; }
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenSetCalled(System.Type,System.String)">
      <summary>
            Sets specific behavior for a non-public static property setter for a class 
            </summary>
      <param name="type">The type to set static property setter behavior on. Applies to static methods.</param>
      <param name="propertyName">The name of a property to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>Property.WhenSetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
            Here is an example how to use Property.WhenSetCalled in order to simulate an error by throwing an exception
            on an internal property setter call:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfMemoryException))]
            public void ThrowExceptionFromPrivatePropertySetter_SimulateMemoryFull()
            {
                Isolate.Fake.Instance&lt;LogContainer&gt;();
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenSetCalled(typeof(LogContainer), "Cache").WillThrow(new OutOfMemoryException());
            
                // The object under test tries to log using the LogContainer.Cache internal container and fails because of the exception we set
                fake.Log("Hello World");
            }
            
            // Excerpt from class under test:
            public class LogContainer
            {
                public void Log(string message)
                {
                    LogContainer.Cache.Add(message);
                    WriteToDisk(message);
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenSetCalled(System.Object,System.String,System.Object)">
      <summary>
            Sets specific behavior for a non-public property setter on an object
            </summary>
      <param name="fake">The object to set property behavior for.</param>
      <param name="value">The value set to property to set behavior on.</param>
      <param name="propertyName">The name of a property to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>Property.WhenSetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
            Here is an example how to use Property.WhenSetCalled in order to simulate an error by throwing an exception
            on an internal property setter call:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfDiskSpaceException))]
            public void ThrowExceptionFromPrivatePropertySetter_SimulateDiskError()
            {
                RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger));
                
                // Set the behavior of the internal CurrentLine property to throw an exception when set
                Isolate.NonPublic.Property.WhenSetCalled(fake, "CurrentLine", "Hello World").WillThrow(new OutOfDiskSpaceException());
            
                // The object under test tries to log to its internal container and fails because of the exception we set
                fake.Log("Hello World");
            }
            
            // Excerpt from classes under test
            public class RealLogger : ILogger
            {
                private string fileName;
                // method under test
                public static override void Log(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
                    
                    CurrentLine = message;
                }
            
                private static bool IsDiskFull
                {
                    get { return ...; }
                }
            
                internal string CurrentLine
                {
                    get { return current; }
                    set { WriteToLogFile(value); current = value; }
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyRecorder.WhenSetCalled(System.Type,System.String,System.Object)">
      <summary>
            Sets specific behavior for a non-public static property setter for a class 
            </summary>
      <param name="type">The type to set static property setter behavior on. Applies to static methods.</param>
      <param name="propertyName">The name of a property to set behavior on.</param>
      <param name="value">The value set to property to set behavior on.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" /> interface reference.</returns>
      <remarks>
            Because of the nature of fluent interface, <c>Property.WhenSetCalled</c> should be used with its proceeding methods. 
            See <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.</remarks>
      <example>
            Here is an example how to use Property.WhenSetCalled in order to simulate an error by throwing an exception
            on an internal property setter call:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfMemoryException))]
            public void ThrowExceptionFromPrivatePropertySetter_SimulateMemoryFull()
            {
                Isolate.Fake.Instance&lt;LogContainer&gt;();
                
                // Set the behavior on the internal IsDiskFull property to true
                Isolate.NonPublic.Property.WhenSetCalled(typeof(LogContainer), "Cache", "Hello World").WillThrow(new OutOfMemoryException());
            
                // The object under test tries to log using the LogContainer.Cache internal container and fails because of the exception we set
                fake.Log("Hello World");
            }
            
            // Excerpt from class under test:
            public class LogContainer
            {
                public void Log(string message)
                {
                    LogContainer.Cache.Add(message);
                    WriteToDisk(message);
                }
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" />
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.StaticMethods``1(TypeMock.ArrangeActAssert.Members)" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker">
      <summary>
            Returned by Isolate.NonPublic.<seealso cref="P:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.Fake" />, this interface contains methods for faking and setting 
            behavior for non-public (private, protected and internal) property get and set calls
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type)">
      <summary>
             Overloaded. Returns a fake instance of type. Using this overload is equal to using <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes">Members.ReturnRecursiveFakes</see>.
             </summary>
      <param name="type">
             The type of the fake instance to be created. T can only be a reference type - 
             to fake structs use an overload that does not define base constructor behavior
             </param>
      <returns>A fake instance of type T.</returns>
      <seealso cref="T:TypeMock.ArrangeActAssert.Members">Members Enum</seealso>
      <example>
             Here is an example how to use Instance in order to fake a RealLogger instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger));
                 
                 fake.Count = 0;
             
                 // This call is faked because we used the default Instance overload - count should not increment
                 fake.Increment();
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members)">
      <summary>
             Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created.
             </summary>
      <param name="type">
             The type of the fake instance to be created. T can only be a reference type - 
             to fake structs use an overload that does not define base constructor behavior
             </param>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="T:TypeMock.TypeMockException" />
      <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.MustSpecifyReturnValues);
                 
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.CallOriginal);
                 
                 fake.Count = 0;
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnNulls);
                 
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes);
            
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
      <summary>
             Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created and the behavior of the constructor.
             </summary>
      <param name="type">
             The type of the fake instance to be created. T can only be a reference type - 
             to fake structs use an overload that does not define base constructor behavior
             </param>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="constructorBehavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="T:TypeMock.TypeMockException" />
      <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.MustSpecifyReturnValues, ConstructorWillBe.Ignored);
                 
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.CallOriginal, ConstructorWillBe.Ignored);
                 
                 // Because constructor was not called Count was not initialized
                 Assert.AreEqual(0, fake.Count);
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnNulls, ConstructorWillBe.Ignored);
                 
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 // We create a fake after running the real constructor that sets count field to 5
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes, ConstructorWillBe.Called);
            
                 // Because Constructor was called fake.count field was initialized
                 Assert.AreEqual(5, fake.count);
             
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,System.Object[])">
      <summary>
             Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created and the behavior of the constructor with arguments.
             </summary>
      <param name="type">
             The type of the fake instance to be created. T can only be a reference type - 
             to fake structs use an overload that does not define base constructor behavior
             </param>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="constructorBehavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="constructorArguments">
             The parameters to pass to a specific constructor. 
             If constructor behavior is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored" /> and this value isn't empty a <see cref="T:TypeMock.TypeMockException" /> will be thrown
             </param>
      <returns>A fake instance of Type T.</returns>
      <seealso cref="T:TypeMock.TypeMockException" />
      <example>
             The following test shows the faking an instance using Members.MustSpecifyReturnValue:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_MustSpecifyReturnValues()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.MustSpecifyReturnValues, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count);
                 fake.Count = 0;
             
                 // This call is faked because we used MustSpecifyReturnValues - count should not increment
                 fake.Increment();
                 Assert.AreEqual(0, fake.count);
             
                 // The following statement will throw, because we didn't set behavior on IntCall method.
                 int x = fake.IntCall();
             }
             </code>
             The next test shows the CallOriginal setting on Instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseCallOriginal()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.CallOriginal, ConstructorWillBe.Called, 10);
              
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count);   
             
                 // Because constructor was not called Count was not initialized
                 Assert.AreEqual(0, fake.Count);
             
                 // This call is not faked. Count should be incremented.
                 fake.Increment();
                 Assert.AreEqual(1, fake.Count);
             }
             </code>
             The next test shows what happens when using ReturnNulls:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_UseReturnNulls()
             {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnNulls, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count); 
             
                 fake.Count = 0;
                 // This call is faked because we set faked method behavior using ReturnNulls 
                 fake.Increment();
                 Assert.AreEqual(0, fake.Count);
             
                 // Since we're returning Null by default the following Assert passes
                 Assert.IsNull(fake.IntCall());
             }
             </code>
             Finally, using recursive faking, this test should pass:
             <code>
            [TestMethod]
            [Isolated]
            public void RecursiveStubsChain()
            {
                 // Call class constructor passing a number that will be passed to count field
                 RealLogger fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes, ConstructorWillBe.Called, 10);
                 
                 // Check that the value we've passed to the constructor was passed to the field
                 Assert.AreEqual(10, fake.count); 
             
                 // This method returns a value type, and therefore, returns a fake 0.
                 Assert.AreEqual(0, fake.ReturnFive());
             
                 // This method returns an object, and therefore returns a non-null object
                 Assert.IsNotNull(fake.GetSon());
             
                 // And the result of GetSon also returns a non-null object 
                 Assert.IsNotNull(fake.GetSon().GetNephew());
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe)">
      <summary>
            Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <param name="type">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <returns>A fake instance of Type T.</returns>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object (or other mscorlib types)
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <seealso cref="T:TypeMock.TypeMockException" />
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Object[])">
      <summary>
            Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <param name="type">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <param name="constructorArguments">
            The parameters to pass to a specific constructor. 
            If constructor behavior is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored" /> and this value isn't empty a <see cref="T:TypeMock.TypeMockException" /> will be thrown
            </param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if <paramref name="constructorBehavior" /> is set to <see cref="F:TypeMock.ArrangeActAssert.ConstructorWillBe.Ignored" /> and parameter arguments are passed in <paramref name="constructorArguments" /></exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments" /></exception>
      <returns>A fake instance of Type T.</returns>
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type)">
      <summary>
            Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <param name="type">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>
            All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> 
            on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <param name="baseTypeToIgnoreConstructor">
            The type of the base class who's constructor will be ignored.
            </param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor" /></exception>
      <returns>A fake instance of Type T.</returns>
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored,
                                                                   typeof(AbstractLoggerBase));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.Instance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe,TypeMock.ArrangeActAssert.BaseConstructorWillBe,System.Type,System.Object[])">
      <summary>
            Overloaded. Returns a fake instance of type, and allows to set the behavior of how the fake object is created, the behavior of the constructor and the Base Constructor.
            </summary>
      <param name="type">
            The type of the fake instance to be created. T can only be a reference type - 
            to fake structs use an overload that does not define base constructor behavior
            </param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>
            All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> 
            on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
      <param name="baseConstructorBehavior">
            Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
            when creating the fake object. Applicable only when <paramref name="constructorBehavior" /> is <c>ConstructorWillBe.Called</c></param>
      <param name="baseTypeToIgnoreConstructor">
            The type of the base class who's constructor will be ignored.
            </param>
      <param name="constructorArguments">        
            The parameters to pass to a specific constructor. 
            </param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
            </exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor" /></exception>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments" /></exception>
      <returns>A fake instance of Type T.</returns>
      <example>
            The following test shows faking an instance without calling its base class' constructor
            <code>
            [TestMethod, Isolated]
            public void FakeAnInstance_DoNotCallBaseCtor()
            {
                // create a fake of RealLogger, calling the RealLogger constructor but not its base class c'tor
                var fake = Isolate.NonPublic.Fake.Instance(typeof(RealLogger), Members.ReturnRecursiveFakes, 
                                                                   ConstructorWillBe.Called, 
                                                                   BaseConstructorWillBe.Ignored,
                                                                   typeof(AbstractLoggerBase));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.NextInstance(System.Type)">
      <summary>
             Overloaded. Fake a future instance of type.
             </summary>
      <returns>An object of type type which is used as a faking handle.</returns>
      <param name="type">The type of the fake instance to be created.</param>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.NextInstance(typeof(RealLogger));
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code></example>
      <note>
             The constructor of the next instance will be ignored.
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.NextInstance(System.Type,TypeMock.ArrangeActAssert.Members)">
      <summary>
            Overloaded. Fake a future instance of type.
            </summary>
      <returns>An object of type type which is used as a faking handle.</returns>
      <param name="type">The type of the fake instance to be created.</param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.NextInstance(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
      <summary>
            Overloaded. Fake a future instance of type.
            </summary>
      <returns>An object of type type which is used as a faking handle.</returns>
      <param name="type">The type of the fake instance to be created.</param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.NextInstance(System.Type,TypeMock.ArrangeActAssert.Members,System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fake a future instance of type.
             </summary>
      <returns>An object of type type which is used as a faking handle.</returns>
      <param name="type">The type of the fake instance to be created.</param>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.NonPublic.Fake.NextInstance(typeof(RealLogger), Members.ReturnRecursiveFakes, context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.NextInstance(System.Type,System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fake a future instance of type.
             </summary>
      <returns>An object of type type which is used as a faking handle.</returns>
      <param name="type">The type of the fake instance to be created.</param>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.NonPublic.Fake.NextInstance(typeof(RealLogger), context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.AllInstances(System.Type)">
      <summary>
             Overloaded. Fakes all instances of type.
             </summary>
      <returns>An object of type T which is used as a faking handle.</returns>
      <param name="type">The type of the fake instance to be created.</param>
      <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.NonPublic.Fake.AllInstances(typeof(RealLogger));
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code></example>
      <note>
             The constructor will be ignored.
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.AllInstances(System.Type,TypeMock.ArrangeActAssert.Members)">
      <summary>
            Overloaded. Fakes all instances of type, and allows to set the behavior of how the fake object is created.
            </summary>
      <returns>An object of type which is used as a mocking handle.</returns>
      <param name="type">The type to fake.</param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.AllInstances(System.Type,TypeMock.ArrangeActAssert.Members,TypeMock.ArrangeActAssert.ConstructorWillBe)">
      <summary>
            Overloaded. Fakes all instances of type, and allows to set the behavior of how the fake object is created.
            </summary>
      <returns>An object of type which is used as a mocking handle.</returns>
      <param name="type">The type to fake.</param>
      <param name="behavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
            </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
            </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
            </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
            </description></item></list></param>
      <param name="constructorBehavior">
            Can be one of the following values:
            <list type="table"><listheader><term><c>ConstructorWillBe</c> Value</term><description>Description</description></listheader><item><term><c>ConstructorWillBe.Ignored</c></term><description>Constructor will not be executed when creating the fake object</description></item><item><term><c>ConstructorWillBe.Called</c></term><description>Execute Constructor when creating the fake object</description></item></list></param>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.AllInstances(System.Type,TypeMock.ArrangeActAssert.Members,System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fakes all instances of type, and allows to set the behavior of how the fake object is created.
             </summary>
      <returns>An object of type which is used as a mocking handle.</returns>
      <param name="type">The type to fake.</param>
      <param name="behavior">
             Can be one of the following values:
             <list type="table"><listheader><term><c>Members</c> Value</term><description>Description</description></listheader><item><term><c>Members.MustSpecifyReturnValues</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will throw a <see cref="T:TypeMock.TypeMockException" />.
             </description></item><item><term><c>Members.ReturnNulls</c></term><description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> on methods that return values and properties, they will return null values (or zero for value types).
             </description></item><item><term><c>Members.CallOriginal</c></term><description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> to change this behavior.
             </description></item><item><term><c>Members.ReturnRecursiveFakes</c></term><description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
             </description></item></list></param>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAllInstances_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.NonPublic.Fake.AllInstances(typeof(RealLogger), context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicFaker.AllInstances(System.Type,System.Action{TypeMock.MethodCallContext})">
      <summary>
             Overloaded. Fakes all instances of type, and allows to set the behavior of how the fake object is created.
             </summary>
      <returns>An object of type which is used as a mocking handle.</returns>
      <param name="type">The type to fake.</param>
      <param name="doInstead">The action to run at the start of the constructor.</param>
      <example>
             This example shows using AllInstances in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAllInstances_StubIncrementMethod()
             {
                 bool flag = false;
             
                 RealLogger fake = Isolate.NonPublic.Fake.AllInstances(typeof(RealLogger), context =&gt; flag = true);
            
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 Assert.IsTrue(flag);
             }
             </code></example>
      <note>
             The constructor will be ignored, unless using context.WillCallOriginal().
             </note>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler">
      <summary>
            Returned by Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />, this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.OnBase(System.Type)">
      <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
      <remarks>
        <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
        <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
      </remarks>
      <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // ignore only base method
                Isolate.NonPublic.WhenCalled(fake,"VirtualMethod").OnBase(typeof(BaseLogger)).IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.OnBase">
      <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
      <remarks>
        <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
      </remarks>
      <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // ignore only base method
                Isolate.WhenCalled(() =&gt; fake.VirtualMethod(0)).OnBase().IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.WithGenericArguments(System.Type,System.Type[])">
      <summary>
             Specifies generic type arguments that apply to a non-public method to set behavior on. The behavior will 
             be set only for a method bound to the passed type arguments
             </summary>
      <param name="genericType">The first generic type argument the method binds to</param>
      <param name="additionalGenericTypes">Optional. Further generic type arguments the method binds to.</param>
      <returns>an INonPublicMethodBehavior interface reference</returns>
      <remarks>
             WithGenericArguments() modifies a call to Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />.
             Due to the fluent nature of the AAA API it should be used with its proceeding methods; see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior" />.
             </remarks>
      <example>
             Here is an example how to use WhenCalled with WithGenericArguments in order to simulate an error creating
             a factory generated object:
             <code>
             [TestMethod]
             [Isolated]
             public void ThrowExceptionFromGenericMethod_SimulateErrorCreatingLogger()
             {
                 LoggerFactory fake = Isolate.Fake.Instance&lt;LoggerFactory&gt;();
                 
                 // Set the logger factory to throw an exception when trying to retrieve a RealLogger
                 Isolate.NonPublic.WhenCalled(fake, "GetLogger").
                     WithGenericArguments(typeof(RealLogger)).
                     WillThrow(new ArgumentNullException());
             
                 // The following method call is not faked because it does not match the specified generic 
                 // type arguments - no exception is thrown
                 DiskLogger logger = fake.GetLogger&lt;DiskLogger&gt;();
            
                 // This call will throws an exception as specified
                 try 
                 {
                     fake.GetLogger&lt;RealLogger&gt;();
                     Assert.Fail("Retrieving a RealLogger should have failed with an ArgumentNullException");
                 }
                 catch(ArgumentNullException)
                 {
                 }
             }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.AssignRefOut(System.Object[])">
      <summary>
            Assigns return values of ref and out arguments of a non-public method to set behavior on. 
            </summary>
      <param name="fakeOutRef">list of values corrisponding to ref and out parameters </param>
      <returns>an INonPublicMethodHandler interface reference</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicArgHandler">
      <summary>
            Returned by Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />, this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicArgHandler.WithGenericArguments(System.Type,System.Type[])">
      <summary>
             Specifies generic type arguments that apply to a non-public method to set behavior on. The behavior will 
             be set only for a method bound to the passed type arguments
             </summary>
      <param name="genericType">The first generic type argument the method binds to</param>
      <param name="additionalGenericTypes">Optional. Further generic type arguments the method binds to.</param>
      <returns>an INonPublicMethodBehavior interface reference</returns>
      <remarks>
             WithGenericArguments() modifies a call to Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />.
             Due to the fluent nature of the AAA API it should be used with its proceeding methods; see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior" />.
             </remarks>
      <example>
             Here is an example how to use WhenCalled with WithGenericArguments in order to simulate an error creating
             a factory generated object:
             <code>
             [TestMethod]
             [Isolated]
             public void ThrowExceptionFromGenericMethod_SimulateErrorCreatingLogger()
             {
                 LoggerFactory fake = Isolate.Fake.Instance&lt;LoggerFactory&gt;();
                 
                 // Set the logger factory to throw an exception when trying to retrieve a RealLogger
                 Isolate.NonPublic.WhenCalled(fake, "GetLogger").
                     WithGenericArguments(typeof(RealLogger)).
                     WillThrow(new ArgumentNullException());
             
                 // The following method call is not faked because it does not match the specified generic 
                 // type arguments - no exception is thrown
                 DiskLogger logger = fake.GetLogger&lt;DiskLogger&gt;();
            
                 // This call will throws an exception as specified
                 try 
                 {
                     fake.GetLogger&lt;RealLogger&gt;();
                     Assert.Fail("Retrieving a RealLogger should have failed with an ArgumentNullException");
                 }
                 catch(ArgumentNullException)
                 {
                 }
             }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicArgHandler.AssignRefOut(System.Object[])">
      <summary>
            Assigns return values of ref and out arguments of a non-public method to set behavior on. 
            </summary>
      <param name="fakeOutRef">list of values corrisponding to ref and out parameters </param>
      <returns>an INonPublicMethodHandler interface reference</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior">
      <summary>
            Returned by Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />, and 
            Isolate.NonPublic.WhenCalled().<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.WithGenericArguments(System.Type,System.Type[])" />. this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior.WithExactArguments(System.Object[])">
      <summary>
             Specifies the exact arguments that apply to a non-public method to set behavior on. The behavior will 
             be set only for a method bound to the passed arguments
             </summary>
      <param name="args">The list of the exact arguments the method binds to</param>
      <returns>an INonPublicMethodBehaviorNoArgs interface reference</returns>
      <remarks>
              WithExactArguments(params object[] args) modifies a call to Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />.
             Due to the fluent nature of the AAA API it should be used with its proceeding methods; see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehaviorNoArgs" />.
             </remarks>
      <example>
             Here is an example how to use WhenCalled with WithExactArguments:
             <code>
             [TestMethod, Isolated]
            public void FakeNonPublicMethod_BasedOn_ExactMethodArgs()
            {
                var fake = Isolate.Fake.Instance&lt;Dependency&gt;();
                Isolate.Fake.NonPublic.WhenCalled(fake, "MethodReturnInt").WithExactArguments("typemock", 1).WillReturn(10);
                Isolate.Fake.NonPublic.WhenCalled(fake, "MethodReturnInt").WithExactArguments("unit tests", 2).WillReturn(50);
                Isolate.Fake.WhenCalled(() =&gt; fake.CallPrivate(" ", 0)).CallOriginal();
            
                var result = new Tested().SimpleCalculation(fake);
            
                Assert.AreEqual(60, result);
            }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehavior.WithArgumentTypes(System.Type[])">
      <summary>
             Specifies the arguments types that apply to a non-public method to set behavior on. The behavior will 
             be set only for a method with matching arguments types
             </summary>
      <param name="types">The list of the arguments types</param>
      <returns>an INonPublicMethodBehavior interface reference</returns>
      <example>
             Here is an example how to use WhenCalled with WithArgumentTypes:
             <code>
             [TestMethod, Isolated]
             public void FakeNonPublicMethod_BasedOn_ArgumentTypes()
             {
                  var fake = Isolate.Fake.Instance&lt;Dependency&gt;(Members.CallOriginal);
                  Isolate.NonPublic.WhenCalled(fake, "MethodReturnInt").WithArgumentTypes(typeof(int)).WillReturn(10);
                  Isolate.NonPublic.WhenCalled(fake, "MethodReturnInt").WithArgumentTypes(typeof(string)).WillReturn(50);
            
                  var result = new Tested().SimpleCalculation(fake);
            
                  Assert.AreEqual(60, result);
             }
            
             class Dependency
             {
                 public int CallMethodReturnInt(int i)
                 {
                     return MethodReturnInt(i);
                 }
            
                 public int CallMethodReturnInt(string s)
                 {
                     return MethodReturnInt(s);
                 }
            
                 private int MethodReturnInt(int i)
                 {
                     return 0;
                 }
            
                 private int MethodReturnInt(string s)
                 {
                     return 0;
                 }
             }
            
             class Tested
             {
                 public int SimpleCalculation(Dependency d)
                 {
                     return d.CallMethodReturnInt(0) + d.CallMethodReturnInt("");
                 }
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehaviorNoArgs">
      <summary>
            Returned by Isolate.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIsolateNonPublic.WhenCalled(System.Object,System.String,System.Object[])" />, and 
            Isolate.NonPublic.WhenCalled().<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodHandler.WithGenericArguments(System.Type,System.Type[])" />. this interface 
            contains methods for defining behavior for non public methods, as will as a modifier for applying behavior for
            generic methods
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicMethodBehaviorNoArgs.ReturnRecursiveFake``1">
      <summary>
            Specify that the intercepted method will return a recursive fake of a defined reference type.
            The real implementation will not be executed.
            </summary>
      <typeparam name="T">
            Type of the recursive fake to return
            </typeparam>
      <remarks>
        <para>
            ReturnRecursiveFake&lt;T&gt;() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />. It
            is similar to using the <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes" /> behavior setting when creating 
            fake objects with <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />, but applies only to a single method.
            </para>
            Use ReturnRecursiveFake&lt;T&gt;() on a method to fake out calls to the method and any call chains 
            beginning with it. When ReturnRecursiveFake&lt;T&gt;() is called on a method returning an object, 
            a fake object of type <typeparamref name="T" /> will be returned. That fake object in turn will return fake values for any 
            method calls. 
            ReturnRecursiveFake&lt;T&gt;() on a method returning a value type will set the method to return 
            the default value of that type. 
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
      <seealso cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes" />
      <example>
            This example shows using ReturnRecursiveFake&lt;T&gt;() to fake out a call chain
            <code>
            [TestMethod]
            [Isolated]
            public void ReturnRecursiveFake_ChainedCallsAreFake()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // exclude one method from the default behavior and return a recursive fake from it
                // calling the method will return a fake of the derived class FileStorage
                Isolate.NonPublic.WhenCalled(fake, "InternalMethod").ReturnRecursiveFake&lt;FileStorage&gt;();
            
                // subsequent calls to the method will not return null values
                // Act...
                var result = ClassUnderTest.CallInternalMethod();    
            
                // Assert
                Assert.AreEqual(10,result);
            }
            </code></example>
      <returns>The fake object that will be returned. WhenCalled should be used on this object to setup specific behavior.</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier">
      <summary>
            Returned by Isolate.Verify.<see cref="P:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.NonPublic" />, this interface contains methods for verifying non
            public (private, protected and internal) method, property and index calls, and checking argumentrs.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Object,System.String)">
      <summary>
            Overloaded. Verifies that a non-public method has been called.
            </summary>
      <param name="targetObject">The fake object to verify method behavior on</param>
      <param name="methodName">The method to verify behavior for</param>
      <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments" /> interface reference, used to add argument checking</returns>
      <remarks>
            In order to perform additional argument checking as part of the verification, use the proceeding <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])" />
            method.
            </remarks>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the internal call to WriteToDisk() was performed with correct arguments
               Isolate.Verify.NonPublic.WasCalled(fake, "WriteToDisk").WithArguments("Hello");
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Type,System.String)">
      <summary>
            Overloaded. Verifies that a non-public static method has been called
            </summary>
      <param name="type">The type to verify static method behavior on</param>
      <param name="methodName">The method to verify behavior for</param>
      <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments" /> interface reference, used to add argument checking</returns>
      <remarks>
            In order to perform additional argument checking as part of the verification, use the proceeding <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])" />
            method.
            </remarks>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a static method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStaticMethodWasCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger("logfile.txt", Access.ReadWrite);
            
               // Verify the call to internal method LoggerFactory.GetRealLogger() has been made
               Isolate.Verify.NonPublic.WasCalled(typeof(LoggerFactory), "GetRealLogger").
                    WithArguments("logfile.txt", Access.ReadWrite); 
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Type,System.String,System.Type[])">
      <summary>
            Overloaded. Verifies that a non-public static generic method has been called
            </summary>
      <param name="type">The type to verify static method behavior on</param>
      <param name="methodName">The method to verify behavior for</param>
      <param name="methodGenericArguments">Array of type arguments for the generic method</param>
      <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments" /> interface reference, used to add argument checking</returns>
      <remarks>
            In order to perform additional argument checking as part of the verification, use the proceeding <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])" />
            method.
            </remarks>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a static generic method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStaticMethodWasCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger("logfile.txt", Access.ReadWrite);
            
               // Verify the call to internal method LoggerFactory.GetRealLogger() has been made
               Isolate.Verify.NonPublic.WasCalled(typeof(LoggerFactory), "GetRealLogger", typeof(int)); 
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.LocalWasCalled(System.Object,System.String,System.String)">
      <summary>
            Overloaded. Verifies that a local function inside of a non-public method was not called regardless of parameters.
            </summary>
      <param name="targetObject">The fake object to verify local function behavior on</param>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The local function to verify behavior for</param>
      <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments" /> interface reference, used to add argument checking</returns>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the local function was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a local function was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyLocalFunctionWasCalled()
            {
                var fake = Isolate.Fake.Instance&lt;classWithLocal&gt;(Members.CallOriginal);
                Isolate.NonPublic.WhenCalledLocal(fake, "UseVoidLocal", "GetLocal").CallOriginal();
                fake.UseVoidLocal();
                Isolate.Verify.NonPublic.LocalWasCalled(fake, "UseVoidLocal", "GetLocal");
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.LocalWasCalled(System.Type,System.String,System.String)">
      <summary>
            Overloaded. Verifies that a local function inside of a non-public static method has been called.
            </summary>
      <param name="type"> The type to verify static method behavior on </param>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The local function to verify behavior for</param>
      <returns> An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IArguments" /> interface reference, used to add argument checking</returns>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a local function was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyStaticLocalFunctionWasCalled()
             {
               Isolate.Fake.StaticMethods&lt;PrivateStaticLocalFunction&gt;(Members.CallOriginal);
               Isolate.NonPublic.WhenCalledLocal&lt;PrivateStaticLocalFunction&gt;("UseVoidLocal", "GetLocal").CallOriginal();
               Isolate.Invoke.Method&lt;PrivateStaticLocalFunction&gt;("UseVoidLocal");
               Isolate.Verify.NonPublic.LocalWasCalled(typeof(PrivateStaticLocalFunction), "UseVoidLocal", "GetLocal");
             }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasNotCalled(System.Object,System.String)">
      <summary>
            Overloaded. Verifies that a non-public method was not called regardless of parameters.
            </summary>
      <param name="fake">The fake object to verify method behavior on</param>
      <param name="methodName">The method to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello world!");
            
               // The logger write was called, so an internal WriteToDisk() was performed - 
               // this verification should fail
               Isolate.Verify.NonPublic.WasNotCalled(fake, "WriteToDisk"); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasNotCalled(System.Type,System.String)">
      <summary>
            Overloaded. Verifies that a non-public static method was not called regardless of parameters.
            </summary>
      <param name="type">The type to verify static method behavior on</param>
      <param name="methodName">The method to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // We retrieved a RealLogger and an internal call to GetRealLogger() was made - 
               // this verification should fail
               Isolate.Verify.NonPublic.WasNotCalled(typeof(LoggerFactory), "GetRealLogger"); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.LocalWasNotCalled(System.Object,System.String,System.String)">
      <summary>
            Overloaded. Verifies that a local function inside of a non-public method was not called regardless of parameters.
            </summary>
      <param name="fake">The fake object to verify method behavior on</param>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The local function to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a local function was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyLocalFunctionWasNotCalled()
            {
                var fake = Isolate.Fake.Instance&lt;classWithLocal&gt;();
                Isolate.NonPublic.WhenCalledLocal(fake, "UseVoidLocal", "GetLocal").IgnoreCall();
                fake.UseVoidLocal();
                Isolate.Verify.NonPublic.LocalWasNotCalled(fake, "UseVoidLocal", "GetLocal");
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.LocalWasNotCalled(System.Type,System.String,System.String)">
      <summary>
            Overloaded. Verifies that a local function inside of a non-public static method was not called regardless of parameters.
            </summary>
      <param name="type"> The type to verify static method behavior on </param>
      <param name="methodName">The name of the method that defines the local function.</param>
      <param name="localFunctionName">The local function to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a local function was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyLocalFunctionWasNotCalled()
             {
               Isolate.Fake.StaticMethods&lt;PrivateStaticLocalFunction&gt;();
               Isolate.NonPublic.WhenCalledLocal&lt;PrivateStaticLocalFunction&gt;("UseVoidLocal", "GetLocal").CallOriginal();
               Isolate.Invoke.Method&lt;PrivateStaticLocalFunction&gt;("UseVoidLocal");
               Isolate.Verify.NonPublic.LocalWasNotCalled(typeof(PrivateStaticLocalFunction), "UseVoidLocal", "GetLocal");
             }
            </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Property">
      <summary>
            A read only property, used to verify calls on non-public properties
            </summary>
      <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier" /> reference
            </returns>
      <remarks>
            Because of the nature of fluent interface, you need to use Property with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier" />.
            <para>
            When handling non public (private, protected, internal) properties all access to property names is string-based.
            </para></remarks>
      <example>
            This example shows how to use Isolate.NonPublic.Property in order to verify the behavior of a private property getter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                
                fake.Log("Hello World");
            
                // Verify an internal disk space check was performed
                Isolate.Verify.NonPublic.Property.WasCalledGet(fake, "IsDiskFull");
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier" />
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Indexer">
      <summary>
            A read only property, used to verify calls on non-public indexers
            </summary>
      <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier" /> reference
            </returns>
      <remarks>
            Because of the nature of fluent interface, you need to use Indexer with one of its proceeding methods, see <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier" />.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.Indexer in order to verify behavior on a private index setter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyIndexSetterWasCalled()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                fake.Write("Hello");
            
                // Verify a set call to the LogFile's internal indexer was made
                Isolate.Verify.NonPublic.Indexer.WasSetCalled(fake);
            }
            </code></example>
      <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier">
      <summary>
            Returned by Isolate.Verify.NonPublic.<see cref="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Property" />, this interface contains methods for verifying non
            public (private, protected and internal) properties
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledGet(System.Object,System.String)">
      <summary>
            Overloaded. Verifies that a non-public property getter has been called
            </summary>
      <param name="fake">The fake object to verify property behavior on</param>
      <param name="propertyName">The non-public property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property get was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a private property
            get has been called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the private property IsDiskFull has been called
               Isolate.Verify.NonPublic.Property.WasCalledGet(fake, "IsDiskFull");
            }
            
            // Exceprt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                public void override Write(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
            
                    WriteToFile(fileName, message);
                }
            
                private bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledGet(System.Type,System.String)">
      <summary>
            Overloaded. Verifies that a non-public static property getter has been called
            </summary>
      <param name="type">The type to verify static property get behavior on</param>
      <param name="propertyName">The non-public property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property get was not called.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private property
            get has been called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // Verify the private property DoesLoggerExist has been called
               Isolate.Verify.NonPublic.Property.WasCalledGet(typeof(LoggerFactory), "DoesLoggerExist");
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                private ILogger logger;
                public ILogger GetLogger()
                {
                    if(!DoesLoggerExist)
                    {
                        logger = new RealLogger();
                    }
                
                    return logger;
                }
            
                private bool DoesLoggerExist
                {
                    get { return logger != null; }
                }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Object,System.String)">
      <summary>
            Overloaded. Verifies that a non-public property setter has been called with a specific value
            </summary>
      <param name="fake">The fake object to verify property behavior on</param>
      <param name="propertyName">The non-public property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property set was not called or if it was called with a mismatching value.
            </exception>
      <remarks>
            In order to specify the argument to verify use the proceeding method <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier.WithArgument(System.Object)" />.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private property
            set has been called with a specific value:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled_WithSpecificArgument()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the private property LineCount has been set to 1
               Isolate.Verify.NonPublic.Property.WasCalledSetWithExactArgument(fake, "LineCount").WithArgument(1);
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public void override Write(string message)
                {
                    LineCount = lineCount + 1;
                    WriteToDisk(lineCount, message);
                }
            
                private int lineCount;
                internal int LineCount
                { get; set; }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Type,System.String)">
      <summary>
            Overloaded. Verifies that a non-public static property setter has been called with a specific value
            </summary>
      <param name="type">The type to verify static property get behavior on</param>
      <param name="propertyName">The non-public property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property set was not called or if it was called with a mismatching value.
            </exception>
      <remarks>
            In order to specify the argument to verify use the proceeding method <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier.WithArgument(System.Object)" />.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private static property
            set has been called with a specific value:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled_WithSpecificArgument()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // Verify the private property LoggerCount has been set to 1
               Isolate.Verify.NonPublic.Property.WasCalledSetWithExactArgument(typeof(LoggerFactory), "LoggerCount").WithArgument(1);
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                public ILogger GetLogger()
                {
                    LoggerCount++;
                    return ...;
                }
            
                private static int loggerCount = 0;
                protected static int LoggerCount
                { get; set; }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledGet(System.Object,System.String)">
      <summary>
            Overloaded. Verifies that a non-public property get was not called regardless of parameters.
            </summary>
      <param name="fake">The fake object to verify property behavior on</param>
      <param name="propertyName">The property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property getter was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property get was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello world!");
            
               // The logger write was called, so an internal call to the IsDiskFull property was performed - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledGet(fake, "IsDiskFull"); 
            }
            
            
            // Exceprt from class under test
            public class RealLogger : ILogger
            {
                private string fileName;
                public void override Write(string message)
                {
                    if(IsDiskFull)
                    {
                        throw new OutOfDiskSpaceException();
                    }
            
                    WriteToFile(fileName, message);
                }
            
                private bool IsDiskFull
                {
                    get { return ...; }
                }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledGet(System.Type,System.String)">
      <summary>
            Overloaded. Verifies that a non-public static property get was not called regardless of parameters.
            </summary>
      <param name="type">The type to verify static property behavior on</param>
      <param name="propertyName">The property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property getter was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property get was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // We retrieved a RealLogger and an internal call to LoggerFactory.LoggerInstance was made - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledGet(typeof(LoggerFactory), "LoggerInstance"); 
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                public ILogger GetLogger()
                {
                    if(LoggerInstance == null)
                    {
                        LoggerInstance = new ...;
                    }
                    return LoggerInstance;
                }
                
                protected ILogger LoggerInstance
                {
                    get { ... }
                    set { ... }
                }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledSet(System.Object,System.String)">
      <summary>
            Overloaded. Verifies that a non-public property set was not called regardless of parameters.
            </summary>
      <param name="fake">The fake object to verify property behavior on</param>
      <param name="propertyName">The property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property setter was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property set was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello world!");
            
               // The logger write was called, so internal property LineCount was updated - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledSet(fake, "LineCount"); 
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public void override Write(string message)
                {
                    LineCount = lineCount + 1;
                    WriteToDisk(lineCount, message);
                }
            
                private int lineCount;
                internal int LineCount
                { get; set; }
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasNotCalledSet(System.Type,System.String)">
      <summary>
            Overloaded. Verifies that a non-public static property set was not called regardless of parameters.
            </summary>
      <param name="type">The type to verify static property behavior on</param>
      <param name="propertyName">The property to verify behavior for</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the property setter was called at least once.
            </exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic.Property in order to check a property set was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasNotCalled()
            {
               Isolate.Fake.Instance&lt;LoggerFactory&gt;(Members.CallOriginal);
            
               RealLogger logger = LoggerFactory.GetLogger();
            
               // We created a RealLogger and an internal property LoggerFactory.LoggerCount was updated - 
               // this verification should fail
               Isolate.Verify.NonPublic.Property.WasNotCalledSet(typeof(LoggerFactory), "LoggerCount"); 
            }
            
            // Excerpt from class under test
            public class LoggerFactory
            {
                public ILogger GetLogger()
                {
                    LoggerCount++;
                    return ...;
                }
            
                private static int loggerCount = 0;
                protected static int LoggerCount
                { get; set; }
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IArguments">
      <summary>
            Returned by Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Object,System.String)" />, this interface is used to verify
            the call was made with specific arguments 
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IArguments.WithArguments(System.Object,System.Object[])">
      <summary>
            Verify the call was made with the specified arguments
            </summary>
      <param name="argument">Mandatory. The first argument to verify.</param>
      <param name="additionalArguments">Optional. Additional arguments to verify.</param>
      <remarks>
        <para>
            This method is used to complement verifying calls, using 
            Isolate.Verify.NonPublic.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Object,System.String)" />, with specific argument verification.
            </para>
        <para>
            All expected call arguments must be passed to this method in order for verification to be performed.
            </para>
      </remarks>
      <exception cref="T:TypeMock.VerifyException">Thrown if the call was made with mismatching arguments</exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a method was called with specific arguments:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the internal call to WriteToDisk() was performed with correct arguments
               Isolate.Verify.NonPublic.WasCalled(fake, "WriteToDisk").WithArguments("Hello");
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public void override Write(string message)
                {
                    WriteToDisk(message);
                }
            
                private void WriteToDisk(string content)
                { ... }
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier">
      <summary>
            Returned by Isolate.Verify.Property.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Object,System.String)" /> and 
            Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.WasCalled(System.Type,System.String)" />, this interface is used to verify
            a property setter call was made with the correct argument
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IArgumentVerifier.WithArgument(System.Object)">
      <summary>
            Verify the property set call was made with the specified argument
            </summary>
      <param name="argument">The property set value to verify.</param>
      <remarks>
            This method is used to complement verifying property set, using 
            Isolate.Verify.NonPublic.Property.<see cref="M:TypeMock.ArrangeActAssert.Fluent.INonPublicPropertyVerifier.WasCalledSet(System.Object,System.String)" />, 
            with specific argument verification.
            </remarks>
      <exception cref="T:TypeMock.VerifyException">Thrown if the property set call was made with a mismatching argument</exception>
      <example>
            This example shows how to use Isolate.Verify.NonPublic in order to check a private property
            set has been called with a specific value:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyPropertyWasCalled_WithSpecificArgument()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
               fake.Write("Hello");
            
               // Verify the private property LineCount has been set to 1
               Isolate.Verify.NonPublic.Property.WasCalledSetWithExactArgument(fake, "LineCount").WithArgument(1);
            }
            
            // Excerpt from class under test
            public class RealLogger : ILogger
            {
                public override void Write(string message)
                {
                    LineCount++;
                    WriteToDisk...;
                }
            
                private int lineCount;
                internal int LineCount
                { get; set; }
                
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier">
      <summary>
            Returned by Isolate.Verify.<see cref="P:TypeMock.ArrangeActAssert.Fluent.INonPublicVerifier.Indexer" />, this interface contains methods for verifying non
            public (private, protected and internal) index calls.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)">
      <summary>
            Verify a call has been made to a non-private index getter
            </summary>
      <returns>
            An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier" /> reference
            </returns>
      <param name="fake">The fake object to verify index behavior on</param>
      <remarks>
            In order to verify the index getter has been called at a specific index location, use the proceeding method 
            <see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier.WithIndex``1(``0)" />.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.Indexer.WasCalledGet() in order to verify behavior on a private index setter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyIndexGetterWasCalled()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                string line = fake.GetLineAt(10);
            
                // Verify a get call to the LogFile's internal indexer was made
                Isolate.Verify.NonPublic.Indexer.WasGetCalled(fake).WithIndex(10);
            }
            
            // Excerpt from class under test
            public class LogFile
            {
                public string GetLineAt(int lineNumber)
                {
                    return this[lineNumber];
                }
                
                protected string this[int line]
                {
                    get { return ...; }
                }
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier.WithIndex``1(``0)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledSet(System.Object)">
      <summary>
             Verify a call has been made to a non-private index setter
             </summary>
      <returns>
             An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier" /> reference
             </returns>
      <param name="fake">The fake object to verify index behavior on</param>
      <remarks>
             In order to verify the index getter has been called at a specific index location and value, use the proceeding method 
             <see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)" />.
             </remarks>
      <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasCalledSet() in 
             order to verify behavior on a private index setter:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexSetterWasCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 // set the position to write at - this will be used for internal index value
                 fake.SetPosition(10);
                 fake.Write("Hello World");
             
                 // Verify a set call to the LogFile's internal indexer was made at the correct index
                 Isolate.Verify.NonPublic.Indexer.WasSetCalled(fake).WithIndexAndValue(10, "Hello World");
             }
             
             // Excerpt from class under test
             public class LogFile
             {
                 private int currentPosition = 0;
                 public void Write(string message)
                 {
                     this[currentPosition] = message;
                 }
             
                 public void SetPosition(int value)
                 {
                     currentPosition = value;
                 }
                 
                 protected string this[int line]
                 {
                     set { WriteToFile(line, value); }
                 }
             }
             </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasNotCalledGet(System.Object)">
      <summary>
             Verify a call has not been made to a non-private index getter
             </summary>
      <param name="fake">The fake object to verify index behavior on</param>
      <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasNotCalledGet() 
             in order to verify a private index getter has not been called:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexGetterWasNotCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 string line = fake.GetLineAt(10)
             
                 // The internal index was used to retrieve the log line - this verification should fail
                 Isolate.Verify.NonPublic.Indexer.WasNotCalledGet(fake);
             }
             
             
             // Excerpt from class under test
             public class LogFile
             {
                 public string GetLineAt(int lineNumber)
                 {
                     return this[lineNumber];
                 }
                 
                 protected string this[int line]
                 {
                     get { return ...; }
                 }
             }
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasNotCalledSet(System.Object)">
      <summary>
             Verify a call has not been made to a non-private index setter
             </summary>
      <param name="fake">The fake object to verify index behavior on</param>
      <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasNotCalledSet() 
             in order to verify a private index getter has not been called:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexSetterWasNotCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 // set the position to write at - this will be used for internal index value
                 fake.SetPosition(10);
                 fake.Write("Hello World");
             
                 // The internal index was set during the Write operation so this verification will fail
                 Isolate.Verify.NonPublic.Indexer.WasNotCalledSet(fake);
             }
             
             // Excerpt from class under test
             public class LogFile
             {
                 private int currentPosition = 0;
                 public void Write(string message)
                 {
                     this[currentPosition] = message;
                 }
             
                 public void SetPosition(int value)
                 {
                     currentPosition = value;
                 }
                 
                 protected string this[int line]
                 {
                     set { WriteToFile(line, value); }
                 }
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier">
      <summary>
            Returned by Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)" />, this interface is used to verify an index
            getter was called with a specific index.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerGetVerifier.WithIndex``1(``0)">
      <summary>
            Verify the index getter was made with the specific index location.
            </summary>
      <param name="index">The index location value to verify</param>
      <typeparam name="T">The type of the index used. Can be inferred from <c>index</c>.</typeparam>
      <remarks>
            This method is used to complement verifying index getter calls, using 
            Isolate.Verify.NonPublic.Indexer.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)" />, with specific index location verification.
            </remarks>
      <example>
            This example shows how to use Isolate.NonPublic.Indexer.WasCalledGet() in order to verify behavior on a private index setter:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyIndexGetterWasCalled()
            {
                LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
                
                string line = fake.GetLineAt(10);
            
                // Verify a get call to the LogFile's internal indexer was made
                Isolate.Verify.NonPublic.Indexer.WasGetCalled(fake).WithIndex(10);
            }
            
            // Excerpt from class under test
            public class LogFile
            {
                public string GetLineAt(int index)
                {
                    return this[index];
                }
                
                internal string this[int line]
                {
                    get { return GetFromLog(line); } 
                }
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledGet(System.Object)" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier">
      <summary>
            Returned by Isolate.Verify.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledSet(System.Object)" />, this interface is used to verify an index
            setter was called with a specific index.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)">
      <summary>
             Verify the index setter was called with a specific index location and setter value
             </summary>
      <param name="index">The index location value to verify</param>
      <param name="value">The setter value to verify</param>
      <typeparam name="TIndex">The type of the index used. Can be inferred from <c>index</c></typeparam>
      <typeparam name="TValue">The type of the setter value used. Can be inferred from <c>value</c></typeparam>
      <remarks>
             This method is used to complement verifying index setter calls, using 
             Isolate.Verify.NonPublic.Indexer.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerVerifier.WasCalledSet(System.Object)" />, with specific 
             index location and value verification.
             </remarks>
      <example>
             This example shows how to use Isolate.NonPublic.Indexer.WasCalledSet() in 
             order to verify behavior on a private index setter:
             <code>
             [TestMethod]
             [Isolated]
             public void VerifyIndexSetterWasCalled()
             {
                 LogFile fake = Isolate.Fake.Instance&lt;LogFile&gt;(Members.CallOriginal);
            
                 // set the position to write at - this will be used for internal index value
                 fake.SetPosition(10);
                 fake.Write("Hello World");
             
                 // Verify a set call to the LogFile's internal indexer was made
                 Isolate.Verify.NonPublic.Indexer.WasSetCalled(fake).WithIndexAndValue(10, "Hello World");
             }
             
             // Excerpt from class under test
             public class LogFile
             {
                 private int currentPosition = 0;
                 public void Write(string message)
                 {
                     this[currentPosition] = message;
                 }
             
                 public void SetPosition(int value)
                 {
                     currentPosition = value;
                 }
                 
                 protected string this[int line]
                 {
                     set { WriteToFile(line, value); }
                 }
             }
             </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IIndexerSetVerifier.WithIndexAndValue``2(``0,``1)" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`2">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`3">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`4">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`4.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`5">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Func{``0,``1,``2,``3,``4})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Func{``0,``1,``2,``3,``4})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`5.AndArgumentsMatch(System.Func{`0,`1,`2,`3,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Func{``0,``1,``2,``3,``4})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`6">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Func{``0,``1,``2,``3,``4,``5})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Func{``0,``1,``2,``3,``4,``5})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`6.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Func{``0,``1,``2,``3,``4,``5})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`7">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Func{``0,``1,``2,``3,``4,``5,``6})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Func{``0,``1,``2,``3,``4,``5,``6})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`7.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Func{``0,``1,``2,``3,``4,``5,``6})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`8">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`8.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`9">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`9.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`10">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`10.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`11">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.INonVoidMatchingHandler`11.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,System.Boolean})">
      <summary>
            Defines a custom argument matching predicate for the method passed in 
            <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})" /> using its parameter placeholders. 
            The fake behavior specified in the following statement(s) will be returned only if this 
            predicate is evaluated as true on the call's arguments.
            </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
            placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
            faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1" /> interface reference</returns>
      <example>
            Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to return a value if an argument is 
            inside a range of values:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value of AddLines() if the number of lines is between 1 and 5
                Isolate.WhenCalled((int i) =&gt; fake.AddLines(i))
                    .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;=1)
                    .WillReturn(10);
            
                Assert.AreEqual(10, fake.AddLines(3));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1">
      <summary>
            Interface for specifying behavior for intercepted calls on public methods returning values. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of public base methods that has return values.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1.OnBase(System.Type)">
      <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
      <remarks>
        <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
        <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
      </remarks>
      <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Set return value only on base method
                Isolate.WhenCalled(() =&gt; fake.VirtualMethod(0)).OnBase().WillReturn(10);
            
                // Check that the correct value returned
                Assert.AreEqual(10, fake.VirtualMethod(0));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidMethodHandler`1.OnBase">
      <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
      <remarks>
        <para>
            OnBase() is a completing statement for <see><cref>Isolate.WhenCalled{T}</cref></see>. 
            </para>
      </remarks>
      <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Set return value only on base method
                Isolate.WhenCalled(() =&gt; fake.VirtualMethod(0)).OnBase().WillReturn(10);
            
                // Check that the correct value returned
                Assert.AreEqual(10, fake.VirtualMethod(0));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidRootMethodHandler`1">
      <summary>
            Interface for specifying behavior for intercepted calls on public methods returning values. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of public methods that has return values.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidRootMethodHandler`1.ReturnRecursiveFake">
      <summary>
            Specify that the intercepted method will return a recursive fake.
            The real implementation will not be executed.
            </summary>
      <remarks>
        <para>
            ReturnRecursiveFake() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />. It
            is similar to using the <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes" /> behavior setting when creating 
            fake objects with <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />, but applies only to a single method.
            </para>
            Use ReturnRecursiveFake() on a method to fake out calls to the method and any call chains 
            beginning with it. When ReturnRecursiveFake() is called on a method returning an object, 
            a fake object will be returned. That fake object in turn will return fake values for any 
            method calls. 
            ReturnRecursiveFake() on a method returning a value type will set the method to return 
            the default value of that type. 
            
            When ReturnRecursiveFake() is used on methods whose returned value is a collection
            in mscorlib (only collections that implement IEnumerable and have default constructor)
            then a new initialized collection is returned.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
      <seealso cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes" />
      <example>
            This example shows using ReturnRecursiveFake() to fake out a call chain
            <code>
            [TestMethod]
            [Isolated]
            public void ReturnRecursiveFake_ChainedCallsAreFake()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // exclude one method from the default behavior and return a recursive fake from it
                Isolate.WhenCalled(() =&gt; fake.Storage).ReturnRecursiveFake();
            
                // subsequent calls to the method will not return null values
                Assert.IsNotNull(fake.Storage);
                Assert.IsNotNull(fake.Storage.FileSystem);
                // methods returning a value type will return the default value for the type
                Assert.AreEqual(0, fake.Storage.FreeSpaceInBytes);
            }
            </code></example>
      <returns>The fake object that will be returned. WhenCalled should be used on this object to setup specific behavior.
            </returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicNonVoidRootMethodHandler`1.WithExactArguments">
      <summary>
            Specifies that the behavior will only be set on method calls with the exact arguments.
            </summary>
      <remarks>
        <para>
            WithExactArguments() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />. 
            </para>
      </remarks>
      <example>
            This example shows how to use WithExactArguments() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void WithExactArguments_DifferentArgsReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // Set return value according to exact arguments
                Isolate.WhenCalled(() =&gt; fake.IntCallWithArg(0)).WithExactArguments().WillReturn(10);
                Isolate.WhenCalled(() =&gt; fake.IntCallWithArg(1)).WithExactArguments().WillReturn(20);
            
                // Check that the correct value returned
                Assert.AreEqual(10, fake.IntCallWithArg(0));
                Assert.AreEqual(20, fake.IntCallWithArg(1));
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IMethodBehavior">
      <summary>
            Interface for specifying behavior for a method call. The interface is extended by <see cref="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler" /> and <see cref="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1" />.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of any method by calling its original implementation or throwing an exception from it.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IMethodBehavior.CallOriginal">
      <summary>
            Specify that an intercepted call will try to execute the real logic of the intercepted instance.
            </summary>
      <remarks>
            This interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            <para>
            Before using this directive make sure that the intercepted method has a real implementation that can be executed.
            </para></remarks>
      <example>
            This test shows faking an object to return null values, and overriding one of its methods to call its original
            implementation:
            <code>
            [TestMethod]
            [Isolated]
            public void CallOriginalOnFakeInstance()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls);
                
                // Override the Increment() method to call its original implementation
                Isolate.WhenCalled(() =&gt; fake.Increment()).CallOriginal();
            
                // Make sure Count is reset
                fake.Count = 0;
            
                // This call now redirects to its original implementation - the count should increment
                fake.Increment();
                Assert.AreEqual(1, fake.Count);
            
                // even though we called the original implementation, we can still verify the call happened
                Isolate.Verify.WasCalledWithAnyArguments(() =&gt; fake.Increment());
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IMethodBehavior.WillThrow(System.Exception)">
      <summary>
            Specify that an intercepted call will throw the given exception.
            </summary>
      <remarks>
            This interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </remarks>
      <param name="ex"> The exception to throw</param>
      <example>
            This test shows faking an object, and overriding one of its methods to throw an exception:
            <code>
            [TestMethod]
            [Isolated]
            [ExpectedException(typeof(OutOfMemoryException))]
            public void WillThrowOnFakeInstance()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Override the Write() method to throw an exception
                Isolate.WhenCalled(() =&gt; fake.Write("")).WillThrow(new OutOfMemoryException());
            
                // This call will now throw an exception when called - this is verified by the
                // [ExpectedException] decorator
                fake.Write("Hello");
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler">
      <summary>
            Interface for specifying behavior for intercepted calls on public void methods. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of public base methods that has return values.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler.OnBase(System.Type)">
      <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
      <remarks>
        <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
        <para>
            OnBase() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />. 
            </para>
      </remarks>
      <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Ignore only base method
                Isolate.WhenCalled(() =&gt; fake.VirtualMethod(0)).OnBase(typeof(BaseLogger)).IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler.OnBase">
      <summary>
            Specifies that the behavior will only be set on base of the last method call.
            </summary>
      <remarks>
        <para>
            OnBase() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />. 
            </para>
      </remarks>
      <example>
            This example shows how to use OnBase() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void OnBase_ReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;DerivedLogger&gt;(Members.CallOriginal);
                 
                // Ignore only base method
                Isolate.WhenCalled(() =&gt; fake.VirtualMethod(0)).OnBase().IgnoreCall();
            
                // Check that the base was not called
                Assert.AreEqual(false, fake.WasBaseCalled);
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidWithExactActionHandler">
      <summary>
            Interface for specifying behavior for intercepted calls on public void methods. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of public base methods that has return values.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IPublicVoidWithExactActionHandler.WithExactArguments">
      <summary>
            Specifies that the behavior will only be set on method calls with the exact arguments.
            </summary>
      <remarks>
        <para>
            WithExactArguments() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" />. 
            </para>
      </remarks>
      <example>
            This example shows how to use WithExactArguments() to set behavior on specific method call
            <code>
            [TestMethod]
            [Isolated]
            public void WithExactArguments_DifferentArgsReturnDifferentValues()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // Set return value according to exact arguments
                Isolate.WhenCalled(() =&gt; fake.VoidCallWithArg(0)).WithExactArguments().IgnoreCall();
                Isolate.WhenCalled(() =&gt; fake.VoidCallWithArg(1)).WithExactArguments().CallOriginal();
                Isolate.WhenCalled(() =&gt; fake.VoidCallWithArg(2)).WithExactArguments().WillThrow(new Exception(""));
            
                // Check that the correct value returned
                fake.VoidCallWithArg(0); // This call will be ignored
                fake.VoidCallWithArg(1); // This call will call the real method
                fake.VoidCallWithArg(2); // This call will throw an exception
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1">
      <summary>
            Interface for specifying behavior for intercepted calls on methods returning values. 
            The interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" />.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of methods that has return values.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1.WillReturn(`0)">
      <summary>
            Specify that the intercepted method will return the given value.
            The real implementation will not be executed.
            </summary>
      <param name="value">The fake value to return when the call is intercepted</param>
      <example>
            This example shows using WillReturn() to change the return value for a property call:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_ChangeMethodReturnValue()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Change the return value for Count property
                Isolate.WhenCalled(() =&gt; fake.Count).WillReturn(10);
            
                // fake.Count will return the assigned value
                Assert.AreEqual(10, fake.Count);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1.DoInstead(System.Func{TypeMock.MethodCallContext,`0})">
      <summary>
             Run a custom function instead of the methods in the WhenCalled block.
             </summary>
      <param name="function">The function that will run instead of the faked method</param>
      <example>
             This example shows using DoInstead() to run custom code instead of a function:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_DoInstead()
             {
                 var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
                 // Use DoInstead to replace the method called with custom function
                 Isolate.WhenCalled(() =&gt; fake.IntCallWithArgs(0))
                     .DoInstead((callContext) =&gt;
                         {
                             // We can set field on the instance that called the method
                             ((RealLogger)callContext.Instance).count = (int)callContext.ParametersDefaultValuesGenerator[0];
            
                             // Change the returned value  
                             return 100;
                         });
            
                 int value = fake.IntCallWithArgs(10);
             
                 // Verify
                 Assert.AreEqual(100, value);
                 Assert.AreEqual(10, fake.count);
             </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IReturnValueHandler`1.ReturnRecursiveFake(System.Type)">
      <summary>
            Specify that the intercepted method will return a recursive fake of a defined reference type.
            The real implementation will not be executed.
            </summary>
      <param name="type">
            Type of the recursive fake to return
            </param>
      <remarks>
        <para>
            ReturnRecursiveFake&lt;T&gt;() is a completing statement for <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />. It
            is similar to using the <see cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes" /> behavior setting when creating 
            fake objects with <see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />, but applies only to a single method.
            </para>
            Use ReturnRecursiveFake(type) on a method to fake out calls to the method and any call chains 
            beginning with it. When ReturnRecursiveFake(type) is called on a method returning an object, 
            a fake object of <paramref name="type" /> will be returned. That fake object in turn will return fake values for any 
            method calls. 
            ReturnRecursiveFake(type) on a method returning a value type will set the method to return 
            the default value of that type. 
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.Instance``1(TypeMock.ArrangeActAssert.Members)" />
      <seealso cref="F:TypeMock.ArrangeActAssert.Members.ReturnRecursiveFakes" />
      <example>
            This example shows using ReturnRecursiveFake(type) to fake out a call chain
            <code>
            [TestMethod]
            [Isolated]
            public void ReturnRecursiveFake_ChainedCallsAreFake()
            {
                // create a fake logger which will behave as the original one
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
                 
                // exclude one method from the default behavior and return a recursive fake from it
                // calling the method will return a fake of the derived class FileStorage
                Isolate.NonPublic.WhenCalled(fake, "InternalMethod").ReturnRecursiveFake(typeof(FileStorage));
            
                // subsequent calls to the method will not return null values
                // Act...
                var result = ClassUnderTest.CallInternalMethod();    
            
                // Assert
                Assert.AreEqual(10,result);
            }
            </code></example>
      <returns>The fake object that will be returned. WhenCalled should be used on this object to setup specific behavior.</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler">
      <summary>
            Interface for specifying behavior for a void returning intercepted calls. The interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </summary>
      <remarks>
            This interface allow tweaking the behavior of methods which return void.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler.IgnoreCall">
      <summary>
            Specify that an intercepted call should be ignored without executing any logic.
            </summary>
      <remarks>
            This interface is returned by <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)" /> method.
            </remarks>
      <example>
            This example shows using IgnoreCall() to stub out a call to a method:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_StubIncrementMethod()
            {
                RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                
                // Increment call will be ignored (stubbed)
                Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
            
                // Make sure Count is reset
                fake.Count = 0;
            
                // This call is faked - count should not increment
                fake.Increment();
            
                Assert.AreEqual(0, fake.Count);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidActionHandler.DoInstead(System.Action{TypeMock.MethodCallContext})">
      <summary>
            Run a custom action instead of the methods in the WhenCalled block.
            </summary>
      <param name="action">The action that will run instead of the faked method</param>
      <example>
            This example shows using DoInstead() to run custom code instead of a function:
            <code>
            [TestMethod]
            [Isolated]
            public void FakeAnInstance_DoInstead()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.CallOriginal);
            
                // Use DoInstead to replace the called method with custom action
                Isolate.WhenCalled(() =&gt; fake.CallWithArguments("", 0, 0.0))
                    .DoInstead((callContext) =&gt;
                            {
                                // Change the value of a field in the object that called the method
                                ((RealLogger)callContext.Instance).count = (int)callContext.ParametersDefaultValuesGenerator[1];
                            });
                
                // Call the method
                fake.CallWithArguments(100);
            
                // Verify the field's value
                Assert.AreEqual(100, fake.count);
            }
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Action{``0})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`1.AndArgumentsMatch(System.Func{`0,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``1(System.Func{``0})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Action{``0,``1})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Action{``0,``1})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`2.AndArgumentsMatch(System.Func{`0,`1,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``2(System.Func{``0,``1})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Action{``0,``1,``2})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Action{``0,``1,``2})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`3.AndArgumentsMatch(System.Func{`0,`1,`2,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``3(System.Func{``0,``1,``2})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Action{``0,``1,``2,``3})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Action{``0,``1,``2,``3})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`4.AndArgumentsMatch(System.Func{`0,`1,`2,`3,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``4(System.Func{``0,``1,``2,``3})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Action{``0,``1,``2,``3,``4})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Action{``0,``1,``2,``3,``4})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`5.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``5(System.Func{``0,``1,``2,``3,``4})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Action{``0,``1,``2,``3,``4,``5})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Action{``0,``1,``2,``3,``4,``5})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`6.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``6(System.Func{``0,``1,``2,``3,``4,``5})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Action{``0,``1,``2,``3,``4,``5,``6})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Action{``0,``1,``2,``3,``4,``5,``6})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`7.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``7(System.Func{``0,``1,``2,``3,``4,``5,``6})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`8.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`9.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10">
      <summary>
            Interface used to define conditional argument matching when faking behavior. The interface is returned 
            by the <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})" /> method.
            </summary>
      <remarks>
            This interface allows defining custom argument matching by taking the parameter placeholders
            provided in Isolate.WhenCalled() and defining a custom checking function around them.
            </remarks>
      <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVoidMatchingHandler`10.AndArgumentsMatch(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,System.Boolean})">
      <summary>
             Defines a custom argument matching predicate for the method passed in 
             <seealso cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})" /> using its parameter placeholders. 
             The fake behavior specified in the following statement(s) will be returned only if this 
             predicate is evaluated as true on the call's arguments.
             </summary>
      <param name="argumentMatchingFunc">The predicate function. Evaluates the parameter 
             placeholders from <c>WhenCalled()</c> and returns true or false. If this returns true, the following
             faked behavior will be returned.</param>
      <returns>An <seealso cref="T:TypeMock.ArrangeActAssert.Fluent.IPublicVoidActionHandler" /> interface reference</returns>
      <example>
             Here is an example how to use WhenCalled() with AndArgumentsMatch() in order to 
             ignore (stub) a call if its argument is inside a range of values:
             <code>
             [TestMethod]
             [Isolated]
             public void FakeAnInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 
                 // The call to Increment() will be ignored if the argument value is between 1 and 5
                 Isolate.WhenCalled((int i) =&gt; fake.Increment(i))
                     .AndArgumentsMatch(i =&gt; i &lt;= 5 &amp;&amp; i &gt;= 1)
                     .IgnoreCall();
             
                 // Make sure Count is reset
                 fake.Count = 0;
             
                 // This call is faked - count should not increment because the argument value is between 1 and 5
                 fake.Increment(3);
            
                 Assert.AreEqual(0, fake.Count);
             }
             </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.ISwapper">
      <summary>
            Interface used for swapping between object method calls and collection values.
            </summary>
      <remarks>
            This interface is returned by the Isolate.<see cref="P:TypeMock.ArrangeActAssert.Isolate.Swap" /> property.
            </remarks>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.NextInstance``1">
      <summary>
             Return a swapping object, in order to swap a future instance of type T with an existing fake object.
             </summary>
      <returns>An <c>ISwapperBehavior</c> interface refernce.</returns>
      <remarks>
             Because of the nature of fluent interface, you need to use NextInstance with its proceeding method <see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)" /></remarks>
      <example>
             This example shows using NextInstance in order to fake a future instance:
             <code>
             [TestMethod]
             [Isolated]
             public void SwapAFutureInstance_StubIncrementMethod()
             {
                 RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 Isolate.Swap.NextInstance&lt;RealLogger&gt;().With(fake);
            
                 Isolate.WhenCalled(() =&gt; fake.Increment()).IgnoreCall();
             
                 // This object is swapped with the fake
                 RealLogger logger = new RealLogger();
             
                 // Make sure Count is reset
                 logger.Count = 0;
             
                 // This call is faked - count should not increment
                 logger.Increment();
            
                 Assert.AreEqual(0, logger.Count);
             }
             </code></example>
      <note>
             The constructor behavior of the next instance will follow the constructor behavior of the swapped instance.
             If it is a real object it will be called, if it is a fake it will follow the fakes behavior
             </note>
      <typeparam name="T">Type of instance to swap.</typeparam>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.AllInstances``1">
      <summary>
             Return a swapping object, in order to swap all past and future instance of type T with an existing fake object.
             Use this method to set the same behavior on all instances of the same type.
             </summary>
      <returns>An <c>ISwapperBehavior</c> interface refernce.</returns>
      <remarks>
             Because of the nature of fluent interface, you need to use AllInstances with its
             proceeding methods <see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.With(`0)" /> or <see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapperBehavior`1.ConstructorWillThrow(System.Exception)" /></remarks>
      <example>
             This example shows using AllInstances in order to set the same behavior on two instances:
             <code>
             [TestMethod, Isolated]
             public void SwapAllInstances_FakeFutureAndPastInstances_AllInstancesAreFaked()
             {
                 var logger1 = new RealLogger();
             
                 var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
                 Isolate.WhenCalled(() =&gt; fake.ReturnFive()).WillReturn(50);
            
                 // set behavior on all future and past instances of RealLogger
                 Isolate.Swap.AllInstances&lt;RealLogger&gt;().With(fake);
             
                 var logger2 = new RealLogger();
                 
                 // Verify behavior of past instance is faked
                 Assert.AreEqual(50, logger1.ReturnFive());
                 // Verify behavior of future instance is faked
                 Assert.AreEqual(50, logger2.ReturnFive());
             }
             </code></example>
      <note>
             The constructor behavior of the next instances will follow the constructor behavior of the swapped instance.
             If it is a real object it will be called, if it is a fake it will follow the fakes behavior
             </note>
      <typeparam name="T">Type of instances to swap.</typeparam>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)">
      <summary>
            Enables swapping one object's implementation with another. Followed by the completing statement 
            <see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" />.
            </summary>
      <param name="toSwap">The object to swap implementation for</param>
      <returns>An <see cref="T:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper" /> interface reference. </returns>
      <remarks>
            When a method is called on the swapped object, it is replaced with a corresponding implementation (a method
            with the same signature) on the swapping object. This means that the swapped object will start behaving like
            the object it was swapped with for all methods they have in common.
            </remarks>
      <example>
            This example shows how to use Isolate.Swap.<see cref="M:TypeMock.ArrangeActAssert.Fluent.ISwapper.CallsOn(System.Object)" />.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" /> 
            in order to redirect calls from an object to a stand-in object:
            <code>
            [TestMethod]
            [Isolated]
            public void SwapCallsOnObject_CallsRedirectedToTargetObject()
            {
                // Create the object under test
                RealLogger logger = new RealLogger();
                // Create the object calls will be redirected to
                TestLogger swapped = new TestLogger();
            
                // Redirect any calls from the object under test to the swapping target
                Isolate.Swap.CallsOn(logger).WithCallsTo(swapped);
            
                // logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
                logger.Write("Hello World");
            
                // We can still verify the call to logger.Write() happened
                Isolate.Verify.WasCalledWithAnyArguments(() =&gt; logger.Write(""));
            }
            
            // excerpt code for the class under test:
            public class RealLogger
            {
                string logFilePath = ...;
                public void Write(string toWrite)
                {
                    logFile.WriteAllText(logFilePath, toWrite);
                }
            }
            
            // excerpt code for the replacement class:
            public class TestLogger
            {
                public void Write(string toWrite)
                {
                    Console.WriteLine("RealLogger.Write() was called with {0}", toWrite);
                }
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Fluent.IDynamicSwapper.WithCallsTo(System.Object)" />
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler">
      <summary>
            Returned by <seealso cref="P:TypeMock.ArrangeActAssert.Isolate.Verify" />, this interface contains methods for verifying the method calls and checking their arguments.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler.OnBase(System.Type)">
      <summary>
            Overloaded. Verifies that the method in a base class was called. The baseType must be in the last calls heiarchy.
            </summary>
      <param name="baseType">The type to verify the call. The baseType must be in the last calls heiarchy.</param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if the base type can not be found.
            </exception>
      <remarks>
            The verify uses the following statements to configure what to verify
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.OnBase:
            <code>
            [TestMethod]
            [Isolated]
            public void OnBaseExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;DeviredLogger&gt;(Members.CallOriginal);
            
               string entry = fake.VirtualMethod();
            
               Isolate.Verify.Base(typeof(BaseLogger)).WasCalledWithAnyArguments(() =&gt; fake.VirtualMethod());
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler.OnBase">
      <summary>
            Overloaded. Verifies that the method in the base class was called. The baseType must be in the last calls heiarchy.
            </summary>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if the base type can not be found.
            </exception>
      <remarks>
            The verify uses the following statements to configure what to verify
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.OnBase:
            <code>
            [TestMethod]
            [Isolated]
            public void OnBaseExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;DeviredLogger&gt;(Members.CallOriginal);
            
               string entry = fake.VirtualMethod();
            
               Isolate.Verify.Base().WasCalledWithAnyArguments(() =&gt; fake.VirtualMethod());
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyHandler.GetInstancesOf``1(``0)">
      <summary>
            Returns faked objects that where created using Isolate.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.NextInstance``1" /> and Isolate.<see cref="M:TypeMock.ArrangeActAssert.Fluent.IFaker.AllInstances``1" />.
            </summary>
      <param name="fake">a fake instance</param>
      <returns>An array of instances that are controlled by the fake</returns>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if fake has no instances that where instantiated.
            </exception>
      <remarks>
            Do not use <see cref="P:TypeMock.ArrangeActAssert.Isolate.Verify" /> on the returned instances, use the fake instance instead.
            Instances that have been GC'ed will not apear.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.GetInstancesOf in order to grab a future instance.
            This API can be used to check fields on the created instances
            and to pass it as an argument to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithExactArguments(System.Action)" />.
            <code>
            [TestMethod,Isolated]
            public void FakeFutureInstance_GetInstance()
            {
               var handle = Isolate.Fake.NextInstance&lt;RealLogger&gt;();
               var item = Factory.CreateRealLogger();
            
               Assert.AreSame(item, Isolate.Verify.GetInstancesOf(handle)[0]);
            }
            [TestMethod,Isolated]
            public void Fake_MultipleFutureInstances_CheckFutureFields()
            {
               var handle = Isolate.Fake.AllInstances&lt;Dependency&gt;();
               ClassUnderTest.AddCheckingTwoInternalDependencies(1, 2);
            
               var instance2 = Isolate.Verify.GetInstancesOf(fake)[1];
            
               Assert.AreEqual(2, instance2.field);
            }
            [TestMethod]
            </code></example>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler">
      <summary>
            Returned by <seealso cref="P:TypeMock.ArrangeActAssert.Isolate.Verify" />, this interface contains methods for verifying the method calls and checking their arguments.
            </summary>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.GetTimesCalled``1(System.Func{``0})">
      <summary>
            Overloaded. Returns the number of times a method was called.
            </summary>
      <param name="func">A method in the form of a Lambda Expression that we want to count the calls on.</param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if there was no behavior set on the object before.
            </exception>
      <remarks>
            The count is regardless of arguments, and can work on both instance and static methods. It works also on properties and indexers.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.GetTimesCalled in order to count the calls:
            <code>
            [TestMethod]
            [Isolated]
            public void GetTimesCalledExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               string entry = fake.GetEntry();
            
               int count = Isolate.Verify.GetTimesCalled(() =&gt; fake.GetEntry());
               
               Assert.AreEqual(1, count);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.GetTimesCalled(System.Action)">
      <summary>
            Overloaded. Returns the number of times a method was called.
            </summary>
      <param name="action">A coid method in the form of a Lambda Expression that we want to count the calls on.</param>
      <exception cref="T:TypeMock.TypeMockException">
            Thrown if there was no behavior set on the object before.
            </exception>
      <remarks>
            The count is regardless of arguments, and can work on both instance and static methods. It works also on properties and indexers.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify.GetTimesCalled in order to count the calls:
            <code>
            [TestMethod]
            [Isolated]
            public void GetTimesCalledExample()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               int count = Isolate.Verify.GetTimesCalled(() =&gt; fake.Write("Hello"));
               
               Assert.AreEqual(1, count);
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithAnyArguments(System.Action)">
      <summary>
            Overloaded. Verifies that a method was called, without checking its arguments.
            </summary>
      <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            When arguments are specified, they are ignored in the verification.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               // We did not check the call for argument matching so this verification should pass
               Isolate.Verify.WasCalledWithAnyArguments(() =&gt; fake.Write("Goodbye"));
            }
            </code></example>
      <seealso cref="M:TypeMock.ArrangeActAssert.Verifier.WasCalledWithExactArguments(System.Action)" />
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithAnyArguments``1(System.Func{``0})">
      <summary>
            Overloaded. Verifies that a method was called, without checking its arguments.
            </summary>
      <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            When arguments are specified, they are ignored in the verification.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was called:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;(Members.ReturnNulls);
            
               int x = fake.GetCount();
            
               Isolate.Verify.WasCalledWithAnyArguments(() =&gt; fake.GetCount());
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithExactArguments(System.Action)">
      <summary>
            Overloaded. Verifies that a method was called, and checking its arguments.
            </summary>
      <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called with the specified arguments.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was called 
            with a specific set of arguments:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled_WithExactArguments()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               // As we're verifying the call was made with exact arguments, this verification should fail
               Isolate.Verify.WasCalledWithExactArguments(() =&gt; fake.Write("Goodbye")); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithExactArguments``1(System.Func{``0})">
      <summary>
            Overloaded. Verifies that a method was called, and checking its arguments.
            </summary>
      <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was not called with the specified arguments.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was called 
            with a specific set of arguments:
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasCalled_WithExactArguments()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Write("Hello");
            
               // As we're verifying the call was made with exact arguments, this verification should fail
               Isolate.Verify.WasCalledWithExactArguments(() =&gt; fake.Write("Goodbye")); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalled(System.Action)">
      <summary>
            Overloaded. Verifies that a method was not called regardless of parameters.
            </summary>
      <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was called at least once.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment();
            
               // This verification should fail
               Isolate.Verify.WasNotCalled(() =&gt; fake.Increment()); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalled``1(System.Func{``0})">
      <summary>
            Overloaded. Verifies that a method was not called regardless of parameters.
            </summary>
      <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was called at least once.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was not called 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment();
            
               // This verification should fail
               Isolate.Verify.WasNotCalled(() =&gt; fake.Increment()); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalledWithExactArguments(System.Action)">
      <summary>
            Overloaded. Verifies that a method was not called with specified parameters.
            </summary>
      <param name="action">A void method in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was called at least once with the specified parameters.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was not called with arguments 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment(1);
            
               // This verification should fail
               Isolate.Verify.WasNotCalledWithExactArguments(() =&gt; fake.Increment(1)); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalledWithExactArguments``1(System.Func{``0})">
      <summary>
            Overloaded. Verifies that a method was not called with specified parameters.
            </summary>
      <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called with specified parameters.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, or chain of methods was called at least once with the specified parameters.
            </exception>
      <remarks>
            This can also be a chain of methods. In that case, the verification is on the entire chain, and not part of it.
            </remarks>
      <example>
            This example shows how to use Isolate.Verify in order to check a method was not called with arguments 
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodWasNotCalled()
            {
               RealLogger fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
               fake.Increment(1);
            
               // This verification should fail
               Isolate.Verify.WasNotCalledWithExactArguments(() =&gt; fake.Increment(1)); 
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalledWithArguments``1(System.Func{``0})">
      <summary>
            Overloaded. Verifies that a method was not called with arguments matching custom verifier.
            </summary>
      <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, was called with arguments matching the custom verifier.
            </exception>
      <remarks>
            Calls to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalledWithArguments``1(System.Func{``0})">WasCalledWithArguments</see> must be followed with call to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">Matching()</see> method.
            </remarks>
      <example>
            The following example verifies a method was not called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(-1);
            
                Isolate.Verify.WasNotCalledWithArguments(() =&gt; fake.Log(0)).Matching(args =&gt; (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was not called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(-1, "rts");
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0, null))
                    .Matching(args =&gt; ((int) args[0] &gt; 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalledWithArguments(System.Action)">
      <summary>
            Overloaded. Verifies that a method was not called with arguments matching custom verifier.
            </summary>
      <param name="action">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, was not called with arguments matching the custom verifier.
            </exception>
      <remarks>
            Calls to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasNotCalledWithArguments``1(System.Func{``0})">WasCalledWithArguments</see> must be followed with call to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">Matching()</see> method.
            </remarks>
      <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(-1);
            
                Isolate.Verify.WasNotCalledWithArguments(() =&gt; fake.Log(0)).Matching(args =&gt; (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was not called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(-1, "rts");
            
                Isolate.Verify.WasNotCalledWithArguments(() =&gt; fake.Log(0, null))
                    .Matching(args =&gt; ((int) args[0] &gt; 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments``1(System.Func{``0})">
      <summary>
            Overloaded. Verifies that a method was called, and checking its arguments using custom verifier.
            </summary>
      <param name="func">A method returning a value in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, was not called with arguments matching the custom verifier.
            </exception>
      <remarks>
            Calls to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments``1(System.Func{``0})">WasCalledWithArguments</see> must be followed with call to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">Matching()</see> method.
            </remarks>
      <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1);
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0)).Matching(args =&gt; (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1, "str");
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0, null))
                    .Matching(args =&gt; ((int) args[0] &gt; 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code></example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments(System.Action)">
      <summary>
            Overloaded. Verifies that a method was called, and checking its arguments using custom verifier.
            </summary>
      <param name="action">A method in the form of a Lambda Expression that we want to verify if was called.</param>
      <exception cref="T:TypeMock.VerifyException">
            Thrown if the method, was not called with arguments matching the custom verifier.
            </exception>
      <remarks>
            Calls to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.WasCalledWithArguments``1(System.Func{``0})">WasCalledWithArguments</see> must be followed with call to <see cref="M:TypeMock.ArrangeActAssert.Fluent.IArgumentsMatcher.Matching(System.Predicate{System.Object[]})">Matching()</see> method.
            </remarks>
      <example>
            The following example verifies a method was called with positive int value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1);
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0)).Matching(args =&gt; (int) args[0] &gt; 0);
            }
            </code>
            The following example verifies a method was called with positive int value and exact string value.
            <code>
            [TestMethod]
            [Isolated]
            public void VerifyMethodCalledWithMatchingArguments()
            {
                var fake = Isolate.Fake.Instance&lt;RealLogger&gt;();
            
                fake.Log(1, "str");
            
                Isolate.Verify.WasCalledWithArguments(() =&gt; fake.Log(0, null))
                    .Matching(args =&gt; ((int) args[0] &gt; 0) &amp;&amp; ((string) args[1] == "str"));
            }
            </code></example>
    </member>
    <member name="P:TypeMock.ArrangeActAssert.Fluent.IVerifyCallsHandler.NonPublic">
      <summary>
            Provides an entry point to verify non-public (private, protected, internal) members
            </summary>
      <example>
        <code>
            [TestMethod, Isolated]
            public void FakeReturnValue_BasedOn_ExactMethodArgs()
            {
                var fake = Isolate.Fake.Instance&lt;Dependency&gt;();
            
                Isolate.NonPublic.WhenCalled(fake, "MethodReturnInt").WithExactArguments("typemock", 1).WillReturn(10);
                Isolate.NonPublic.WhenCalled(fake, "MethodReturnInt").WithExactArguments("unit tests", 2).WillReturn(50);
                Isolate.WhenCalled(() =&gt; fake.CallPrivate(" ", 0)).CallOriginal();
            
                var result = new tested().SimpleCalculation(fake);
                Isolate.Verify.NonPublic.WasNotCalled(typeof(Dependency), "MethodReturnInt");
            }
             }
            </code>
      </example>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.FakeLog.FakeLogDataExtensions.GetSignature(System.Reflection.MethodBase)">
      <summary>
            Return the method signature as a string.
            </summary>
      <param name="method">The Method</param>
      <returns>Method signature</returns>
    </member>
    <member name="M:TypeMock.ArrangeActAssert.FakeLog.FakeLogDataExtensions.TypeName(System.Type)">
      <summary>
            Get full type name with full namespace names
            </summary>
      <param name="type">Type. May be generic or nullable</param>
      <returns>Full type name, fully qualified namespaces</returns>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Action`5">
      <summary>
            An expansion of the Action delegate to 5 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Action`6">
      <summary>
            An expansion of the Action delegate to 6 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Action`7">
      <summary>
            An expansion of the Action delegate to 7 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Action`8">
      <summary>
            An expansion of the Action delegate to 8 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Action`9">
      <summary>
            An expansion of the Action delegate to 9 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Action`10">
      <summary>
            An expansion of the Action delegate to 10 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Func`6">
      <summary>
            An expansion of the Func delegate to 5 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Func`7">
      <summary>
            An expansion of the Func delegate to 6 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Func`8">
      <summary>
            An expansion of the Func delegate to 7 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Func`9">
      <summary>
            An expansion of the Func delegate to 8 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Func`10">
      <summary>
            An expansion of the Func delegate to 9 arguments.
            </summary>
    </member>
    <member name="T:TypeMock.ArrangeActAssert.ExpandDelegates.Func`11">
      <summary>
            An expansion of the Func delegate to 10 arguments.
            </summary>
    </member>
  </members>
</doc>